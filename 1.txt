;;Automatically save off when called
;;;;setwindow 20, 20, 24, 31, 14, 14, 0, 2, 20, 1, 1, "img/msgbox.bmp", 10, 10 
;;;;setwindow 95, 480, 21, 3, 29, 29, 0, 4, 20, 0, 1, "img/msgbox2.bmp", 80, 470 
*text_cw
  erasetextwindow 0
  getcursorpos %tmp1, %tmp2
  amsp SP_CLICK, %tmp1, %tmp2
  amsp SP_CLICK_MINI, %tmp1, %tmp2
  if %adv_talkmode == 1 amsp SP_CLICK, 675, 546 ;If talk mode, display star at the bottom right
  vsp SP_CLICK, 1
  if %adv_talkmode == 100 vsp SP_CLICK_MINI, 1 : vsp SP_CLICK, 0  ;If speak mode, display a small star
  print 1
;;;
  btndef clear
  if %adv_talkmode == 0 goto *text_cw_l1        ;not talk mode
  if %adv_talkmode == 100 goto *text_cw_l1      ;speak mode
  if %adv_noroi_off == 1 goto *text_cw_l1
  exbtn_d "P816C817"  ;816=SP_USAGI, 817=SP_USAGI_R
  exbtn SP_USAGI, 1001, "C816P817"
*text_cw_l1
;;;
  if %save_flag == 1 saveon
*text_cw_loop
  getpage  ;Capture PageUp, PageDown
  textbtnwait %ret
  if %ret == 0 goto *text_cw_next  ;left click
  if %ret == -1 gosub *text_cw_rclick  ;right click
  if %ret == -12 gosub *text_cw_pageup
  if %ret == -2 gosub *text_cw_pageup
  if %ret == 101 gosub *text_cw_pageup
  if %ret == 1001 gosub *noroi_loop
  goto *text_cw_loop
*text_cw_next
  vsp SP_USAGI, 0
  vsp SP_USAGI_R, 0
  vsp SP_CLICK, 0
  vsp SP_CLICK_MINI, 0
  print 1
  texec  ;Erase text in case of page break
  erasetextwindow 1
  saveoff
  return
*text_cw_pageup
  vsp SP_CLICK, 0
  vsp SP_CLICK_MINI, 0
  print 1
  systemcall lookback
  vsp SP_CLICK, 1
  if %adv_talkmode == 100 vsp SP_CLICK, 0 : vsp SP_CLICK_MINI, 1
  print 1
  return
*text_cw_rclick
  if %adv_rmode == 0 return
  vsp SP_CLICK, 0
  vsp SP_CLICK_MINI, 0
  print 1
  gosub *rclick_menu
;;  systemcall rmenu
  vsp SP_CLICK, 1
  if %adv_talkmode == 100 vsp SP_CLICK, 0 : vsp SP_CLICK_MINI, 1
  print 1
  return

*rclick_menu
  lsp SP_RC_BACK, ":c;img/black.bmp", 0, 0, 150
  lsp SP_RC_1, ":s/30,30,1;#DDDDDD#FFFFFFErase Text", 300, 140
  lsp SP_RC_2, ":s/30,30,1;#DDDDDD#FFFFFFRecollect", 300, 170
  lsp SP_RC_3, ":s/30,30,1;#DDDDDD#FFFFFFSave", 300, 200
  lsp SP_RC_4, ":s/30,30,1;#DDDDDD#FFFFFFLoad", 300, 230
  lsp SP_RC_5, ":s/30,30,1;#DDDDDD#FFFFFFLaunch Interpreter", 300, 260
  print 1
  btndef clear
  spbtn SP_RC_1, 1
  spbtn SP_RC_2, 2
  spbtn SP_RC_3, 3
  spbtn SP_RC_4, 4
  spbtn SP_RC_5, 5
*rclick_menu_loop
  btnwait2 %ret
  if %ret == 0 goto *rclick_menu_loop
  csp SP_RC_1
  csp SP_RC_2
  csp SP_RC_3
  csp SP_RC_4
  csp SP_RC_5
  csp SP_RC_BACK
  if %ret == 1 systemcall windowerase
  if %ret == 2 systemcall lookback
  if %ret == 3 systemcall save
  if %ret == 4 systemcall load
  if %ret == 5 gosub *free_eval
  btndef clear
  print 1
  return

*free_eval
  mov %gc_silent, 1
  mov %adv_rmode, 0         ;Right-click disabled
  lsp SP_RC_BACK, ":c;img/black.bmp", 0, 0, 240
  print 1
  skipoff
  mov %save_flag, 0  ;Cannot save
  gosub *create_new_env  ;Create a new environment to manipulate freely
  mov %arg0, %ret
  mov %toplevel_env, %arg0
  gosub *push  ;GC measures
  mov %arg1, %global_env
  gosub *nconc
*free_eval_loop
  mov %gc_run, 0  ;Initialize GC activation count
  mov %current_proc, %nil
  mov %current_env, %toplevel_env
  mov %adv_error, 0
  mov $sarg0, ""
  lsp SP_RC_1, ":s/14,14,1;#FFFFFFPress the Tab key to return to the game", 40, 100
  print 1
  textfield $sarg0, 30, 120, 770, 140, 10, 20, 0
  getret %ret
  if %ret == 1 goto *free_eval_end  ;Tab
  if $sarg0 == "" goto *free_eval_loop
  lsp SP_RC_1, ":s/14,14,1;#FFFFFFCalculating……", 40, 100
  print 1
  repaint
  gosub *check_lr_parenthesis
  if %ret != 0 gosub *free_eval_parenthesis_error : goto *free_eval_loop
  gosub *input_to_lobject
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *eval_form
  mov %arg0, %ret
  gosub *get_tag : if %ret == TAG_ERROR mov %adv_error, 1
  gosub *lobject_to_string
  ;;Display result with line breaks
  mov $stmp1, ":s/14,14,1;#FFFFFF"
  mov $stmp2, ":s/14,14,1;#FFFFFF"
  mov $stmp3, ":s/14,14,1;#FFFFFF"
  if %adv_error == 1 goto *free_eval_l0
  mov $sret, "The result is 『" + $sret + "』"
*free_eval_l0
  len %tmp, $sret
  if %tmp <= 80 mov $stmp, ":s/14,14,1;#FFFFFF"+$sret : goto *free_eval_l1
  ;;Enter line 2
  mid $stmp, $sret, 0, 80
  mid $sret, $sret, 80, %tmp-80
  mov $stmp, ":s/14,14,1;#FFFFFF"+$stmp
  len %tmp, $sret
  if %tmp <= 80 mov $stmp1, ":s/14,14,1;#FFFFFF"+$sret : goto *free_eval_l1
  ;;Enter line 3
  mid $stmp1, $sret, 0, 80
  mid $sret, $sret, 80, %tmp-80
  mov $stmp1, ":s/14,14,1;#FFFFFF"+$stmp1
  len %tmp, $sret
  if %tmp <= 80 mov $stmp2, ":s/14,14,1;#FFFFFF"+$sret : goto *free_eval_l1
  ;;Enter line 4
  mid $stmp2, $sret, 0, 80
  mid $sret, $sret, 80, 80
  mov $stmp2, ":s/14,14,1;#FFFFFF"+$stmp2
  mov $stmp3, ":s/14,14,1;#FFFFFF"+$sret
*free_eval_l1
  lsp SP_RC_1, $stmp, 40, 180
  lsp SP_RC_2, $stmp1, 40, 194
  lsp SP_RC_3, $stmp2, 40, 208
  lsp SP_RC_4, $stmp3, 40, 222
  print 1
  click
  csp SP_RC_2
  csp SP_RC_3
  csp SP_RC_4
  goto *free_eval_loop
*free_eval_end
  mov %gc_silent, 0
  mov %adv_rmode, 1        ;Right-click enabled
  gosub *pop
  saveon
  mov %save_flag, 1  ;Can save
  csp SP_RC_1
  csp SP_RC_BACK
  print 1
  return
*free_eval_parenthesis_error
  lsp SP_RC_1, ":s/14,14,1;#FFFFFFThe number of opening and closing brackets do not match", 40, 100
  print 1
  click
  return

;;呼ばれるとき自動的にsaveoff
*customsel
  btndef clear
  getcselnum %tmp
  getnextline %tmp1, %tmp3
  getcursorpos %tmp1, %tmp2
  sub %tmp3, %tmp2
  for %i=0 to %tmp-1
    cselbtn %i, %i+1, %tmp1, %tmp2
    add %tmp2, %tmp3  ;Height of the characters
  next
*customsel_loop
  getpage  ;Capture PageUp, PageDown
  selectbtnwait %ret
  if %ret == -12 gosub *text_cw_pageup2 : goto *customsel
  if %ret == -2 gosub *text_cw_pageup2 : goto *customsel
  if %ret <= 0 goto *customsel_loop
  if %ret > %tmp goto *customsel_loop
  saveon
  cselgoto %ret-1
*text_cw_pageup2
  systemcall lookback
  return

*noroi_loop
  rnd %adv_noroi, 530
  add %adv_noroi, 85
  amsp SP_NOROI_HALF, %adv_noroi, 338
  amsp SP_NOROI, %adv_noroi, 338
  amsp SP_NOROI_D1, %adv_noroi, 338
  amsp SP_NOROI_D2, %adv_noroi, 338
  amsp SP_NOROI_HD1, %adv_noroi, 338
  amsp SP_NOROI_HD2, %adv_noroi, 338
  lsph SP_TMP, ":s/30,30,1;#FFFFFFKill count", 550, 40
  itoa2 $sarg0, %adv_noroi_kill
  if %adv_noroi_kill < 10 mov $sarg0, ":s/50,50,0;#FFFFFF" + $sarg0
  if %adv_noroi_kill >= 10 mov $sarg0, ":s/30,50,0;#FFFFFF" + $sarg0
  lsph SP_TMP1, $sarg0, 650, 20
  vsp SP_NOROI_HALF, 1
  vsp SP_TMP, 1
  vsp SP_TMP1, 1
  mov %adv_noroi_frame, 0
*noroi_loop_l1
  resettimer
  print 1
  waittimer 33
;;
  trap off
  inc %adv_noroi_frame
  if %adv_noroi_frame == 10 vsp SP_NOROI_HALF, 0 : vsp SP_NOROI, 1
  if %adv_noroi_frame == 20 vsp SP_NOROI_HALF, 1 : vsp SP_NOROI, 0
  trap *noroi_loop_judge
;;
  if %adv_noroi_frame < 30 goto *noroi_loop_l1
  vsp SP_NOROI_HALF, 0
  csp SP_TMP
  csp SP_TMP1
  trap off
  delay 200
  print 1
  return

*noroi_loop_judge
  getmousepos %adv_noroi_mx, %adv_noroi_my
  if %adv_noroi_frame <10 goto *noroi_loop_judge_h
  if %adv_noroi_frame >=20 goto *noroi_loop_judge_h
  if %adv_noroi_mx > %adv_noroi+20 && %adv_noroi_mx < %adv_noroi+85 && %adv_noroi_my > 388 && %adv_noroi_my < 470 goto *noroi_loop_hit
  goto *noroi_loop_l1
*noroi_loop_judge_h
  if %adv_noroi_mx > %adv_noroi+20 && %adv_noroi_mx < %adv_noroi+85 && %adv_noroi_my > 403 && %adv_noroi_my < 470 goto *noroi_loop_hit_h
  goto *noroi_loop_l1

*noroi_loop_hit
  inc %adv_noroi_kill
  mov %adv_noroi_frame, 0
  vsp SP_NOROI, 0
  vsp SP_NOROI_D1, 1
  csp SP_TMP1
  itoa2 $sarg0, %adv_noroi_kill
  if %adv_noroi_kill < 10 mov $sarg0, ":s/50,50,1;#FFFFFF" + $sarg0
  if %adv_noroi_kill >= 10 mov $sarg0, ":s/30,50,0;#FFFFFF" + $sarg0
  lsp SP_TMP1, $sarg0, 650, 20
*noroi_loop_hit_loop
  resettimer
  if %adv_noroi_frame == 6 vsp SP_NOROI_D1, 0 : vsp SP_NOROI_D2, 1
  inc %adv_noroi_frame
  print 1
  waittimer 33
  if %adv_noroi_frame < 12 goto *noroi_loop_hit_loop
  vsp SP_NOROI_D2, 0
  csp SP_TMP
  csp SP_TMP1
  print 1
  return

*noroi_loop_hit_h
  inc %adv_noroi_kill
  mov %adv_noroi_frame, 0
  vsp SP_NOROI_HALF, 0
  vsp SP_NOROI_HD1, 1
  itoa2 $sarg0, %adv_noroi_kill
  if %adv_noroi_kill < 10 mov $sarg0, ":s/50,50,1;#FFFFFF" + $sarg0
  if %adv_noroi_kill >= 10 mov $sarg0, ":s/30,50,0;#FFFFFF" + $sarg0
  lsp SP_TMP1, $sarg0, 650, 20
*noroi_loop_hit_loop_h
  resettimer
  if %adv_noroi_frame == 6 vsp SP_NOROI_HD1, 0 : vsp SP_NOROI_HD2, 1
  inc %adv_noroi_frame
  print 1
  waittimer 33
  if %adv_noroi_frame < 12 goto *noroi_loop_hit_loop_h
  vsp SP_NOROI_HD2, 0
  csp SP_TMP
  csp SP_TMP1
  print 1
  return

*confirm_abort
Arisa "It's taking an unusually long time... There might be an infinite loop. Do you want to stop the calculation?"
csel "Stop", *confirm_abort_abort, "Continue", *confirm_abort_resume
*confirm_abort_resume
  mov %eval_count, 0
  return
*confirm_abort_abort
  return

*parenthesis_error
textclear
  r_show ari_die
Arisa: "The number of opening and closing parentheses do not match"\
  r_show ari_n
  return

*trap_init
  trap *trap_init_l1
*trap_init_l1
  trap off
  return

*img_init
  lsph SP_CLICK, ":l/4,<200,200,200,200>,0;img/click.bmp", 0, 0
  lsph SP_CLICK_MINI, ":l/4,<200,200,200,200>,0;img/click_m.bmp", 0, 0;;;
  lsph SP_USAGI, ":c;img/usagi.bmp", 0, 445
  lsph SP_USAGI_R, ":c;img/usagi_r.bmp", 0, 445
  lsph SP_NOROI_HALF, ":l;img/noroi_half.bmp", 0, 338
  lsph SP_NOROI, ":l;img/noroi.bmp", 0, 338
  lsph SP_NOROI_D1, ":l;img/noroi_d1.bmp", 0, 338
  lsph SP_NOROI_D2, ":l;img/noroi_d2.bmp", 0, 338
  lsph SP_NOROI_HD1, ":l;img/noroi_hd1.bmp", 0, 338
  lsph SP_NOROI_HD2, ":l;img/noroi_hd2.bmp", 0, 338
  lsph SP_DUMMY, ":s#000000na", 1000, 1000
  return

*show_wait_picture
  csp SP_TMP
  rnd %adv_tmp, 2
  if %adv_tmp == 0 lsp SP_TMP, ":c;img/moji.bmp", 0, 0
  if %adv_tmp == 1 lsp SP_TMP, ":c;img/nanyano.bmp", 0, 0
  getspsize SP_TMP, %adv_tmp1, %adv_tmp2
  div %adv_tmp1, 2
  mov %adv_tmp1, 400 - %adv_tmp1
  mov %adv_tmp2, 590 - %adv_tmp2
  amsp SP_TMP, %adv_tmp1, %adv_tmp2
  print 1
  return

*ex_init
  mov %adv_rmode, 0         ;Right-click disabled
  bgm ms_ex
  csp SP_R : csp SP_L
  bg black, E_NORMAL
  r_load ari_n
  bg "img/blackboard.bmp", E_FAST
  skipoff
  mov %adv_tmp, 0
  mov %save_flag, 0  ;Saving disabled
*ex_init_env
  gosub *create_new_env  ;Create a new environment that can be freely modified
  mov %arg0, %ret
  mov %toplevel_env, %arg0
  gosub *push  ;GC measure
  mov %arg1, %global_env
  gosub *nconc
  return

*ex_rep
  mov %gc_run, 0  ;Initialize the number of GC activations
  mov %current_proc, %nil
  mov %current_env, %toplevel_env
  mov %adv_error, 0
  if %in_ex_test != 0 goto *ex_rep_get_answer
  mov $sarg0, ""
  textclear
  gosub $problem_label
  textfield $sarg0, 30, 120, 770, 140, 10, 20, 0
  getret %ret
  if %ret == 1 goto $tab_label  ;Tab
  if $sarg0 == "" goto $ret_label
  textclear
!s0Arisa: "Calculating..."!sd
  repaint
  gosub *check_lr_parenthesis
  if %ret != 0 gosub *parenthesis_error : goto $ret_label
  goto *ex_rep_exec
*ex_rep_get_answer
  gosub *ex_test_set_answer
*ex_rep_exec
  gosub *input_to_lobject
  mov %arg0, %ret
  gosub *push
  mov %arg1, %toplevel_env
  gosub *eval_form
  mov %arg0, %ret
  gosub *get_tag : if %ret == TAG_ERROR mov %adv_error, 1
  gosub *push
  gosub *lobject_to_string
  if %in_ex_test != 0 goto $suc_label
  textclear
  if %adv_error == 1 goto *ex_rep_error
Arisa: "The result is 『$sret』"\
  goto $suc_label
*ex_rep_error
Arisa: "There is an error in the program"
#33FF33$sret#FFFFFF\
  goto $suc_label

;;; ex_check_pass($label)
*ex_check_pass
  if %in_ex_test == 0 goto $sarg0
  goto *ex_test_pass

;;; ex_check_pass_end($label)
*ex_check_pass_end
  if %in_ex_test == 0 goto $sarg0
  goto *ex_test_pass_end

;;; ex_check_fail($label)
*ex_check_fail
  if %in_ex_test == 0 goto $sarg0
  goto *ex_test_fail

;;; ex_test_set_answer()
*ex_test_set_answer
  if $suc_label == "*ex02_check" mov $sarg0, "(define x 4)"
  if $suc_label == "*ex02_2_check" mov $sarg0, "(* (+ x 3) 4)"
  if $suc_label == "*ex03_check" mov $sarg0, "'hayate"
  if $suc_label == "*ex03_2_check" mov $sarg0, "(define fate 'nanoha)"
  if $suc_label == "*ex03_3_check" mov $sarg0, "fate"
  if $suc_label == "*ex04_check" mov $sarg0, "(define x '(a b c))"
  if $suc_label == "*ex04_2_check" mov $sarg0, "(car x)"
  if $suc_label == "*ex04_3_check" mov $sarg0, "(cdr x)"
  if $suc_label == "*ex05_check" mov $sarg0, "(define (f x) (car (cdr x)))"
  if $suc_label == "*ex05_2_check" mov $sarg0, "(f '(a b c d))"
  if $suc_label == "*ex06_check" mov $sarg0, "(define (s n) (if (= n 0) 0 (+ n (s (- n 1)))))"
  if $suc_label == "*ex06_2_check" mov $sarg0, "(s 10)"
  if $suc_label == "*ex07_check" mov $sarg0, "(define (len x) (if (null? x) 0 (+ 1 (len (cdr x)))))"
  if $suc_label == "*ex07_2_check" mov $sarg0, "(len '(a b c))"
  if $suc_label == "*ex08_check" mov $sarg0, "(define (f x) (lambda (y) (+ x y)))"
  if $suc_label == "*ex08_2_check" mov $sarg0, "((f 6) 66)"
  if $suc_label == "*ex09_check" mov $sarg0, "(define (si n acc) (if (= n 0) acc (si (- n 1) (+ acc n))))"
  if $suc_label == "*ex09_2_check" mov $sarg0, "(s 10)"
  if $suc_label == "*ex11_check" mov $sarg0, "(define (map1 f x) (if (null? x) x (cons (f (car x)) (map1 f (cdr x)))))"
  if $suc_label == "*ex11_2_check" mov $sarg0, "(map1 (lambda (n) (+ n 1)) '(1 2))"
  if $suc_label == "*ex12_check" mov $sarg0, "(define (muli x y acc) (if (eq? y (zero)) acc (muli x (dec y) (add x acc))))"
  if $suc_label == "*ex12_2_check" mov $sarg0, "(mul (inc (inc (zero))) (inc (inc (inc (zero)))))"
  return

;;; ex_test_pass_log($test_name)
*ex_test_pass_log
  gosub *print_string
!s0【#00FF00pass#FFFFFF】　$sret!sd
  return

;;; ex_test_pass($label)
*ex_test_pass
  gosub *spush
  mov $sarg0, $problem_label
  gosub *ex_test_pass_log
  gosub *spop
  goto $sret

;;; ex_test_pass_end($ignored_label)
*ex_test_pass_end
  mov $sarg0, $problem_label
  gosub *ex_test_pass_log
  goto *ex_test_next_problem

;;; ex_test_fail($ignored_label)
*ex_test_fail
  mov $sarg0, $problem_label
  gosub *print_string
!s0【#FF0000fail#FFFFFF】　$sret!sd
*ex_test_next_problem
  mov %sp, %in_ex_test  ; restore %sp
  gosub *ex_init_env
  if $suc_label == "*ex02_check" goto *ex03
  if $suc_label == "*ex02_2_check" goto *ex03
  if $suc_label == "*ex03_check" goto *ex04
  if $suc_label == "*ex03_2_check" goto *ex04
  if $suc_label == "*ex03_3_check" goto *ex04
  if $suc_label == "*ex04_check" goto *ex05
  if $suc_label == "*ex04_2_check" goto *ex05
  if $suc_label == "*ex04_3_check" goto *ex05
  if $suc_label == "*ex05_check" goto *ex06
  if $suc_label == "*ex05_2_check" goto *ex06
  if $suc_label == "*ex06_check" goto *ex07
  if $suc_label == "*ex06_2_check" goto *ex07
  if $suc_label == "*ex07_check" goto *ex08
  if $suc_label == "*ex07_2_check" goto *ex08
  if $suc_label == "*ex08_check" goto *ex09_prev
  if $suc_label == "*ex08_2_check" goto *ex09_prev
  if $suc_label == "*ex09_check" goto *ex11
  if $suc_label == "*ex09_2_check" goto *ex11
  if $suc_label == "*ex11_check" goto *ex12_prev
  if $suc_label == "*ex11_2_check" goto *ex12_prev
  if $suc_label == "*ex12_check" goto *ex_test_done
  if $suc_label == "*ex12_2_check" goto *ex_test_done

*ex_test_done
done.\
  mov %sp, %in_ex_test  ; restore %sp
  mov %in_ex_test, 0
  return

*ex_test_start
  mov %in_ex_test, %sp  ; save %sp
  gosub *ex_init_env
  goto *ex02

;;;;;;;;;;
;;;Everything starts from here……
;;;;;;;;;;
*main_game_start
  mov %in_ex_test, 0
  mov %adv_rmode, 1  ;;Honestly, it’s quite tough……
  bgmfadeout 100
  gosub *get_vol
  !sd
  gosub *img_init
saveoff

;;;;;Logo Start
  lsph SP_LOGO0, ":l;img/magic1.bmp", 0, 0
  lsph SP_LOGO1, ":l;img/magic2.bmp", 0, 0
  lsph SP_LOGO_LAMBDA, ":l;img/lambda.bmp", 0, 0
  lsph SP_LOGO_KUMI, ":l;img/kumi.bmp", 0, 0
  lsph SP_LOGO_SAKURA, ":l;img/sakura.bmp", 0, 0
  lsph SP_LOGO_KARASU, ":l;img/karasu.bmp", 0, 0
  mov %adv_tmp, 0  ;Angle*100
  mov %adv_tmp1, 50 ;Angular velocity
  gosub *trap_init
  trap *logo_loop_end
*logo_loop
  resettimer
  mov %adv_tmp2, %adv_tmp
  div %adv_tmp2, 100
  drawfill 0, 0, 0

mov %adv_tmp3, %adv_tmp-25500
if %adv_tmp3 < 0 mov %adv_tmp3, 0
  drawsp2 SP_LOGO0, 0, 255-%adv_tmp3/200, 400, 300, 125, 125, %adv_tmp2
  drawsp2 SP_LOGO1, 0, 255-%adv_tmp3/200, 400, 300, 125, 125, -%adv_tmp2
  drawsp2 SP_LOGO_LAMBDA, 0, %adv_tmp3/200, 400, 300, 125, 125, 0
  draw
  gettimer %adv_tmp3
  if %adv_tmp3 > 33 goto *logo_loop_l1
  wait 33-%adv_tmp3
  goto *logo_loop_l2
*logo_loop_l1
  wait 0
*logo_loop_l2
  add %adv_tmp1, 2
  add %adv_tmp, %adv_tmp1
  if %adv_tmp < 76500 goto *logo_loop

mov %adv_tmp, 400
*logo_loop2
  resettimer
  drawfill 0, 0, 0
  drawsp2 SP_LOGO_LAMBDA, 0, 255, %adv_tmp, 300, 125, 125, 0
  draw
  sub %adv_tmp, 15
  gettimer %adv_tmp3
  if %adv_tmp3 > 33 goto *logo_loop2_l1
  wait 33-%adv_tmp3
  goto *logo_loop2_l2
*logo_loop2_l1
  wait 0
*logo_loop2_l2
  if %adv_tmp > 100 goto *logo_loop2

mov %adv_tmp, 0
*logo_loop3
  resettimer
  drawfill 0, 0, 0
  drawsp2 SP_LOGO_LAMBDA, 0, 255, 100, 300, 125, 125, 0
  drawsp2 SP_LOGO_KUMI, 0, %adv_tmp, 208, 300, 125, 125, 0
  drawsp2 SP_LOGO_KARASU, 0, %adv_tmp, 550, 300, 125, 125, 0
  draw
  add %adv_tmp, 6
  gettimer %adv_tmp3
  if %adv_tmp3 > 33 goto *logo_loop3_l1
  wait 33-%adv_tmp3
  goto *logo_loop3_l2
*logo_loop3_l1
  wait 0
*logo_loop3_l2
  if %adv_tmp < 255 goto *logo_loop3

mov %adv_tmp, -40
*logo_loop4
  mov %adv_tmp2, %adv_tmp
  mul %adv_tmp2, 125
  div %adv_tmp2, 100
  resettimer
  drawfill 0, 0, 0
  drawsp2 SP_LOGO_LAMBDA, 0, 255, 100, 300, 125, 125, 0
  drawsp2 SP_LOGO_KUMI, 0, 255, 208, 300, 125, 125, 0
  drawsp2 SP_LOGO_SAKURA, 0, 255, 319, %adv_tmp2, 125, 125, -120-%adv_tmp
  drawsp2 SP_LOGO_KARASU, 0, 255, 550, 300, 125, 125, 0
  draw
  add %adv_tmp, 4
  gettimer %adv_tmp3
  if %adv_tmp3 > 33 goto *logo_loop4_l1
  wait 33-%adv_tmp3
  goto *logo_loop4_l2
*logo_loop4_l1
  wait 0
*logo_loop4_l2
  if %adv_tmp < 240 goto *logo_loop4

*logo_loop_end
  trap off
  drawfill 0, 0, 0
  drawsp2 SP_LOGO_LAMBDA, 0, 255, 100, 300, 125, 125, 0
  drawsp2 SP_LOGO_KUMI, 0, 255, 208, 300, 125, 125, 0
  drawsp2 SP_LOGO_SAKURA, 0, 255, 319, 300, 125, 125, 0
  drawsp2 SP_LOGO_KARASU, 0, 255, 550, 300, 125, 125, 0
  draw
delay 1500
  csp SP_LOGO0
  csp SP_LOGO1
  csp SP_LOGO_LAMBDA
  csp SP_LOGO_KUMI
  csp SP_LOGO_SAKURA
  csp SP_LOGO_KARASU

setwindow 8,16,29,20,26,26,0,2,20,1,1,#FFFFFF,0,0,799,599
  gosub *show_wait_picture
!s0
Initializing...

This game takes a while to start.
It will not respond to input, so please be patient.
Please have a coffee break.
!sd
  gosub *mem_init
  gosub *set_additional_func
  mov %gc_silent, 1
  gosub *gc
  mov %gc_silent, 0
  mov %save_flag, 1  ; Save is possible
textclear
  csp SP_TMP

;;;;;タイトルの処理
*title
  textoff
mov %adv_miss, 0
mov %adv_noroi_kill, 0
;;共通記録のロード
  fileexist %adv_tmp,"arisa.szk"
  if %adv_tmp == 0 filecreate "arisa.szk"
  csvopen "arisa.szk", "rc"
  csvread %adv_clear
  csvclose
;;83+40~~120
  lsph SP_TITLE, ":l;img/title.bmp", 40, 30
  lsph SP_TITLE_SEN, ":l;img/sen.bmp", 10, 266 ;215
  lsph SP_TITLE_HOSHI, ":l;img/hoshi.bmp", 175, -30
  lsph SP_BACKGROUND, ":c;img/yama.bmp", 0, 0
  mov %adv_tmp, 300
  gosub *trap_init
  trap *title_menu_pre
*title_loop
  resettimer
  drawsp2 SP_BACKGROUND, 0, 255, 400, 600, 100, 100, 0
  drawsp2 SP_TITLE_HOSHI, 0, 255, 365, 160, %adv_tmp, %adv_tmp, 0
  drawsp2 SP_TITLE, 0, 255, 422, 167, %adv_tmp, %adv_tmp, 0
  draw
  gettimer %adv_tmp3
  if %adv_tmp3 > 33 goto *title_loop_l1
  wait 33 - %adv_tmp3
  goto *title_loop_l2
*title_loop_l1
  wait 0
*title_loop_l2
  sub %adv_tmp, 5
  if %adv_tmp > 100 goto *title_loop

drawsp2 SP_BACKGROUND, 0, 255, 400, 600, 100, 100, 0
  drawsp2 SP_TITLE_HOSHI, 0, 255, 364, 159, 100, 100, 0
  drawsp2 SP_TITLE, 0, 255, 422, 166, 100, 100, 0
  draw
  vsp SP_TITLE, 1
  vsp SP_TITLE_SEN, 1
  vsp SP_TITLE_HOSHI, 1
  vsp SP_BACKGROUND, 1
  print E_RWIPE_SLOW

mov %adv_tmp, 0
*title_loop2
  resettimer
  amsp SP_BACKGROUND, 0, %adv_tmp, 255
  print 1
  gettimer %adv_tmp3
  if %adv_tmp3 > 33 goto *title_loop2_l1
  wait 33 - %adv_tmp3
  goto *title_loop2_l2
*title_loop2_l1
  wait 0
*title_loop2_l2
  sub %adv_tmp, 10
  if %adv_tmp > -480 goto *title_loop2
  goto *title_menu

*title_menu_pre

*title_menu
  trap off
  amsp SP_BACKGROUND, 0, -480, 255
  vsp SP_TITLE, 1
  vsp SP_TITLE_SEN, 1
  vsp SP_TITLE_HOSHI, 1
  vsp SP_BACKGROUND, 1
  print 1
  ;setwindow2 #FFFFFF
;;  setwindow 8,16,20,23,26,26,0,2,20,1,1,#FFFFFF,0,0,639,479
  setwindow 8,16,29,20,26,26,0,2,20,1,1,#FFFFFF,0,0,799,599
*title_menu_l1
  bgm ms_title
  texton
  locate 11, 12
if %adv_clear >= 12 csel "From the Beginning", *title_story, "Continue", *title_load, "Supplementary Explanation", *title_condicil, "Glossary", *title_glossary, "Free Mode", *free_mode, "Extras", *title_omake, "Adjust Volume", *title_set_vol, "End", *end
csel "From the Beginning", *title_story, "Continue", *title_load, "Supplementary Explanation", *title_condicil, "Glossary", *title_glossary, "Free Mode", *free_mode, "Adjust Volume", *title_set_vol, "End", *end

*title_set_vol
  gosub *set_vol
  goto *title_menu_l1

*title_load
  systemcall load
  goto *title_menu_l1

*title_story
  locate 11, 12
if %adv_clear == 0 csel "Episode 1", *story01_pre, "Return", *title_menu_l1
if %adv_clear == 1 csel "Episode 1", *story01_pre, "Episode 2", *story02_pre, "Return", *title_menu_l1
if %adv_clear == 2 csel "Episode 1", *story01_pre, "Episode 2", *story02_pre, "Episode 3", *story03_pre, "Return", *title_menu_l1
if %adv_clear == 3 csel "Episode 1", *story01_pre, "Episode 2", *story02_pre, "Episode 3", *story03_pre, "Episode 4", *story04_pre, "Return", *title_menu_l1
if %adv_clear == 4 csel "Episode 1", *story01_pre, "Episode 2", *story02_pre, "Episode 3", *story03_pre, "Episode 4", *story04_pre, "Episode 5", *story05_pre, "Return", *title_menu_l1
if %adv_clear == 5 csel "Episode 1", *story01_pre, "Episode 2", *story02_pre, "Episode 3", *story03_pre, "Episode 4", *story04_pre, "Episode 5", *story05_pre, "Episode 6", *story06_pre, "Return", *title_menu_l1
if %adv_clear >= 6 csel "Episode 1", *story01_pre, "Episode 2", *story02_pre, "Episode 3", *story03_pre, "Episode 4", *story04_pre, "Episode 5", *story05_pre, "Episode 6", *story06_pre, "Next", *title_story2, "Return", *title_menu_l1
;;Episodes from 7 onward are divided into two: [Episodes 1, …, 6, Next] [Episodes 7, …, 12, Return]

*title_story2
  locate 11, 12
if %adv_clear == 6 csel "Episode 7", *story07_pre, "Previous", *title_story, "Return", *title_menu_l1
if %adv_clear == 7 csel "Episode 7", *story07_pre, "Episode 8", *story08_pre, "Previous", *title_story, "Return", *title_menu_l1
if %adv_clear == 8 csel "Episode 7", *story07_pre, "Episode 8", *story08_pre, "Episode 9", *story09_pre, "Previous", *title_story, "Return", *title_menu_l1
if %adv_clear == 9 csel "Episode 7", *story07_pre, "Episode 8", *story08_pre, "Episode 9", *story09_pre, "Episode 10", *story10_pre, "Previous", *title_story, "Return", *title_menu_l1
if %adv_clear == 10 csel "Episode 7", *story07_pre, "Episode 8", *story08_pre, "Episode 9", *story09_pre, "Episode 10", *story10_pre, "Episode 11", *story11_pre, "Previous", *title_story, "Return", *title_menu_l1
if %adv_clear == 11 csel "Episode 7", *story07_pre, "Episode 8", *story08_pre, "Episode 9", *story09_pre, "Episode 10", *story10_pre, "Episode 11", *story11_pre, "Episode 12", *story12_pre, "Previous", *title_story, "Return", *title_menu_l1
if %adv_clear >= 12 csel "Episode 7", *story07_pre, "Episode 8", *story08_pre, "Episode 9", *story09_pre, "Episode 10", *story10_pre, "Episode 11", *story11_pre, "Episode 12", *story12_pre, "Previous", *title_story, "Return", *title_menu_l1

*title_omake
  locate 9, 15
csel "Battle of Lambda Mountain", *yakyu, "Yagami Family Stalkers!?", *komiyan_start, "About the Ending", *hint_start, "　　Return", *title_menu_l1

*komiyan_start
  gosub *destroy_title
  goto *komiyan

*hint_start
  gosub *destroy_title
  gosub *hint

*title_condicil
  gosub *destroy_title
bgm ms_setsume
  gosub *condicil
stop
  goto *title

*title_glossary
  gosub *destroy_title
bgm ms_setsume
  gosub *glossary
stop
  goto *title

*story01_pre
  gosub *destroy_title
  goto *story01
*story02_pre
  gosub *destroy_title
  goto *story02
*story03_pre
  gosub *destroy_title
  goto *story03
*story04_pre
  gosub *destroy_title
  goto *story04
*story05_pre
  gosub *destroy_title
  goto *story05
*story06_pre
  gosub *destroy_title
  goto *story06
*story07_pre
  gosub *destroy_title
  goto *story07
*story08_pre
  gosub *destroy_title
  goto *story08
*story09_pre
  gosub *destroy_title
  goto *story09
*story10_pre
  gosub *destroy_title
  goto *story10
*story11_pre
  gosub *destroy_title
  goto *story11
*story12_pre
  gosub *destroy_title
  goto *story12

*destroy_title
  csp SP_BACKGROUND
  csp SP_TITLE
  csp SP_TITLE_HOSHI
  csp SP_TITLE_SEN
  return

*end
  end

*r_in
  getparam $sarg0
  csp SP_R
  print E_FAST
  lsph SP_R, $sarg0, 0, 0
  getspsize SP_R, %tmp1, %tmp2
  mov %tmp2, 600-%tmp2
  mov %tmp1, 790-%tmp1
  mov %tmp, 800
  vsp SP_R, 1
  trap *r_in_l1
*r_in_loop
  resettimer
  amsp SP_R, %tmp, %tmp2
  print 1
  sub %tmp, 30
  if %tmp < %tmp1 goto *r_in_l1
  gettimer %tmp3
  if %tmp3 > 33 goto *r_in_loop_l1
  wait 33-%tmp3
  goto *r_in_loop_l2
*r_in_loop_l1
  wait 0
*r_in_loop_l2
  goto *r_in_loop
*r_in_l1
  trap off
  amsp SP_R, %tmp1, %tmp2
  print 1
  return

*r_out
  getspsize SP_R, %tmp1, %tmp2
  mov %tmp2, 600-%tmp2
  mov %tmp1, 790-%tmp1
  vsp SP_R, 1
  trap *r_out_l1
*r_out_loop
  resettimer
  amsp SP_R, %tmp1, %tmp2
  print 1
  add %tmp1, 30
  if %tmp1 > 800 goto *r_out_l1
  gettimer %tmp3
  if %tmp3 > 33 goto *r_out_loop_l1
  wait 33-%tmp3
  goto *r_out_loop_l2
*r_out_loop_l1
  wait 0
*r_out_loop_l2
  goto *r_out_loop
*r_out_l1
  trap off
  csp SP_R
  print 1
  return

*l_rout
  getspsize SP_L, %tmp1, %tmp2
  mov %tmp2, 600-%tmp2
  mov %tmp1, 30
  vsp SP_L, 1
  trap *l_rout_l1
*l_rout_loop
  resettimer
  amsp SP_L, %tmp1, %tmp2
  print 1
  add %tmp1, 30
  if %tmp1 > 800 goto *l_rout_l1
  gettimer %tmp3
  if %tmp3 > 33 goto *l_rout_loop_l1
  wait 33-%tmp3
  goto *l_rout_loop_l2
*l_rout_loop_l1
  wait 0
*l_rout_loop_l2
  goto *l_rout_loop
*l_rout_l1
  trap off
  csp SP_L
  print 1
  return

*l_in
  getparam $sarg0
  lsph SP_L, $sarg0, 0, 0
  getspsize SP_L, %tmp1, %tmp2
  mov %tmp2, 600-%tmp2
  mov %tmp, 0-%tmp1
  vsp SP_L, 1
  trap *l_in_l1
*l_in_loop
  resettimer
  amsp SP_L, %tmp, %tmp2
  print 1
  add %tmp, 30
  if %tmp > 30 goto *l_in_l1
  gettimer %tmp3
  if %tmp3 > 33 goto *l_in_loop_l1
  wait 33-%tmp3
  goto *l_in_loop_l2
*l_in_loop_l1
  wait 0
*l_in_loop_l2
  goto *l_in_loop
*l_in_l1
  trap off
  amsp SP_L, 30, %tmp2
  print 1
  return

*l_out
  getspsize SP_L, %tmp1, %tmp2
  mov %tmp2, 600-%tmp2
  mov %tmp, 0-%tmp1
  mov %tmp1, 30
  vsp SP_R, 1
  trap *l_out_l1
*l_out_loop
  resettimer
  amsp SP_L, %tmp1, %tmp2
  print 1
  sub %tmp1, 30
  if %tmp1 < %tmp goto *l_out_l1
  gettimer %tmp3
  if %tmp3 > 33 goto *l_out_loop_l1
  wait 33-%tmp3
  goto *l_out_loop_l2
*l_out_loop_l1
  wait 0
*l_out_loop_l2
  goto *l_out_loop
*l_out_l1
  trap off
  csp SP_L
  print 1
  return

*talk_mode
  mov %adv_talkmode, 1
  erasetextwindow 1
  setwindow 95, 480, 21, 3, 29, 29, 0, 4, 20, 0, 1, "img/msgbox2.bmp", 80, 470 
  return

*speak_mode
  mov %adv_talkmode, 100
  erasetextwindow 0
  setwindow 20, 20, 24, 31, 14, 14, 0, 2, 20, 1, 1, "img/msgbox.bmp", 10, 10 
  return

*r_show
  getparam $sarg0
  r_load $sarg0
  print E_FAST
  return

*l_show
  getparam $sarg0
  l_load $sarg0
  print E_FAST
  return

*r_load
  getparam $sarg0
  csp SP_R
  lsph SP_R, $sarg0, 0, 0
  getspsize SP_R, %tmp1, %tmp2
  mov %tmp2, 600-%tmp2
  mov %tmp1, 790-%tmp1
  amsp SP_R, %tmp1, %tmp2
  vsp SP_R, 1
  return

*l_load
  getparam $sarg0
  csp SP_L
  lsph SP_L, $sarg0, 0, 0
  getspsize SP_L, %tmp1, %tmp2
  mov %tmp2, 600-%tmp2
  amsp SP_L, 30, %tmp2
  vsp SP_L, 1
  return

*c_show
  getparam $sarg0
  c_load $sarg0
  print E_FAST
  return

*c_load
  getparam $sarg0
  csp SP_C
  lsph SP_C, $sarg0, 0, 0
  getspsize SP_C, %tmp1, %tmp2
  mov %tmp2, 600-%tmp2
  mov %tmp1, %tmp1/2
  mov %tmp1, 400-%tmp1
  amsp SP_C, %tmp1, %tmp2
  vsp SP_C, 1
  return

*show_dgm
  getparam $sarg0
  load_dgm $sarg0
  wait_dgm
  return

*load_dgm
  getparam $sarg0
  csp SP_DGM0
  lsp SP_DGM0, $sarg0, 200, 200
  print E_FAST
  return

*wait_dgm
  getspmode %tmp1, SP_R
  getspmode %tmp2, SP_L
  textoff
  vsp SP_R, 0
  vsp SP_L, 0
  print E_FAST
  click
  vsp SP_R, %tmp1
  vsp SP_L, %tmp2
  print E_FAST
  texton
  return

*set_vol
  fileexist %adv_vol,"suzuka.ars"
  if %adv_vol == 0 filecreate "suzuka.ars"
  csvopen "suzuka.ars", "rc"
  csvread %adv_vol
  csvclose
  itoa $sadv_vol, %adv_vol
  input $sadv_vol, "Please enter the volume between 0 and 100 using single-byte characters (0=mute, 100=max)", $sadv_vol, 3, 0
  atoi %adv_vol, $sadv_vol
  if %adv_vol > 100 mov %adv_vol, 100
  if %adv_vol < 0 mov %adv_vol, 0
  bgmvol %adv_vol
  csvopen "suzuka.ars", "wc"
  csvwrite %adv_vol
  csvclose
  return

*get_vol
  fileexist %adv_vol,"suzuka.ars"
  if %adv_vol == 0 filecreate "suzuka.ars"
  csvopen "suzuka.ars", "rc"
  csvread %adv_vol
  csvclose
  bgmvol %adv_vol
  return

*story01
  mov %adv_noroi_off, 0
  stop
  csp SP_R : csp SP_L : print E_FAST
  print E_FAST
  mov %adv_clear, 0
  textclear
  bgm ms_narumi
  bg "img/blackboard.bmp", E_FAST

talk_mode
  r_in ari_n
Arisa: "Arisa here!"\
l_in suzu_n
l_show suzu_dere
Suzuka: "!? Arisa here! This is like the 2007 Masked Ranger, I'm so embarrassed"\
r_show ":l;img/arin.bmp"
Arisa: "Arrrrr"\
;; lsp SP_DGM0, ":l;img/dgm0201a.bmp", 200, 200
Arisa: "I don't really care about that"\
l_show suzu_exc
Suzuka: "Wow, it's gotten so small!"\
r_show ari_n
Arisa: "Speaking of small, it's the programming language #FFFF33Lisp#FFFFFF"\
l_show suzu_nc
Suzuka: "Lisp does not refer to one programming language, but to multiple languages."\
Alisa: "Lisp has many dialects, with various extensions from MIT and other places."\
Suzuka: "There are many dialects, such as #FFFF33CommonLisp#FFFFFF and #FFFF33eLisp#FFFFFF, and so on."\
Alisa: "There are many dialects, but the core part is simple, and although it is small, it is a very powerful language."\
Suzuka: "Once you understand the functions, you can even incorporate it into #FFFF33NScripter#FFFFFF."\

csp SP_R : csp SP_L : print E_VFAST
  bg "img/title#01.bmp", 1
  wait 1000
  delay 3000
  bgm ms_setsume
  bg "img/blackboard.bmp", E_FAST

speak_mode
  r_show ari_n
Arisa: "So, let's learn some basic Lisp grammar."\
r_show suzur_hrt
Suzuka: "I don't know why, but it's good for now."\
r_show ari_n
Arisa: "Addition in Lisp is written as follows:
#33FF33 (+ 1 2) #FFFFFF
@/
When you enter this in the interpreter dialogue screen, the answer to 1 plus 2, 3, will be displayed."\
r_show suzur_nc
Suzuka: "I can't really imagine it."\
r_show ari_n
Arisa: "In that case, right-click to open the menu, select "#FFFF33 Run Interpreter #FFFFFF", and enter /
#33FF33 (+ 1 2) #FFFFFF./
All input is half-width characters. Press the Enter key to get the result."\
r_show suzur_nc
Suzuka: "...I think I understand a little bit now.@First, parentheses, then a plus sign, the number to be added, the number to be added, and finally parentheses."\
r_show ari_n
Arisa: "That's right. For subtraction, you write
#33FF33(-5 3)#FFFFFF. #33FF33+#FFFFFF has changed to #33FF33-#FFFFFF, and the rest is the same as for addition. 5 minus 3 is calculated."\
r_show suzur_n
Suzuka: "The key is to write operators like + and - first."\
r_show ari_ase
Arisa: "...Suzuka, elementary school kids don't say things like 'operators'."\
r_show suzur_dot
Suzuka: "More importantly, I'd like to actually try it out."\
r_show ari_n
Arisa: "Okay. First, a few points to note. Multiplication can be written using #33FF33*#FFFFFF, and division can be written using #33FF33/#FFFFFF, but division is set up to "ignore the remainder". @/
r_show ari_tun
For the sake of Lisp's dignity, I'll say this, but in reality, modern Lisp can handle complex numbers as standard. @NScLisper can only handle integers because it was lazy!"\
r_show suzur_ase
Suzuka: "...Arisa-chan, elementary school students don't say things like 'complex numbers' or 'integers'"\
r_show ":l;img/arin.bmp"
Arisa: "Arin"\
r_show ari_n
Arisa: "Also, all input is half-width characters. Press the Enter key to get the result. @/
Be careful not to type in any weird expressions♪"\

gosub *ex_init
*ex01
  mov $problem_label, "*ex01_problem"
  mov $tab_label, "*ex01_end"
  mov $ret_label, "*ex01"
  mov $suc_label, "*ex01_check"
  goto *ex_rep
*ex01_problem
!s0Arisa "When you're satisfied, press the Tab key to finish."!sd
  return
*ex01_check
  gosub *pop : gosub *pop
  inc %adv_tmp
  goto *ex01

*ex01_end
  mov %adv_rmode, 1        ;右クリック有効
  gosub *pop
  saveon
  mov %save_flag, 1  ;セーブ可能
  textclear
  bgm ms_setsume
  if %adv_tmp == 1 goto *s_01_2
  if %adv_tmp == 0 goto *s_01_1
Alisa "Well, something like that."\
  goto *s_01_3
*s_01_1
  r_show ":l;img/arin.bmp"
Alisa "Aleen."\
Alisa "What do you mean you won't even try once...?"\
  goto *s_01_3
*s_01_2
Alisa "Is it okay with just one try? Well, I guess it's fine..."\
  goto *s_01_3
*s_01_3

r_show suzur_qes
Suzuka: "What was that #33FF33 (+ 1 2) #FFFFFF that came up earlier?"\
r_show ari_n
Arisa: "That's a Lisp program. In other programming languages, the actual calculation is often called "executing a program," but in Lisp, it's called evaluating the #FFFF33 expression #FFFFFF. @/
#FFFF33 expression #FFFFFF is written in the format #33FF33 (+ 1 2) #FFFFFF./
#FFFF33 evaluation #FFFFFF is calculating some value from an expression according to certain rules."\
r_show suzur_n
Suzuka: "The calculation result...or should I say the evaluation result? @Why was it displayed on the screen? /I don't remember writing a command to display it."\
r_show ari_n
Arisa: "The result of evaluating an expression is called #FFFF33value of expression#FFFFFF.@/
The Lisp interpreter automatically displays the value of the expression you input on the screen.@/
That's why the result was displayed on the screen without you having to write anything.@/
The Lisp interpreter consists of three actions: "reading", "evaluating", and "displaying".@/
This is called the "read-evaluate-print loop" or the top level."\
r_show suzur_nc
Suzuka: "To sum up, when you run a program with a Lisp interpreter, you first input an expression.@/
The interpreter reads it, @evaluates it, and @displays the result. That's the flow."\
r_show ari_n
Arisa: "Also, the whole thing like #33FF33(*3 4)#FFFFFF is called an expression, but the parts that make it up,/
#33FF33+#FFFFFF, #33FF331#FFFFFF, and #33FF332#FFFFFF, are also expressions.@/
To emphasize that it is an expression contained within an expression, we also say #FFFF33subexpression#FFFFFF"\
r_show suzur_n
Suzuka: "In other words, #33FF33(*3 4)#FFFFFF is three expressions enclosed in parentheses.@/
Also, each expression is separated by a space"\
r_show ari_n
Arisa: "The first expression that appears in the parentheses is called #FFFF33operator#FFFFFF, and the other expressions are called #FFFF33operand#FFFFFF. @/
show_dgm ":l;img/dgm0101.bmp"
In the case of #33FF33 (* 3 4) #FFFFFF, #33FF33*#FFFFFF is the operator, and #33FF333#FFFFFF and #33FF334#FFFFFF are the operands."\
r_show suzur_n
Suzuka: "An expression enclosed in parentheses is divided into an operator and an operand, and the result of the expression is the result of applying the operand to the operator."\
r_show ari_n
Arisa: "I'll be doing practice problems from time to time from now on, but at any other time, you can/
right-click to open the menu and select "Launch #FFFF33Interpreter#FFFFFF"/
and enter expressions at any time."\
r_show suzur_n
Suzuka: "It seems like it would be useful to use it to check various things during an explanation."\
  csp SP_DGM0
  csp SP_R
  bg black, E_NORMAL
  r_load ari_n
  l_load suzu_n
  bgm ms_after
  bg "img/blackboard.bmp", E_NORMAL
  talk_mode
Arisa: "According to information from Nanoha and Yuno, magic is also programmable. In other words, if we can program it..."\
Suzuka: "Eventually, we will be able to get magical powers in our hands. The incompetent people at the Space-Time Administration Bureau will no longer be acting all high and mighty."\
r_show ari_hrt
Arisa: "It wouldn't be bad to gain magical powers during spring break, would it?"\
l_show suzu_nc
Suzuka: "That's a worthwhile spring break."\
r_show ari_n
Arisa: "Hehe,!w300Hehe,!w200Ahaha,!w100
Ahahahaha!!!"\

;;;;;第1話終了;;;;;
  speak_mode
  textclear
  vsp SP_R, 0
  vsp SP_L, 0
  bg black, E_SLOW
;;共通記録の書き換え
  csvopen "arisa.szk", "rc"
  csvread %adv_clear
  csvclose
  if %adv_clear >= 1 goto *story01_after 
  mov %adv_clear, 1
  csvopen "arisa.szk", "wc"
  csvwrite %adv_clear
  csvclose
#FFFF33 Word has been added to the glossary #FFFFFF.\
*story01_after
  r_show suzur_nc
Suzuka: "What should I do?"
csel "Read supplementary explanation", *story01_condicil, "Read glossary", *story01_glossary, "Return to title", *title_back, "Proceed to Episode 2", *story02

*story01_condicil
  gosub *condicil
  goto *story01_after
*story01_glossary
  gosub *glossary
  goto *story01_after

;;;;;第2話;;;;;
*story02
  mov %adv_noroi_off, 0
  csp SP_R : csp SP_L : print E_FAST
  stop
  talk_mode
  bgm ms_narumi
  bg "img/blackboard.bmp", E_FAST
  r_in ari_n
  l_in suzu_n

talk_mode
  l_show suzu_exc
Suzuka: "Try saying 'Mamedegansu', Arisa-chan."\
r_show ari_ase
Arisa: "What's this all of a sudden... or rather, what on earth are you talking about?"\
l_show suzu_n
Suzuka: "'Mamedegansu' means 'I'm fine' in Hiroshima dialect."\
r_show ari_qes
Arisa: "Really?"\
l_show suzu_qes
Suzuka: "Huh? Didn't Arisa-chan say that a while ago?"\
Arisa: "I wonder... Speaking of dialects, I feel like I've forgotten something important."\

csp SP_R : csp SP_L : print 1
  bg "img/title#02.bmp", E_VFAST
  wait 1000
  delay 2000
  bgm ms_setsume
  bg "img/blackboard.bmp", E_FAST

speak_mode
  r_show ari_n
Arisa: "Yes, that's right. We need to decide which #FFFF33dialect#FFFFFF of Lisp to use." \
  r_show suzur_nc
Suzuka: "Well, various places have created their own extensions for Lisp, so there are different rules." \
  r_show ari_n
Arisa: "Here, let's use something similar to a dialect called #FFFF33Scheme#FFFFFF. Scheme has a compact specification and is very elegant." \
  r_show suzur_n
Suzuka: "Well, even though the syntax is Scheme-like, NScripter doesn't even meet/
that 'compact specification'." \
  r_show ":l;img/arin.bmp"
Arisa: "Ariin" \
  r_show ari_n
Arisa: "Aside from that, let's try using variables this time.@
#33FF33(define x 128)#FFFFFF
When you evaluate this expression, the Lisp interpreter #FFFF33environment#FFFFFF will remember 'variable x is 128'.@/
  show_dgm ":l;img/dgm0201a.bmp"
After evaluating this expression, when you evaluate the expression #33FF33x#FFFFFF, the result will be 128.@/
  show_dgm ":l;img/dgm0201b.bmp"
The result of evaluating a variable is called the #FFFF33value of the variable#FFFFFF." \
  csp SP_DGM0
  r_show suzur_n
Suzuka: "In other words, evaluating #33FF33(define variable-name expression)#FFFFFF lets you define a variable.@/
Also, the result of evaluating a variable is called the #FFFF33value of the variable#FFFFFF." \
  r_show ari_n
Arisa: "Don't forget that not only things enclosed in parentheses, but also x and 128 are expressions.@/
Also, if you evaluate a variable that hasn't been defined with define, it will result in an error.
For example, if you evaluate it without defining variable y, an error #33FF33y is unbound#FFFFFF will be displayed." \
  r_show suzur_dere
Suzuka: "Using an undefined variable will cause an error." \
  r_show ari_n
Arisa: "By the way, what do you think will happen if you directly evaluate an expression that represents a number, like #33FF33256#FFFFFF?" \
  r_show suzur_qes
Suzuka: "Uh, it doesn't seem like it can be anything other than 256, so I guess it stays as 256?" \
  r_show ari_n
Arisa: "That's correct. It seems like an obvious rule, but it's surprisingly important.@/
After evaluating the previous define expression,
what do you think will happen if you evaluate
#33FF33(+ x 896)#FFFFFF?" \
  r_show suzur_nc
Suzuka: "Well, won't it calculate 128 plus 896 to become 1024?" \
  r_show ari_n
Arisa: "The value of the expression is exactly that.@/
However, in the flow, when evaluating #33FF33(+ x 896)#FFFFFF,/
first, x is evaluated and becomes 128.@
Then, 896 is further evaluated to become 896, and then addition is performed by the plus.@/
  show_dgm ":l;img/dgm0202.bmp"
In this way, operands are evaluated first." \
  csp SP_DGM0
  r_show suzur_exc
Suzuka: "#33FF33(+ A B)#FFFFFF means A and B are evaluated before + is applied." \
  r_show ari_n
Arisa: "Yes. And A or B can be numbers, variables, or even expressions enclosed in parentheses. In other words,
writing an expression like
#33FF33(+ (* 3 4)(- 5 2))#FFFFFF
is also allowed." \
  r_show suzur_excc
Suzuka: "Operands are evaluated before the operator acts on them.@/
Therefore, the operands on which an operator like + acts can be numbers or expressions enclosed in parentheses, as long as the result of evaluating them is a number." \
  csp SP_DGM0
  r_show ari_ase
Arisa: "...You're grasping it surprisingly quickly. Well, let's actually try something.@/
  r_show ari_exc
Before the exercise, a few reminders again./
When you evaluate #33FF33(define name 2)#FFFFFF, the result is #33FF33name#FFFFFF.@/
You might feel it's a bit strange, but as for what on earth this is,/
we'll defer that for now, so you mustn't think too deeply about it!@/
Also, if you truly feel it's impossible, pressing the #FFFF33Tab#FFFFFF key might make something good happen." \

gosub *ex_init
*ex02
  mov $problem_label, "*ex02_problem"
  mov $tab_label, "*ex02_tab"
  mov $ret_label, "*ex02"
  mov $suc_label, "*ex02_check"
  goto *ex_rep
*ex02_problem
!s0Alisa: "First, define the value of x as 4"!sd
  return
*ex02_check
  gosub *pop : gosub *pop
  ;答え合わせ
  mov $sarg0, "x"
  gosub *create_symbol
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *find_var
  mov %arg0, %ret
  gosub *cdr
  mov %arg0, %ret
  gosub *get_tag
  mov %tmp1, %ret
  gosub *get_data
  mov %tmp2, %ret
  mov $sarg0, "*ex02_2"
  if %tmp1 == TAG_NUM && %tmp2 == 4 goto *ex_check_pass  ;S(new env)
  mov $sarg0, "*ex02_normal_miss"
  goto *ex_check_fail
*ex02_normal_miss
  r_show ari_die
  Arisa: "...What are you doing wrong? Do it again!"
  r_show ari_n
  inc %adv_tmp
  gosub *pop  ;new env<S()
  gosub *ex_init_env : goto *ex02

*ex02_2  ;S(new env)
  mov $problem_label, "*ex02_2_problem"
  mov $tab_label, "*ex02_2_tab"
  mov $ret_label, "*ex02_2"
  mov $suc_label, "*ex02_2_check"
  goto *ex_rep
*ex02_2_problem
!s0Alisa: "Next, calculate (x+3)*4"!sd
  return
*ex02_2_check
  gosub *pop  ;new object<S(input, new env)
  mov %arg0, %ret
  gosub *get_tag
  mov %tmp1, %ret
  gosub *get_data
  mov %tmp2, %ret
; Don't use ex_check_pass for ex02_2_check2
if %tmp1 == TAG_NUM && %tmp2 == 28 goto *ex02_2_check2 ;Change the value of x and check
;For the kind person who is willing to redefine x here
  mov $sarg0, "x"
  gosub *create_symbol
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *find_var
  mov %arg0, %ret
  gosub *cdr
  mov %arg0, %ret
  gosub *get_tag
  mov %tmp1, %ret
  gosub *get_data
  mov %tmp2, %ret
  mov $sarg0, "*ex02_ext"
  if %tmp1 != TAG_NUM goto *ex_check_fail
  if %tmp2 != 4 goto *ex_check_fail
  mov $sarg0, "*ex02_2_normal_miss"
  goto *ex_check_fail
*ex02_2_normal_miss
  r_show ari_die
Arisa: "No, try again!"
  r_show ari_n
  gosub *pop  ;input<S(new env)
  inc %adv_tmp
  goto *ex02_2
*ex02_ext
  r_show ari_muka
Arisa: "...You're doing some pretty interesting things. @/
  r_show ari_do
Start over!!!"
  r_show ari_n
  gosub *pop  ;input<S(new env)
  gosub *pop  ;new env<S()
  inc %adv_tmp
  gosub *ex_init_env : goto *ex02

*ex02_2_check2  ;（ｘ＋３）＊４なのかチェック
  mov $sarg0, "(set! x 997)"
  gosub *input_to_lobject
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *eval_form  ;xの値を997に書き換え
  gosub *pop  ;input<S(new env)
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *eval_form
  mov %arg0, %ret
  gosub *get_tag
  mov %tmp1, %ret
  gosub *get_data
  mov %tmp2, %ret
  mov $sarg0, "*ex02_end"
  if %tmp1 == TAG_NUM && %tmp2 == 4000 goto *ex_check_pass_end
  r_show ari_muka
Arisa: "Hey, why is it only the answer that's correct...@/
  r_show ari_do
Start over from the beginning!!!"\
  r_show ari_n
  gosub *pop  ;new env<S()
  inc %adv_tmp
  gosub *ex_init_env
  mov $sarg0, "*ex02"
  goto *ex_check_fail

*ex02_tab
csel "Continue", *ex02, "Hint", *ex02_hint,  "Return to Title", *ex02_bye

*ex02_hint
textclear
Arisa: "The variable definition is
#33FF33 (define variable name expression) #FFFFFF
よ"\
  goto *ex02

*ex02_bye
  mov %adv_rmode, 1        ;Right-click enabled
  textclear
  csp SP_R
  stop
  goto *title

*ex02_2_tab
csel "Continue", *ex02_2, "Hint", *ex02_2_hint,  "Return to Title", *ex02_2_bye

*ex02_2_hint
textclear
Arisa: "First, '(x+3)*4' is the product of x+3 and 4. @/
These two can be expressed as the formulas #33FF33(+x3)#FFFFFF and #33FF334#FFFFFF, respectively. @/
Then, because of the rule that the operands are evaluated first, the product of formula A and formula B is
#33FF33(*A B)#FFFFFF. In this case, formulas A and B are the two formulas we've already mentioned, so..."\
  goto *ex02_2

*ex02_2_bye
  mov %adv_rmode, 1        ;Right-click enabled
  textclear
  csp SP_R
  stop
  gosub *pop
  goto *title

*ex02_end
  mov %adv_rmode, 1        ;右クリック有効
  gosub *pop  ;new env<S()
  saveon
  mov %save_flag, 1  ;セーブ可能
  add %adv_miss, %adv_tmp
  bgm ms_setsume
  textclear
  if %adv_tmp == 0 goto *s_02_2
  if %adv_tmp >=3   goto *s_02_3
*s_02_1
Arisa: "Not bad"\
 goto *s_02_4
*s_02_2
r_show ari_hrt
Arisa: "No problems at all"\
 goto *s_02_4
*s_02_3
 r_show ari_ase
Arisa: "You made quite a few mistakes"\
  goto *s_02_4

*s_02_4
  r_show suzur_qes
Suzuka: "So what is a variable anyway?"\
r_show ari_n
Arisa: "A variable is a string of characters #FFFF33name #FFFFFF associated with #33FF33value #FFFFFF. @/
For now, think of values ??as numbers like 7 or 8."\
r_show suzur_nc
Suzuka: "A variable x that, when evaluated, results in 128, is the name x associated with the value 128?"\
r_show ari_n
Arisa: "In the explanation so far, we have only used simple names like #33FF33ｘ#FFFFFF, but @/
#33FF33ｽｕｚｕｋａ#FFFFFF or #33FF33ｎｏｏｈａ１９#FFFFFF,/
and you can mix in symbols, like @#33FF33スターライト−ブレーキカー！#FFFFFF,/
and you can't use parentheses like "(" or ")", and @#33FF33６６６#FFFFFF/
and numbers only are treated as #FFFF33numbers#FFFFFF, so #FFFF33names#FFFFFF can't be used"\

r_show ari_hrt
Arisa: "I'm impressed. You understand it well! @/
Also, Lisp usually doesn't distinguish between uppercase and lowercase letters, but/
NScLisper does, so be careful. @This #FFFF33name#FFFFFF is expressed in Lisp using #FFFF33symbol#FFFFFF"\
r_show suzur_qes
Suzuka: "A variable is a #FFFF33symbol#FFFFFF that is associated with a value. So what was #FFFF33variable definition#FFFFFF and/
#FFFF33variable evaluation#FFFFFF?"\
r_show ari_n
Arisa: "Defining a variable in Lisp means binding the #FFFF33 symbol #FFFFFF to the #FFFF33 value #FFFFFF. @/
For example, #33FF33 (define x 16) #FFFFFF binds the name x to the value 16./
This is called "x is #FFFF33 bound #FFFFFF to 16"\
r_show suzur_qes
Suzuka: "So instead of x binding 16, x is bound to 16? "\
r_show ari_n
Arisa: "It may be a strange way of saying it in Japanese, but I've read it in English books, so I'm sure it's true@/
r_show ari_ase
...Probably"\
r_show suzur_n
Suzuka: "I'm sure the #FFFF33environment#FFFFFF contains the binding between variables and values, right? "\
r_show ari_n
Arisa: "An environment is a collection of #FFFF33bindings#FFFFFF, which are the binding between symbols and values. /
You can add new bindings to this environment by using define. @/
And when you evaluate a variable, the name is searched for in the environment, and the corresponding value becomes the result."\
r_show suzur_qes
Suzuka: "Hey, I was just wondering. #33FF33 (+ x 1) #FFFFFF evaluates #33FF33x #FFFFFF, then #33FF33 + #FFFFFF acts on it, right? @But what if you write #33FF33 (define x 32) #FFFFFF? @ /
show_dgm ":l;img/dgm0203.bmp"
In this case, doesn't x get treated as a symbol without being evaluated? "\
r_show ari_n
Arisa: "That's a good point. /
The second operand of define gets evaluated, but the first operand gets treated as a symbol without being evaluated. @/
The only reason this happened is because "define is special"\
csp SP_DGM0
r_show suzur_ase
Suzuka: "Eh, that's not fair, Arisa-chan. Tell me~"\

csp SP_R
  bg black, E_NORMAL
  r_load ari_n
  l_load suzu_n
  bgm ms_after
  bg "img/blackboard.bmp", E_NORMAL
  talk_mode
Arisa "Well, well, no need to hurry so much. It's fine. At this rate, you should be able to use magic soon."\
  l_show suzu_qes
Suzuka "I heard from Nanoha-chan that natural talent is also necessary to use magic, but I wonder how it is with us."\
  r_show ari_tun
Arisa "That's something we can't really know."\
  l_show suzu_ase
Suzuka "...Isn't that a big problem?"\
  r_show ari_n
Arisa "But even if you don't have the talent for magic, as long as you can create the effects of magic through programming, that's enough."\
  l_show suzu_n
Suzuka "We just need to save the magic program on the wand (device) and let someone who can use magic hold it, right?"\
Arisa "Then, you should be able to activate the magic. So let's focus on programming."\
  l_show suzu_nc
Suzuka "If neither of us can use magic, we have to find someone who can."\
  r_show ari_tun
Arisa "In that case, let's leave it to Samejima. If it's him, it should be fine."@/
  r_show ari_dere
"...Age-wise."\
  l_show suzu_dot
Suzuka "No way, Arisa-chan, you don't actually believe that you can use magic after turning 25, right?"\
Arisa "...It's fine. I'm sure I've also cleared the other condition."\
  l_show suzu_dotc
Suzuka "Arisa-chan..."\

;;;;;第2話終了;;;;;
  speak_mode
  textclear
  vsp SP_R, 0
  vsp SP_L, 0
  bg black, E_SLOW
;共通記録の書き換え
  csvopen "arisa.szk", "rc"
  csvread %adv_clear
  csvclose
  if %adv_clear >= 2 goto *story02_after 
  mov %adv_clear, 2
  csvopen "arisa.szk", "wc"
  csvwrite %adv_clear
  csvclose
#FFFF33Supplementary explanation#FFFFFF has been added.
#FFFF33Glossary#FFFFFF has been added.\
*story02_after
  r_show suzur_nc
Suzuka: "What should I do?"
csel "Read supplementary explanation", *story02_condicil, "Read glossary", *story02_glossary, "Return to title", *title_back, "Proceed to Episode 3", *story03

*story02_condicil
  gosub *condicil
  goto *story02_after
*story02_glossary
  gosub *glossary
  goto *story02_after

;;;;;第3話;;;;;
*story03
  mov %adv_noroi_off, 0
  csp SP_R : csp SP_L : print E_FAST
  stop
  talk_mode
  bgm ms_narumi
  bg "img/blackboard.bmp", E_FAST
  r_in ari_n
  l_in suzu_n

Arisa: "The memory capacity of Atom's brain, which appears in the famous manga Astro Boy, is 15.8 trillion bits. Did you know that?"\
l_show suzu_exc
Suzuka: "That's right. @/
l_show suzu_ase
But, you know... if you calculate this, it comes out to less than 2 terabytes. That's surprisingly small."\

csp SP_R : csp SP_L : print 1
  bg "img/title#03.bmp", E_VFAST
  wait 1000
  delay 2000
  bgm ms_setsume
  bg "img/blackboard.bmp", E_FAST

speak_mode
  r_show ari_n
Arisa: "So, let's talk about numbers and symbols."\
  r_show suzur_T_T
Suzuka: "What happened to the topic about atoms...?"\
  r_show ari_n
Arisa: "The entire expression enclosed in parentheses is called a #FFFF33 list #FFFFFF. @/
And an expression not enclosed in parentheses (symbols or numbers) is called an #FFFF33 atom #FFFFFF. @/
  show_dgm ":l;img/dgm0301.bmp"
In a slightly old-fashioned way of speaking in Lisp, they used to say character atom or number atom, but/
recently, it seems this way of speaking isn't used much."\
  csp SP_DGM0
  r_show suzur_ase
Suzuka: "You brought up the topic of atoms just to say that."\
  r_show ":l;img/arin.bmp"
Arisa: "Ariin."\
  r_show suzur_nc
Suzuka: "Numbers don't change when evaluated, but symbols change into something else when evaluated./
It feels a bit unfair."\
  r_show ari_n
Arisa: "Hehehe... Lisp is not careless.
#33FF33 'suzuka #FFFFFF
When you evaluate this, the result is #33FF33 suzuka #FFFFFF."\
  r_show suzur_n
Suzuka: "Why do you use my name... I mean, the character string is the result./
Is this perhaps a symbol?"\
  r_show ari_exc
Arisa: "Correct. #33FF33 'suzuka #FFFFFF is precisely an abbreviated notation of/
#33FF33 (quote suzuka) #FFFFFF, and writing it this way means the same thing."\
  r_show suzur_n
Suzuka: "So, when you evaluate #33FF33 (quote symbol) #FFFFFF,/
the result is #33FF33 symbol #FFFFFF itself, right?"\
  r_show ari_n
Arisa: "You might think that the symbol won't be evaluated before quote acts on it,/
but it's not evaluated because 'quote' is special."\
  r_show suzur_qes
Suzuka: "You said 'define' is special too, but when you evaluate/
#33FF33 (define name expr) #FFFFFF,/
expr is evaluated but name is not and is treated as the same symbol, right? @/
So, does it mean that if the operator is special, there are operands that aren't evaluated?"\
  r_show ari_n
Arisa: "Exactly. Even if you don't understand it well, just remember that when you evaluate #33FF33 'name #FFFFFF,/
the result is #33FF33 name #FFFFFF. @/
By the way, the value of the expression #33FF33 '3 #FFFFFF is #33FF33 3 #FFFFFF. /
If you have room in your memory, it's good to remember this too."\
  r_show suzur_qes
Suzuka: "Hey, speaking of symbols, they came up as variable names before but is it different this time?"\
  r_show ari_exc
Arisa: "This part might be a bit difficult, so listen closely. @/
Things like #33FF33 19 #FFFFFF or #33FF33 nanoha #FFFFFF are both called #FFFF33 values #FFFFFF (objects). @/
Although they’re just called values, there are several types, such as those made from sequences of numbers or letters. @/
The category of values like 'numbers' and 'symbols' is called #FFFF33 types #FFFFFF."\
  r_show suzur_excc
Suzuka: "#33FF33 19 #FFFFFF is a value with number type. #33FF33 nanoha #FFFFFF is a value with symbol type, right? @/
  show_dgm ":l;img/dgm0302.bmp"
"\
  csp SP_DGM0
  r_show ari_n
Arisa: "We sometimes call a value with number type just a 'number' or a value with symbol type just a 'symbol,'/
but these are just abbreviations leaving out the word value."\
  r_show suzur_nc
Suzuka: "Come to think of it, variables were #FFFF33 bound symbols #FFFFFF, weren't they? Conversely,/
there are also symbols that are not bound, right?"\
  r_show ari_n
Arisa: "When symbols are evaluated, the corresponding value is searched in the environment, and that's the result. @/
But if not evaluated, it remains just as a symbol representing a sequence of letters. @/
  show_dgm ":l;img/dgm0303.bmp"
"\
  csp SP_DGM0
  r_show suzur_dotc
Suzuka: "Well, #33FF33 'symbol #FFFFFF doesn't get evaluated because of the effect of quote, so... @/
  r_show suzur_exc
I see, that's why you can create a symbol with a single quote."\
  r_show ari_n
Arisa: "Furthermore, because symbols are also values, you can add bindings to the environment as values corresponding to variables./
Evaluating #33FF33 (define nanoha 'fate) #FFFFFF, and then/
evaluating #33FF33 nanoha #FFFFFF results in #33FF33 fate #FFFFFF."\
  r_show suzur_excc
Suzuka: "Note that Nanoha-chan is bound to Fate-chan./
  r_show suzur_ase
... I mean, #33FF33 (define variable-name expression) #FFFFFF/
#33FF33 expression #FFFFFF is evaluated, so if you want it to be a symbol, you need to add a single quote, but/
#33FF33 variable-name #FFFFFF is not evaluated due to the effect of define, so adding a single quote is a no-go."\
  r_show ari_n
Arisa: "Since I think your head might be getting a bit tangled, let's do a simple problem."\

gosub *ex_init
*ex03
  mov $problem_label, "*ex03_problem"
  mov $tab_label, "*ex03_tab"
  mov $ret_label, "*ex03"
  mov $suc_label, "*ex03_check"
  goto *ex_rep
*ex03_problem
!s0Alisa: "Evaluate the expression that results in the symbol '#33FF33hayate#FFFFFF'"!sd
  return
*ex03_check
  mov $sarg0, "hayate"
  gosub *create_symbol
  mov %tmp, %ret
  gosub *pop      ;ret<S(input)
  mov $sarg0, "*ex03_2"
  if %tmp == %ret gosub *pop : goto *ex_check_pass
  mov $sarg0, "*ex03_normal_miss"
  goto *ex_check_fail
*ex03_normal_miss
  gosub *pop
  textclear
  r_show ari_die
Arisa: "No. Try again!"
  r_show ari_n
  inc %adv_tmp
  goto *ex03

*ex03_2
  mov $problem_label, "*ex03_2_problem"
  mov $tab_label, "*ex03_2_tab"
  mov $ret_label, "*ex03_2"
  mov $suc_label, "*ex03_2_check"
  goto *ex_rep
*ex03_2_problem
!s0Alisa: "Define the variable fate so that its value is the symbol 'nanoha'"!sd
  return
*ex03_2_check
  gosub *pop : gosub *pop
  mov $sarg0, "fate"
  gosub *create_symbol
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *find_var
  mov %arg0, %ret
  gosub *cdr
  mov %arg0, %ret
  gosub *push     ;S(value of fate)
  mov $sarg0, "nanoha"
  gosub *create_symbol
  mov %arg0, %ret
  gosub *pop      ;value of fate<S()
  mov $sarg0, "*ex03_3"
  if %arg0 == %ret goto *ex_check_pass
  mov $sarg0, "*ex03_2_normal_miss"
  goto *ex_check_fail
*ex03_2_normal_miss
  textclear
  r_show ari_die
Arisa: "No. Try again!"
  r_show ari_n
  inc %adv_tmp
  goto *ex03_2

*ex03_3
  mov $problem_label, "*ex03_3_problem"
  mov $tab_label, "*ex03_3_tab"
  mov $ret_label, "*ex03_3"
  mov $suc_label, "*ex03_3_check"
  goto *ex_rep
*ex03_3_problem
!s0Alisa: "Evaluate the variable fate"!sd
  return
*ex03_3_check
  ;;;定義の書き換えcheck;;;
  mov $sarg0, "fate"
  gosub *create_symbol
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *find_var
  mov %arg0, %ret
  gosub *cdr
  mov %arg0, %ret
  gosub *push     ;S(value of fate, ret, input)
  mov $sarg0, "nanoha"
  gosub *create_symbol
  mov %arg0, %ret
  gosub *pop      ;value of fate<S(ret, input)
  mov $sarg0, "*ex03_3_miss2"
  if %arg0 != %ret sub %sp, 2 : goto *ex_check_fail
  ;;;end;;;
  mov $sarg0, "nanoha"
  gosub *create_symbol
  mov %arg0, %ret
  gosub *pop      ;ret<S(input)
  mov $sarg0, "*ex03_3_miss"
  if %arg0 != %ret gosub *pop : goto *ex_check_fail
  mov $sarg0, "fate"
  gosub *create_symbol
  mov %arg0, %ret
  gosub *pop      ;input<S()
  mov $sarg0, "*ex03_end"
  if %arg0 == %ret goto *ex_check_pass_end
  mov $sarg0, "*ex03_3_miss"
  goto *ex_check_fail
*ex03_3_miss
  textclear
  r_show ari_die
Arisa: "No. Try again!"
  r_show ari_n
  inc %adv_tmp
  goto *ex03_3
*ex03_3_miss2
  textclear
  r_show ari_muka
Arisa: "...Let's start over from the beginning!!"
  r_show ari_n
  inc %adv_tmp
  gosub *pop  ;new env
  gosub *ex_init_env : goto *ex03

*ex03_tab
csel "Continue", *ex03, "Hint", *ex03_hint,  "Return to Title", *ex03_bye
*ex03_2_tab
csel "Continue", *ex03_2, "Hint", *ex03_2_hint,  "Return to Title", *ex03_bye
*ex03_3_tab
csel "Continue", *ex03_3, "Hint", *ex03_3_hint,  "Return to Title", *ex03_bye

*ex03_bye
  mov %adv_rmode, 1        ;Right click enabled
  textclear
  csp SP_R
  stop
  gosub *pop
  goto *title

*ex03_hint
  textclear
Arisa: "To leave a symbol as is and not evaluate it, you can use quotation marks, like this: #33FF33'ｘ#FFFFFF, or / #33FF33（quote　ｘ）#FFFFFF"
  goto *ex03

*ex03_2_hint
  textclear
Arisa: "You can define variables as usual with #33FF33 (define variable name expression) #FFFFFF. @/
#33FF33 variable name #FFFFFF is not evaluated, but #33FF33 expression #FFFFFF is evaluated, so you can use quotation marks. "\
  goto *ex03_2
Arisa: "You should define variables the same way as always, with #33FF33(define variable_name expression)#FFFFFF. @/
#33FF33Variable names#FFFFFF are not evaluated, but #33FF33expressions#FFFFFF are, so you should use quotation marks '."\
  goto *ex03_2

*ex03_3_hint
  textclear
Arisa: "Just write the variable name without thinking about anything."
  goto *ex03_3

*ex03_end
  mov %adv_rmode, 1        ;右クリック有効
  gosub *pop  ;new env<S()
  saveon
  mov %save_flag, 1  ;セーブ可能
  textclear
  add %adv_miss, %adv_tmp
  bgm ms_setsume
  if %adv_tmp == 0 goto *s_03_2
  if %adv_tmp >=4   goto *s_03_3
*s_03_1
Arisa: "That was okay."
  goto *s_03_4
*s_03_2
  r_show ari_hrt
Arisa: "There seems to be no problem at all."
  goto *s_03_4
*s_03_3
  r_show ari_ase
Arisa: "There are a few mistakes."
  goto *s_03_4
*s_03_4

r_show ari_n
Arisa: "Using quote and quotation marks ' to not evaluate expressions or subexpressions is called #FFFF33 quoting #FFFFFF. It might sound a bit strange, but remember it."\
  r_show suzur_qes
Suzuka: "I know it's late to ask, but what exactly are symbols like +, -, and define? They look like symbols, but..."\
  r_show ari_n
Arisa: "To understand that, we first need to know the rules of evaluation.
#33FF33 (operator operand1 operand2… operand n) #FFFFFF
It's the expression enclosed in parentheses that we've seen many times. Operands are long, so let's call them #FFFF33 arguments #FFFFFF.
For the first, second, and so on, we call them first argument, second argument, and so on."\
  r_show suzur_nc
Suzuka: "When the operators are + or -, the arguments are evaluated, but in the case of quote, they aren't evaluated specially, right?"\
  r_show ari_n
Arisa: "Things that evaluate arguments like + and - are called #FFFF33 functions #FFFFFF, and things with special treatments for arguments like define and quote are called #FFFF33 special forms #FFFFFF."\
  r_show suzur_T_T
Suzuka: "The name 'special form' sounds like it's nothing special even though we've kept saying how special it is..."\
  r_show ari_do
Arisa: "Shut up, shut up, shut up."\
  r_show suzur_dere
Suzuka: "There, there, calm down."\
  r_show ari_n
Arisa: "Yes, yes, until now we've used expressions like 'operators act on operands', but for functions, we'll call it 'calling a function with arguments'. 
Also, an expression like #33FF33(function argument1… argument n) #FFFFFF is called a '#FFFF33 function call #FFFFFF'. 
Furthermore, the result obtained from evaluating a function call is called the #FFFF33 value returned by the function #FFFFFF."\
  r_show suzur_qes
Suzuka: "There are a lot of new terms, but what about the part where + and so on look like symbols?"\
  r_show ari_n
Arisa: "+ and - are symbols themselves. However, they are bound to values of a #FFFF33 type that is a function #FFFFFF.
When evaluating the list, not only the arguments but also the operators are evaluated, so those values appear, but it's complicated, so let's talk about it another time."\
  r_show suzur_n
Suzuka: "Hmm, it sounds difficult. 
For now, maybe we should just remember the names #FFFF33 special form #FFFFFF, #FFFF33 function #FFFFFF, and #FFFF33 argument #FFFFFF and understand the details as we go."\

vsp SP_R, 0
  bg black, E_NORMAL
  r_load ari_n
  l_load suzu_n
  bgm ms_after
  bg "img/blackboard.bmp", E_NORMAL
  talk_mode
Arisa: "You're getting quite used to Lisp smoothly, aren't you?"\
  l_show suzu_qes
Suzuka: "Arisa-chan, I've heard there are many types of programming languages, so why Lisp?"\
Arisa: "Lisp is strong in artificial intelligence development. That's why it's used in the development of AI-equipped devices."\
  l_show suzu_exc
Suzuka: "I see, it's a standard language used for device development."\
  r_show ari_qes
Arisa: "Yes. And for some reason, all of the computers at the Temporal Management Bureau are Lisp machines."\
  l_show suzu_nc
Suzuka: "The Temporal Management Bureau uses Lisp entirely. That's fine, but we need to get a device soon."\
  r_show ari_n
Arisa: "We'll borrow one from the Temporal Management Bureau."\
  l_show suzu_dot
Suzuka: "Isn't that a bit too risky? I wonder if it will be that easy."\
Arisa: "It's okay. In fact, I've been planning it for days. We’ll carry it out soon."\
  l_show suzu_dotc
Suzuka: "What if we're spotted by a bureau member?"\
  r_show ari_hrt
Arisa: "Let's take Sakashima with us. In case something happens, it's the adults who take responsibility. Children don't have to."\
  l_show suzu_ase
Suzuka: "Arisa-chan... that's terrible..."\

;;;;;第3話終了;;;;;
  speak_mode
  textclear
  vsp SP_R, 0
  vsp SP_L, 0
  bg black, E_SLOW
;;共通記録の書き換え
  csvopen "arisa.szk", "rc"
  csvread %adv_clear
  csvclose
  if %adv_clear >= 3 goto *story03_after 
  mov %adv_clear, 3
  csvopen "arisa.szk", "wc"
  csvwrite %adv_clear
  csvclose
#FFFF33Supplementary explanation#FFFFFF has been added.
#FFFF33Glossary#FFFFFF has had a term added.\
*story03_after
  r_show suzur_nc
Suzuka: "What should I do?"
csel "Read the supplementary explanation", *story03_condicil, "Read the glossary", *story03_glossary, "Return to title", *title_back, "Proceed to episode 4", *story04

*story03_condicil
  gosub *condicil
  goto *story03_after
*story03_glossary
  gosub *glossary
  goto *story03_after

;;;;;第4話;;;;;
*story04
  mov %adv_noroi_off, 0
  csp SP_R : csp SP_L : print E_FAST
  stop
  talk_mode
  bgm ms_narumi
  bg "img/blackboard.bmp", E_FAST
  r_in ari_n
  l_in suzu_n
Arisa: "Now, we're going to infiltrate the Time-Space Administration Bureau today. Are you ready?"\
  l_show suzu_dotc
Suzuka: "I still think it's wrong to steal."\
Arisa: "It's okay. According to what I heard from Nanoha, it seems that a large number of old devices are about to be discarded."\
  l_show suzu_n
Suzuka: "Oh, I see."\
  r_show ari_hrt
Arisa: "Although their performance is inferior to the new devices, they can still be used. It's wasteful to just throw them away, right?"\
  l_show suzu_ase
Suzuka: "You mean we're not stealing, but taking things that are about to be thrown away, right?"\
  r_show ari_n
Arisa: "Actually, it's better because it reduces waste. Now, let's study hard to prepare for the infiltration."\

csp SP_R : csp SP_L : print 1
  bg "img/title#04.bmp", E_VFAST
  wait 1000
  delay 2000
  bgm ms_setsume
  bg "img/blackboard.bmp", E_FAST

speak_mode
  r_show suzur_qes
Suzuka: "Lisp has a lot of parentheses in expressions, doesn't it? What exactly are these parentheses for?"\
  r_show ari_n
Arisa: "Fufufu... This is what's interesting about Lisp. It's to encapsulate the intriguing characteristic that expressions, which are programs, and values, which are data, are equivalent."\
  r_show suzur_T_T
Suzuka: "Arisa-chan, that's too complicated..."\
  r_show ari_n
Arisa: "Hehe. Anyway, Lisp is interesting!"\
  r_show suzur_qes
Suzuka: "Values are things like #33FF334#FFFFFF and #33FF33y#FFFFFF, right?/
Expressions like #33FF33（ishida 30）#FFFFFF can also include numerical values and symbols inside parentheses, but is that also a value?"\
  r_show ari_n
Arisa: "Expressions enclosed in parentheses are, as I mentioned before, a structure called a #FFFF33list#FFFFFF,/
formed using multiple values of a type called #FFFF33cons#FFFFFF."\
  r_show suzur_nc
Suzuka: "Hmm, I don't quite get it. Anyway, could you explain what a cons is?"\
  r_show ari_n
Arisa: "A cons is a type with two storage locations, the #FFFF33CAR part#FFFFFF and the #FFFF33CDR part#FFFFFF.@
CAR and CDR are pronounced as 'car' and 'cudder', respectively.@
A cons can store two values using these."\
  r_show suzur_n
Suzuka: "I still don't get it very well... Maybe it's easier to understand if I actually try it."\
  r_show ari_n
Arisa: "To create a cons, you use a function called cons.@
#33FF33（cons 'a 'b）#FFFFFF
Evaluating this returns a value #33FF33（a . b）#FFFFFF. /
This means a cons that holds the symbol a in the CAR part and the symbol b in the CDR part.@
  show_dgm ":l;img/dgm0401.bmp"
As you can see from this, the function cons creates a cons that holds the first argument in the CAR part and the second argument in the CDR part."\
  r_show suzur_exc
Suzuka: "I see, a cons remembers two values with just one."\
  csp SP_DGM0
  r_show ari_n
Arisa: "By using the function car on a cons, you can get the value in the CAR part, and by using the function cdr, you can get the value in the CDR part, so,
#33FF33（car (cons 'a 'b)）#FFFFFF⇒#33FF33a#FFFFFF
#33FF33（cdr (cons 'a 'b)）#FFFFFF⇒#33FF33b#FFFFFF
That's the result."\
  r_show suzur_n
Suzuka: "car, cdr, and cons are functions, so their arguments are evaluated first."\
  r_show ari_n
Arisa: "What you must be careful about here is that cons doesn't memorize two values,/
but rather the #FFFF33address#FFFFFF of the two values."\
  r_show suzur_qes
Suzuka: "What do you mean by the address of the values?"\
  r_show ari_n
Arisa: "Values are considered to be stored in something like boxes when created.@
Each box has its unique number, and this number is called an #FFFF33address#FFFFFF.@
  show_dgm ":l;img/dgm0402.bmp"
Values exist only inside boxes; they don't move to other boxes freely or have two values in one box.
Therefore, as long as you know the address of a value, it's the same as knowing the value."\
  r_show suzur_qes
Suzuka: "Then why does a cons memorize the address rather than the value itself?"\
  r_show ari_n
Arisa: "The CAR and CDR of a cons can remember any value.@
That means it can also include a value whose type is cons.@
That's something that's not possible if you try to remember values directly."\
  r_show suzur_exc
Suzuka: "Ah, I see."\
  csp SP_DGM0
  r_show ari_n
Arisa: "For an expression using cons on a cons,
#33FF33（cons 'a (cons 'b 'c)）#FFFFFF
What do you think is the result of evaluating this?"\
  r_show suzur_nc
Suzuka: "Well, first, #33FF33（cons 'b 'c）#FFFFFF gets evaluated,
becoming a cons like #33FF33（b . c）#FFFFFF.@
Then a cons with symbol a in the CAR part and the cons just created in the CDR part is made, so the value of this expression is
#33FF33（a . (b . c)）#FFFFFF, right?"\
  r_show ari_n
Arisa: "The value of #33FF33（cons 'a (cons 'b 'c)）#FFFFFF is displayed as #33FF33（a b . c）#FFFFFF.@
You might be surprised by this notation, but as in this example,/
when a cons's CDR part is a cons, it's customary to omit the dot and parentheses.@
While the display omits one dot and one parenthesis, you were correct in meaning as Suzuka said."\
  r_show suzur_dotc
Suzuka: "Um, #33FF33（a b . c）#FFFFFF means there's first a cons,
its CAR is symbol a, CDR is another cons. /
Then that cons's CAR is symbol b and CDR is symbol c@/
  r_show suzur_ase
... It's kind of complicated."\
  r_show ari_n
Arisa: "If it's hard to understand, try drawing a diagram.@
  show_dgm ":l;img/dgm0403.bmp"
I'll explain how to draw the diagrams in the supplementary explanation."\
  r_show suzur_nc
Suzuka: "Connecting cons like this, it seems like it'll indeed turn into expressions similar to the ones we've input so far,/
but in the end, we'll be left with something like #33FF33（A B … Y . Z）#FFFFFF, right, with a dot left over."\
  r_show ari_n
Arisa: "This is also a notational rule; when a cons's CDR is a special value called the empty list #33FF33（）#FFFFFF,/
it's customary to omit the CDR part's display."\
  r_show suzur_nc
Suzuka: "Sure, the empty list #33FF33（）#FFFFFF can look like a list with no contents.@
Should I put this in the CDR part of a cons?"\
  r_show ari_n
Arisa: "Specifically,
#33FF33（cons 'a (cons 'b '())）#FFFFFF
the value becomes #33FF33（a b）#FFFFFF. Here's how it looks in a diagram.@
  show_dgm ":l;img/dgm0404.bmp"
The empty list is used as #33FF33'（）#FFFFFF with a quote, so be careful."\
  r_show suzur_exc
Suzuka: "So, what we've written as expressions so far were collections of Lisp's values made by chaining together cons."\
  r_show ari_n
Arisa: "Initially, I called things with elements inside parentheses a list, but,/
to be precise, it's called a list when it's an empty list or a cons that has a list stored in its CDR.@
  show_dgm ":l;img/dgm0405.bmp"
The definition might be recursive and difficult to understand, but you'll understand the meaning eventually."\
  csp SP_DGM0
  r_show suzur_n
Suzuka: "But, if you're trying to make something complex, you'll have to write a lot of cons, which is a hassle."\
  r_show ari_exc
Arisa: "Interestingly, you can also write expressions like #33FF33'（a b c）#FFFFFF."\
  r_show suzur_dotc
Suzuka: "The single quote ' turns into quote, so it transforms into #33FF33（quote （a b c））#FFFFFF,
and because the argument of quote is the direct result... @/
  r_show suzur_exc
The value of the expression is #33FF33（a b c）#FFFFFF... @ The expression itself turned into a list!"\
  r_show ari_n
Arisa: "How is it? Since the way to write expressions and the method to represent values are the same, expressions can also be handled as values.@
By the way, you can also write expressions like #33FF33'（a . b）#FFFFFF.@
The things we've been calling expressions are, in fact, properly referred to as #FFFF33S-expressions#FFFFFF.@
For more details about S-expressions, please read the glossary."\
  r_show suzur_n
Suzuka: "My head feels like it's going to explode, and I'd like to try it out soon."\
  r_show ari_n
Arisa: "Here's a note to remember: When asked to create the list '(1 2 3),
#33FF33/
（cons 1
　（cons 2
　　（cons 3 '())））#FFFFFF
is okay to write, but, @/
#33FF33'(1 2 3)#FFFFFF
is a more convenient way to do it.@
Also, @/
#33FF33（cons x (cons y '())）#FFFFFF
evaluates x and y, but, @/
#33FF33'(x y)#FFFFFF
leaves x and y unevaluated as symbols due to the quote, so be careful."\

gosub *ex_init
*ex04
  mov $problem_label, "*ex04_problem"
  mov $tab_label, "*ex04_tab"
  mov $ret_label, "*ex04"
  mov $suc_label, "*ex04_check"
  goto *ex_rep
*ex04_problem
!s0Alisa: "First, define the value of x as the list (a b c)"!sd
  return
*ex04_check
  gosub *pop : gosub *pop
  ;;(defien x '(a b c))の答え合わせ
  mov $sarg0, "x"
  gosub *create_symbol
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *find_var
  mov %arg0, %ret
  gosub *cdr
  mov %arg0, %ret  ;A
  gosub *get_tag
  mov %tmp1, %ret
  mov $sarg0, "*ex04_miss1"
  if %tmp1 != TAG_CONS goto *ex_check_fail
  gosub *push  ;S(A, new env)
  mov $sarg0, "a"
  gosub *create_symbol
  mov %tmp, %ret  ;a
  gosub *pop   ;A<S(new env)
  mov %arg0, %ret
  gosub *push  ;S(A, new env)
  mov %arg1, %arg0
  mov %arg0, %tmp
  gosub *push  ;S(a, A, new env)
  mov %arg0, %arg1
  gosub *car
  mov %tmp1, %ret  ;CAR(A)
  gosub *pop  ;a<S(A, new env)
  mov $sarg0, "*ex04_miss1"
  if %tmp1 != %ret gosub *pop : goto *ex_check_fail
  gosub *pop  ;A<S(new env)
  mov %arg0, %ret
  gosub *cdr
  mov %arg0, %ret  ;B
  gosub *get_tag
  mov %tmp1, %ret
  mov $sarg0, "*ex04_miss1"
  if %tmp1 != TAG_CONS goto *ex_check_fail
  gosub *push  ;S(B, new env)
  mov $sarg0, "b"
  gosub *create_symbol
  mov %tmp, %ret  ;b
  gosub *pop   ;B<S(new env)
  mov %arg0, %ret
  gosub *push  ;S(B, new env)
  mov %arg1, %arg0
  mov %arg0, %tmp
  gosub *push  ;S(b, B, new env)
  mov %arg0, %arg1
  gosub *car
  mov %tmp1, %ret  ;CAR(B)
  gosub *pop  ;b<S(B, new env)
  mov $sarg0, "*ex04_miss1"
  if %tmp1 != %ret gosub *pop : goto *ex_check_fail
  gosub *pop  ;B<S(new env)
  mov %arg0, %ret
  gosub *cdr
  mov %arg0, %ret  ;C
  gosub *get_tag
  mov %tmp1, %ret
  mov $sarg0, "*ex04_miss1"
  if %tmp1 != TAG_CONS goto *ex_check_fail
  gosub *push  ;S(C, new env)
  mov $sarg0, "c"
  gosub *create_symbol
  mov %tmp, %ret  ;c
  gosub *pop   ;C<S(new env)
  mov %arg0, %ret
  gosub *push  ;S(C, new env)
  mov %arg1, %arg0
  mov %arg0, %tmp
  gosub *push  ;S(c, C, new env)
  mov %arg0, %arg1
  gosub *car
  mov %tmp1, %ret  ;CAR(C)
  gosub *pop  ;c<S(C, new env)
  mov $sarg0, "*ex04_miss1"
  if %tmp1 != %ret gosub *pop : goto *ex_check_fail
  gosub *pop  ;C<S(new env)
  mov %arg0, %ret
  gosub *cdr
  mov $sarg0, "*ex04_miss1"
  if %ret != %nil goto *ex_check_fail
  ;;(define x '(a b c))の答え合わせ終了
  mov $sarg0, "x"
  gosub *create_symbol
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *find_var
  mov %arg0, %ret
  gosub *cdr
  mov %arg0, %ret  ;A
  gosub *push   ;S(A, new env)
  mov $sarg0, "*ex04_2"
  goto *ex_check_pass  ;S(A, new env)

*ex04_miss1
  r_show ari_die
  Arisa: "...What are you doing differently? Do it over!"\
  r_show ari_n
  inc %adv_tmp
  gosub *pop  ;new env<S()
  gosub *ex_init_env : goto *ex04

*ex04_2  ;S(A, new env)
  mov $problem_label, "*ex04_2_problem"
  mov $tab_label, "*ex04_2_tab"
  mov $ret_label, "*ex04_2"
  mov $suc_label, "*ex04_2_check"
  goto *ex_rep
*ex04_2_problem
!s0Alisa: "Next, extract the CAR of x."!sd
  return
*ex04_2_check
  gosub *pop
  mov %arg0, %ret
  gosub *pop
  gosub *push ;S(new object, A, new env)
  ;;(car x)の答え合わせ
  gosub *pop  ;new object<S(A, new env)
  mov %arg0, %ret
  gosub *pop  ;A<S(new env)
  mov %tmp, %ret
  gosub *push ;(new object, new env)
  mov %arg0, %tmp
  gosub *push ;S(A, new object, new env)
  gosub *car
  mov %tmp, %ret  ;CAR(A)
  gosub *pop  ;A<S(new object, new env)
  mov %tmp1, %ret
  gosub *pop  ;new object<S(new env)
  mov %tmp2, %ret
  mov $sarg0, "*ex04_3"
  if %tmp2 == %tmp mov %arg0, %tmp1 : gosub *push : goto *ex_check_pass  ;S(A, new env)
  mov %arg0, %tmp1
  gosub *push  ;S(A, new env)
  ;For the wonderful person who would redefine x here
  ;(Giving up on set-car! and such orz)
  mov $sarg0, "x"
  gosub *create_symbol
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *find_var
  mov %arg0, %ret
  gosub *cdr
  mov %tmp, %ret
  gosub *pop  ;A<S(new env)
  mov %arg0, %ret
  mov $sarg0, "*ex04_ext"
  if %tmp != %arg0 goto *ex_check_fail  ;S(new env)
  gosub *push  ;S(A, new env)
  mov $sarg0, "*ex04_2_normal_miss"
  goto *ex_check_fail
*ex04_2_normal_miss
  r_show ari_die
Alisa: "That's not it. Try again!"
  r_show ari_n
  inc %adv_tmp
  goto *ex04_2
*ex04_ext
  r_show ari_muka
Alisa: "......You're doing something quite interesting.@
  r_show ari_do
Start over from the beginning!!!"
  r_show ari_n
  gosub *pop  ;new env<S()
  inc %adv_tmp
  gosub *ex_init_env : goto *ex04

*ex04_3  ;S(A, new env)
  mov $problem_label, "*ex04_3_problem"
  mov $tab_label, "*ex04_3_tab"
  mov $ret_label, "*ex04_3"
  mov $suc_label, "*ex04_3_check"
  goto *ex_rep
*ex04_3_problem
!s0Arisa: "Next, take out the CDR of x."!sd
  return
*ex04_3_check
  gosub *pop
  mov %arg0, %ret
  gosub *pop
  gosub *push ;S(new object, A, new env)
  ;;(cdr x)の答え合わせ
  gosub *pop  ;new object<S(A, new env)
  mov %arg0, %ret
  gosub *pop  ;A<S(new env)
  mov %tmp, %ret
  gosub *push ;(new object, new env)
  mov %arg0, %tmp
  gosub *push ;S(A, new object, new env)
  gosub *cdr
  mov %tmp, %ret  ;CDR(A)
  gosub *pop  ;A<S(new object, new env)
  mov %tmp1, %ret
  gosub *pop  ;new object<S(new env)
  mov %tmp2, %ret
  mov $sarg0, "*ex04_end"
  if %tmp2 == %tmp goto *ex_check_pass_end  ;S(new env)
  mov %arg0, %tmp1
  gosub *push  ;S(A, new env)
  ;ここでxの再定義をしてくれるという素晴らしい人のために
  ;(set-car!等は諦める方針で orz)
  mov $sarg0, "x"
  gosub *create_symbol
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *find_var
  mov %arg0, %ret
  gosub *cdr
  mov %tmp, %ret
  gosub *pop  ;A<S(new env)
  mov %arg0, %ret
  mov $sarg0, "*ex04_ext"
  if %tmp != %arg0 goto *ex_check_fail  ;S(new env)
  gosub *push  ;S(A, new env)
  mov $sarg0, "*ex04_3_normal_miss"
  goto *ex_check_fail
*ex04_3_normal_miss
  r_show ari_die
Arisa: "No, try again!"
  r_show ari_n
  inc %adv_tmp
  goto *ex04_3

*ex04_tab
csel "Continue", *ex04, "Hint", *ex04_hint,  "Return to Title", *ex04_bye
*ex04_2_tab
csel "Continue", *ex04_2, "Hint", *ex04_2_hint,  "Return to Title", *ex04_2_bye
*ex04_3_tab
csel "Continue", *ex04_3, "Hint", *ex04_3_hint,  "Return to Title", *ex04_3_bye

*ex04_bye
  mov %adv_rmode, 1        ;Right-click enabled
  textclear
  csp SP_R
  stop
  goto *title

*ex04_2_bye
  sub %sp, 2
  goto *ex04_bye

*ex04_3_bye
  sub %sp, 2
  goto *ex04_bye

*ex04_hint
  textclear
Arisa: "The variable definition itself is fine, right? The problem is creating the value #33FF33(a b c)#FFFFFF. @/
If you write #33FF33(a b c)#FFFFFF directly, it will be evaluated as an expression and become a function call, so it won't work. @/
If you quote the expression, like #33FF33'expression#FFFFFF, you'll get a list in the form of the expression, so it works fine."\
  goto *ex04

*ex04_2_hint
  textclear
Arisa: "To get the CAR part of a list, use the function car."
  goto *ex04_2

*ex04_3_hint
  textclear
Arisa: "To get the CDR part of the list, use the function cdr, just like car."
  goto *ex04_3

*ex04_end
  mov %adv_rmode, 1        ;右クリック有効
  gosub *pop  ;new env<S()
  saveon
  mov %save_flag, 1  ;セーブ可能
  textclear
  add %adv_miss, %adv_tmp
  bgm ms_setsume
  if %adv_tmp == 0 goto *s_04_2
  if %adv_tmp >=4   goto *s_04_3
*s_04_1
Arisa: "It was okay."
  goto *s_04_4
*s_04_2
  r_show ari_hrt
Arisa: "No problem at all."
  goto *s_04_4
*s_04_3
  r_show ari_ase
Arisa: "You make a lot of mistakes."
  goto *s_04_4
*s_04_4

r_show suzur_n
Suzuka: "#33FF33 (car' (a b c)) #FFFFFF is #33FF33a #FFFFFF and is a symbol, but /
#33FF33 (cdr' (a b c)) #FFFFFF is #33FF33 (b c) #FFFFFF and is a list"\
r_show ari_n
Arisa: "This makes sense if you think about the structure of the list. @/
show_dgm ":l;img/dgm0406a.bmp"
This is the original list, but the object to be operated on is of course the leftmost cons. @/
show_dgm ":l;img/dgm0406b.bmp"
When you think about it like that, you can see why CAR is a symbol and CDR is a list"\
r_show suzur_excc
Suzuka: "Oh, it does become a list. If you don't understand how to operate a list, it's good to draw a diagram."
  csp SP_DGM0 : print E_FAST

mov %adv_noroi_off, 1
  vsp SP_R, 0
  bg black, E_NORMAL
  r_load ari_n
  l_load suzu_n
  bgm ms_jiku
  bg "img/jiku_back.bmp", E_NORMAL
  talk_mode
Arisa: "You managed to sneak into the Time-Space Administration Bureau's facility" \
Suzuka: "That was really hard" \
r_show ari_tun
Arisa: "For convenience, I will omit the episodes leading up to the infiltration" \
l_show suzu_qes
Suzuka: "Arisa, who are you talking to?" \
r_show ari_n
Arisa: "There are a lot of things happening here too. Samejima, are you following me?" \
l_show ":l;img/same.bmp"
Samejima: "Here" \
r_show ari_ase
Arisa: "I asked Nanoha to check it out, and she said that neither I nor Suzuka have any aptitude for magic, and I didn't think that Samejima would be the only one who has it" \
Samejima: "I'm sorry" \
r_show ari_n
Arisa: "Well, that's fine, I can rely on you." \
Samejima: "I understand."\
  vsp SP_R, 0 : vsp SP_L, 0
  bg black, E_NORMAL
施設の中を探索すること数分\
  lsp SP_TMP, ":l;img/dev.bmp", 100, 50
  print E_SLOW
三人はデバイスを見つけ出した\
  csp SP_TMP
  print E_FAST
  r_load ari_n
  l_load suzu_hrt
  bg "img/jiku_back.bmp", E_NORMAL
Suzuka: "I didn't expect that they would even kindly put the instruction manual with it."\
Arisa: "Thanks to that, it's ready to use right away, isn't it?"\
l_show suzu_nc
Suzuka: "Now Samejima can use magic."\
r_show ari_exc
Arisa: "That's right. I've included the formula that Suzuka typed in as a magic program."\
l_show suzu_n
Suzuka: "!?"\
r_show ari_hrt
Arisa: "#FFFF33If there's no mistake#FFFFFF, you should be able to use powerful magic, so it's okay."\
l_show suzu_dot
Suzuka: "In other words, if there's a mistake#FFFF33, the power of the magic will decrease#FFFFFF..."\
r_show ari_n
Arisa: "Well, I've finished my business, Suzuka and Samejima,

I'm going home."\
l_show suzu_nc
Suzuka: "Yeah."\
r_out
l_rout
delay 500
l_in ":l;img/jiku.bmp"
Officer: "Who's there?!"\
r_show ari_ase
Arisa: "Ah... I've been found..."\
r_show suzu_ase
Suzuka: "Arisa, what should we do?!"\
r_show ari_tun
Arisa: "Samejima!!! Beat him!"\
r_show ":l;img/same.bmp"
Samejima: "I know what to do."\
  stop
  csp SP_R : csp SP_L
  bg black, E_WIPE2
  bgm ms_battle
  gosub *battle04
  if %ret == 0 goto *battle04_after
  ;;敗北
  textclear
  stop
  goto *title
*battle04_after
  l_load ":l;img/jiku.bmp"
  bgm ms_jiku
  bg "img/jiku_back.bmp", E_NORMAL
Officer: "Ugh... Belka-style magic..." \
csp SP_L
print E_FAST
Button\
r_show ari_hrt
l_show suzu_ase
Suzuka: "Arisa-chan, this person has fainted..." \
Arisa: "Let's get away now." \
Suzuka: "We attacked an officer, so we'll definitely be pursued!" \
r_show ari_tun
Arisa: "Hmm... Maybe we should hide somewhere for a while..." \
l_show suzu_exc
Suzuka: "That's right, let's go to Kyoto." \

speak_mode
;;;;;第4話終了;;;;;
  speak_mode
  textclear
  vsp SP_R, 0
  vsp SP_L, 0
  bg black, E_SLOW
;;共通記録の書き換え
  csvopen "arisa.szk", "rc"
  csvread %adv_clear
  csvclose
  if %adv_clear >= 4 goto *story04_after 
  mov %adv_clear, 4
  csvopen "arisa.szk", "wc"
  csvwrite %adv_clear
  csvclose
#FFFF33Additional explanations#FFFFFF have been added.
#FFFF33A term#FFFFFF has been added to the glossary.\
*story04_after
  r_show suzur_nc
Suzuka : "What should I do?"
csel "Read additional explanation", *story04_condicil, "Read glossary", *story04_glossary, "Return to title", *title_back, "Proceed to Episode 5", *story05

*story04_condicil
  gosub *condicil
  goto *story04_after
*story04_glossary
  gosub *glossary
  goto *story04_after

;;;;;第5話;;;;;
*story05
  mov %adv_noroi_off, 1 ;;;Yuno will not appear due to the λ mountains
  csp SP_R : csp SP_L : print E_FAST
  stop
  talk_mode
  bgm ms_kyoto
  bg "img/yama_b.bmp", E_FAST

r_in ari_n
  l_in suzu_n
  l_show suzu_hrt
Suzuka: "So the stage moves to Kyoto"\
r_show ari_hrt
Alisa: "That's the famous #FFFF33λ mountain#FFFFFF in the background...@/
r_show ari_ase
More importantly, I've really come to Kyoto"\
l_show suzu_nc
Suzuka: "Anyway, I need to prepare for my pursuers"\
r_show ari_hrt
Alisa: "For now, I need to strengthen my magic so that I can easily defeat the ones I defeated before"\
l_show suzu_ase
Suzuka: "I feel like I'm not getting anywhere near a solution..."\

csp SP_R : csp SP_L : print 1
  bg "img/title#05.bmp", E_VFAST
  wait 1000
  delay 2000
  bgm ms_setsume
  bg "img/blackboard.bmp", E_FAST

speak_mode
  r_show suzur_n
Suzuka: "But thanks to Samejima-san, who somehow arranged a place to stay and a place to study for us.@/
  r_show suzur_dotc
...It feels like it's a bit too similar to the previous place though"\
  r_show ari_n
Arisa: "Leaving that aside, let me explain functions this time"\
  r_show suzur_nc
Suzuka: "When it comes to functions, they accept evaluated arguments like #33FF33car#FFFFFF or #33FF33+#FFFFFF,/
and return a value accordingly, right"\
  r_show ari_n
Arisa: "This time, let's try to create functions instead of just using them. @/
To start, let's make a 'function that adds 1 to the argument.' 
#33FF33(lambda (x) (+ x 1))#FFFFFF
Lambda is a special form to create functions.@/
Arguments are not evaluated"\
  r_show suzur_n
Suzuka: "It looks like by providing arguments and calling this created function,/
it takes the argument with the name #33FF33x#FFFFFF,/
and the result is the evaluation of #33FF33(+ x 1)#FFFFFF"\
  r_show ari_n
Arisa: "The symbol that receives the argument like x here is called a #FFFF33formal parameter#FFFFFF.@/
The values we've been calling arguments sent to functions are called #FFFF33actual parameters#FFFFFF when distinguishing them from formal parameters.@/
Actual parameters can be of any type, but formal parameters must be symbols"\
  r_show suzur_qes
Suzuka: "The value of the formal parameter is the actual parameter, right?@/
So, does it mean that the formal parameter is bound to the actual parameter?"\
  r_show ari_n
Arisa: "Let's leave that topic for later.@/
A function itself is a kind of value, and when the value of the type function is displayed,/
it appears as #33FF33#<procedure>#FFFFFF/
But there's no particularly useful information in this display"\
  r_show suzur_nc
Suzuka: "The fact that a function is a kind of value means it can be treated the same as numbers or symbols.@/
However, unlike numbers or symbols, displaying it doesn't have much meaning.@/
But somehow, I can't quite grasp the image..."\
  r_show ari_n
Arisa: "Then, let's try calling the function from earlier. 
#33FF33((lambda(x)(+ x 1))9)#FFFFFF
The result would be #33FF3310#FFFFFF.@/
  show_dgm ":l;img/dgm0501.bmp"
It might not click immediately, but try to recall the rule of evaluation"\
  r_show suzur_n
Suzuka: "The entire expression is a list, so it's in the form of a function call #33FF33(function argument)#FFFFFF, right?
The function is #33FF33(lambda(x)(+ x 1))#FFFFFF. The argument is #33FF339#FFFFFF"\
  r_show ari_n
Arisa: "When evaluating a list, not only the operands but also the operators are evaluated first before the operator acts on the operands.@/
  show_dgm ":l;img/dgm0502.bmp"
So in this case, #33FF33(lambda (x) (+ x 1))#FFFFFF and #33FF339#FFFFFF are evaluated first.@/
As I mentioned earlier, the result of the lambda expression is a function. 9 remains as it is.@/
Then, this function is called, replacing the formal parameter x in #33FF33(+ x 1)#FFFFFF with the actual parameter 9,/
resulting in the value of the expression #33FF33(+ 9 1)#FFFFFF being 10, which is the value of the entire expression"\
  r_show suzur_exc
Suzuka: "It's easy to understand if I think of replacing the formal parameter inside the function with the actual parameter"\
  csp SP_DGM0
  r_show ari_n
Arisa: "Next, let's write a function that takes two arguments. It's needless to say, but you can do the same for three or more.@/
#33FF33/
(lambda (x y)
 (cons x (cons y '())))#FFFFFF
It's written over multiple lines, but when you actually input it, you should write it on a single line./
Real Lisp allows writing it over multiple lines, but due to NScripter's specifications, only a single line can be written in NSclisper"\
  r_show suzur_nc
Suzuka: "When calling it, it's
#33FF33/
((lambda (x y)
 (cons x
 (cons y '())))
 'a 'b)#FFFFFF
right? You replace x and y in #33FF33(cons x (cons y '()))#FFFFFF/
with the evaluated values of #33FF33'a#FFFFFF and #33FF33'b#FFFFFF, in other words, a and b/
so the result is #33FF33(a b)#FFFFFF right?"\
  r_show ari_n
Arisa: "However, with this method, you have to write a long expression every time you call the function, so let's bind the function.
#33FF33/
(define caar
 (lambda(lst)
 (car(car lst))))#FFFFFF
Since the function is a type of value, as before, you can use define,@/
which binds #33FF33caar#FFFFFF to the function.@/
This process of binding a function is called 'defining a function.'@/
In this example, it's called 'defining the function caar.'@/
When you say #FFFF33the function caar#FFFFFF, it refers to the function associated with caar, so be careful"\
  r_show suzur_qes
Suzuka: "It's easier to understand with an assigned name than just saying 'function.'@
Once you bind a function, you don't have to recreate it, right?"\
  r_show ari_n
Arisa: "Once bound, instead of writing the lambda expression again, you can use the bound symbol,
#33FF33(caar '((a b)(c d)))#FFFFFF
and the result of this expression would be a"\
  r_show suzur_nc
Suzuka: "Since caar is a symbol, when evaluated, it changes to the corresponding value.@/
  show_dgm ":l;img/dgm0503.bmp"
Since it corresponds to a function, it works properly.@/
  r_show suzur_qes
Huh? Then, similarly, are + and car also symbols tied to functions?"\
  csp SP_DGM0
  r_show ari_exc
Arisa: "That's right. We have been calling + and car functions, but more precisely, they are symbols associated with #FFFF33functions#FFFFFF.@/
Up till now, the term 'the function car' was used to refer to the function associated with car"\
  r_show suzur_excc
Suzuka: "+ and car themselves don't have special meanings; they were just bound to functions"\
  r_show ari_n
Arisa: "Let me explain the rules for evaluating lists once again.
#33FF33(function argument1 argument2...argumentn)#FFFFFF
In this case, evaluate arguments 1 to n and the function. Then pass the evaluated arguments 1 to n to the value obtained from evaluating the function.@/
Here, the term 'function' is a 'expression that becomes a function when evaluated,' such as a symbol bound to a function or a lambda expression./So, don't get confused"\
  r_show suzur_nc
Suzuka: "I kind of get it and kind of don't... Anyway, to go back, to create a function
#33FF33(lambda (formal parameter) expression)#FFFFFF
would be the way, right? You can have as many arguments as you like, and the expression part can be written freely"\
  r_show ari_n
Arisa: "Once bound, it's convenient to use, but you can use it without binding if you want"\
  r_show suzur_n
Suzuka: "Well, I want to try it soon"\
  r_show ari_n
Arisa: "A little review of lists before the practice problem.@/
Lists can be created using quote like #33FF33'(a b c)#FFFFFF.@/
Let's call a, b, c the first element, second element, and third element, respectively.@/
Taking the CAR of this would result in #33FF33a#FFFFFF, and taking the CDR would result in #33FF33(b c)#FFFFFF.@/
Therefore, you could think that car retrieves the first element of a list,@/
and cdr returns the list with the first element removed"\

gosub *ex_init
*ex05
  mov $problem_label, "*ex05_problem"
  mov $tab_label, "*ex05_tab"
  mov $ret_label, "*ex05"
  mov $suc_label, "*ex05_check"
  goto *ex_rep
*ex05_problem
!s0Arisa: "Define the function f as a function that returns the second element of its argument./
However, you can assume that there is only one argument, and that it is a list."!sd
  return
*ex05_check
  gosub *pop : gosub *pop
  ;;;検証1
  mov $sarg0, "(f '(k l))"
  gosub *input_to_lobject
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *eval_form
  mov %arg0, %ret
  gosub *push     ;S(l?)
  mov $sarg0, "l"
  gosub *create_symbol
  mov %arg0, %ret
  gosub *pop      ;l?<S()
  mov $sarg0, "*ex05_miss"
  if %arg0 != %ret goto *ex_check_fail
  ;;;検証2
  mov $sarg0, "(f '(x miko))"
  gosub *input_to_lobject
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *eval_form
  mov %arg0, %ret
  gosub *push     ;S(miko?)
  mov $sarg0, "miko"
  gosub *create_symbol
  mov %arg0, %ret
  gosub *pop      ;miko?<S()
  mov $sarg0, "*ex05_2_prev"
  if %arg0 == %ret goto *ex_check_pass
  mov $sarg0, "*ex05_miss"
  goto *ex_check_fail
*ex05_miss
  textclear
  r_show ari_die
  Arisa: "No. Try again!"
  r_show ari_n
  inc %adv_tmp
  goto *ex05

*ex05_2_prev
  mov $sarg0, "f"
  gosub *create_symbol
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *find_var
  mov %arg0, %ret
  gosub *cdr
  mov %arg0, %ret
  gosub *push     ;S(f)
*ex05_2
  mov $problem_label, "*ex05_2_problem"
  mov $tab_label, "*ex05_2_tab"
  mov $ret_label, "*ex05_2"
  mov $suc_label, "*ex05_2_check"
  goto *ex_rep
*ex05_2_problem
!s0Alisa: "Call f with arguments #33FF33'(a b c) #FFFFFF"!sd
  return
*ex05_2_check
  gosub *pop
  mov %arg0, %ret
  gosub *pop
  gosub *push
  mov $sarg0, "b"
  gosub *create_symbol
  mov %arg0, %ret
  gosub *pop      ;ret<S(f)
  mov $sarg0, "*ex05_end"
  if %arg0 == %ret gosub *pop : goto *ex_check_pass_end
;;;fの再定義をcheck;;;
  mov $sarg0, "f"
  gosub *create_symbol
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *find_var
  mov %arg0, %ret
  gosub *cdr
  mov %arg0, %ret
  gosub *pop      ;f<S()
  mov $sarg0, "*ex05_2_miss"
  if %arg0 != %ret goto *ex_check_fail
  mov %arg0, %ret
  gosub *push     ;S(f)
  mov $sarg0, "*ex05_2_normal_miss"
  goto *ex_check_fail
;;;end;;;
*ex05_2_normal_miss
  textclear
  r_show ari_die
Alisa "That's wrong. Try again!"\
  r_show ari_n
  inc %adv_tmp
  goto *ex05_2

*ex05_2_miss
  textclear
  r_show ari_muka
Arisa: "……You're doing something quite interesting, aren't you?@/
  r_show ari_do
Start over from the beginning!!!"\
  r_show ari_n
  inc %adv_tmp
  goto *ex05

*ex05_tab
csel "Continue", *ex05, "Hint", *ex05_hint,  "Return to Title", *ex05_bye
*ex05_2_tab
csel "Continue", *ex05_2, "Hint", *ex05_2_hint,  "Return to Title", *ex05_2_bye

*ex05_bye
  mov %adv_rmode, 1        ; Right-click enabled
  textclear
  csp SP_R
  stop
  gosub *pop      ; new env<S()
  goto *title

*ex05_2_bye
  gosub *pop      ;f<S(new env)
  goto *ex05_bye

*ex05_hint
  textclear
Arisa: "Since we are defining the function f, the whole formula is #33FF33 (define f function) #FFFFFF. @/
Since it receives one argument, you should write #33FF33 (lambda (x) formula) #FFFFFF in the #33FF33 function #FFFFFF part. @/
Write the formula to extract the second element of "x" in #33FF33 formula #FFFFFF. @/
The big hint is what I said just before doing the problem. @/
Again, car is a function that extracts the first element of a list, and cdr is a function that returns a list with the first element of the list extracted. @/
The result of #33FF33 (cdr x) #FFFFFF is a list, and the first element of that list is the second element of x..." \
goto *ex05

*ex05_2_hint
textclear
Arisa: "Just write the formula #33FF33 (function argument) #FFFFFF"
  goto *ex05_2

*ex05_end
  mov %adv_rmode, 1        ;右クリック有効
  gosub *pop  ;new env<S()
  saveon
  mov %save_flag, 1  ;セーブ可能
  textclear
  add %adv_miss, %adv_tmp
  bgm ms_setsume
  if %adv_tmp == 0 goto *s_05_2
  if %adv_tmp >=4   goto *s_05_3
*s_05_1
Arisa: "Not bad"\
goto *s_05_4
*s_05_2
r_show ari_hrt
Arisa: "No problems at all"\
goto *s_05_4
*s_05_3
r_show ari_ase
Arisa: "You made quite a few mistakes"\
  goto *s_05_4
*s_05_4

r_show suzur_nc
Suzuka: "I thought that formal arguments could be replaced by actual arguments, but they're not really replaced. @For example,
#33FF33/
（ｄｅｆｉｎｅ　ｑ
　（ｌａｍｂｄａ　（ｘ）
　　’ｘ））#FFFFFF
本当に、仮引数を実引数で置き換えたら、#33FF33（ｑ　３）#FFFFFFの値は’３を評価した結果#33FF33３#FFFFFFになっちゃうけど、/
This will be #33FF33x#FFFFFF"\
r_show ari_n
Arisa: "As Suzuka said at the beginning, the #FFFF33 formal argument is actually bound to the actual argument #FFFFFF. @/
ただ、それだけだと問題があるの。@
#33FF33/
（ｄｅｆｉｎｅ　ｘ　１）⇒ｘ
（ｄｅｆｉｎｅ　ｙ　３）⇒ｙ
（ｄｅｆｉｎｅ　ｆ
　（ｌａｍｂｄａ　（ｘ）
　　（＋　ｘ　ｙ）））　⇒ｆ
（ｆ　７）　　　　　　　⇒１０#FFFFFF
What do you think will happen to the environment if these four expressions are evaluated in order? "\
r_show suzur_dotc
Suzuka: "Well, first x is bound to 1. @Then y is bound to 3. @/
Then f is bound by the function. @Finally, f is called with 7. @/
Then the formal parameter x is bound to the actual parameter 7...@/
r_show suzur_exc
What? x is bound twice! "\
r_show ari_n
Arisa: "That would be confusing, so I want to treat "f's formal parameter x" and "x outside the function" as separate things. @/
So when a function is called, a new empty environment is created, where the formal parameters are bound to the actual parameters, and @/
What if the expressions inside the function are evaluated under that environment? "\
r_show suzur_nc
Suzuka: "So two environments are created. That's a bit confusing, isn't it?"\
r_show ari_n
Arisa: "Well, let's call the new environment #FFFF33NewEnvironment#FFFFFF and the previous environment #FFFF33OldEnvironment#FFFFFF/

@/
show_dgm ":l;img/dgm0504.bmp"

Then, the new environment will be used only during the function call, and the old environment will be used again after the function call is over."\
r_show suzur_dotc
Suzuka: "Well, when #33FF33(f 7)#FFFFFF is evaluated, an environment called "x is 7" is created, and then #33FF33(+x y)#FFFFFF is evaluated based on that. @/
r_show suzur_T_T
But then, we know that x is 7 from the environment, but y isn't in the environment, so this expression can't be evaluated."\
csp SP_DGM0
r_show ari_n
Alisa: "Right. So we need to try a little harder. @/
A little bit off topic, but a formal argument is also called #FFFF33 bound variable #FFFFFF. In this case, it's x. /
The binding of bound variables is always included in the new environment. @/
In contrast, variables that are not formal arguments to a function, like y here, but appear in the function's internal formula, are called/
#FFFF33free variables#FFFFFF"\
r_show suzur_n
Suzuka: "Formal arguments are bound variables, and other variables are free variables"\
r_show ari_n
Arisa: "The binding of free variables is not in the new environment, but it is outside the function - in other words, it should be in the old environment. @/
So when Lambda creates a function, it stores the environment used for evaluation/
in the function to be created. @/
show_dgm ":l;img/dgm0505.bmp"
In this case, the environment is bound to "x is 1" and "y is 3."\
r_show suzur_n
Suzuka: "In other words, in addition to the formula inside the function, the lambda is also held in the environment where it was evaluated."\
r_show ari_n
Arisa: "However, when I say "hold," I don't mean that it remembers all the data of the environment directly, just like cons. Instead, it remembers the location of the environment. Rather than "holding," it might be easier to imagine it as "pointing an arrow."\
r_show suzur_n
Suzuka: "Since the environment is not copied in its entirety, there is no need to worry about speed."\
r_show ari_n
Arisa: "When you call the function you created, you create a new environment, bind the formal arguments to the actual arguments, and then connect the environment #FFFFFF held by the #FFFF33 function to the end of that environment. @/
show_dgm ":l;img/dgm0506.bmp"
When evaluating a variable, first look in the new environment, and if not found, look in the connected environment."\
r_show suzur_nc
Suzuka: "So, when evaluating #33FF33 (+ x y) #FFFFFF, @/
look for x in the new environment to find the value. @/
look for y in the new environment, but it's not found. @/
So look for it in the connected environment and find the value. @/
This is how you get the correct result."\
csp SP_DGM0
r_show ari_n
Arisa: "This is just one example of an interpreter implementation, and not all interpreters are built this way. @/
But even if the structure is different, the result is the same, so don't worry."\
r_show suzur_ase
Suzuka: "I'm not sure if I understand this or not."\
r_show ari_n
Arisa: "Well, you don't need to understand this right away. @/
Just remember that if the name of a function's formal argument matches the name of a variable outside the function, the formal argument will be used."\

mov %adv_noroi_off, 0  ;; Resuming hitting Yuno
  vsp SP_R, 0
  bg black, E_NORMAL
  r_load ari_exc
  l_load suzu_n
  bgm ms_after
  bg "img/blackboard.bmp", E_NORMAL
  talk_mode
Suzuka: "This building's window shows not Mount λ, but 'Myo' and 'Ho'."\
  l_show suzu_qes
Suzuka: "By the way, the officer mentioned the #FFFF33 Belkan-style#FFFFFF magic, but I wonder what it was about?"\
  r_show ari_n
Arisa: "I researched it, and there seem to be two styles of magic: Mid-style and Belkan-style."\
Suzuka: "I see. But why is our magic Belkan-style?"\
Arisa: "Mid-style is in Common Lisp, and Belkan-style seems to be in Scheme."\
  l_show suzu_dot
Suzuka: "...That's some intense setting."\
  r_show ":l;img/arin.bmp"
Arisa: "Ariiin"\
Arisa: "Don't call it a setting!"\

;;;;;第5話終了;;;;;
  speak_mode
  textclear
  vsp SP_R, 0
  vsp SP_L, 0
  bg black, E_SLOW
;;共通記録の書き換え
  csvopen "arisa.szk", "rc"
  csvread %adv_clear
  csvclose
  if %adv_clear >= 5 goto *story05_after 
  mov %adv_clear, 5
  csvopen "arisa.szk", "wc"
  csvwrite %adv_clear
  csvclose
#FFFF33Additional explanations#FFFFFF have been added.
#FFFF33A term has been added#FFFFFF to the glossary.\
*story05_after
  r_show suzur_nc
Suzuka: "どうしようかな？"
csel "Read additional explanation", *story05_condicil, "Read glossary", *story05_glossary, "Return to title", *title_back, "Proceed to Chapter 6", *story06

*story05_condicil
  gosub *condicil
  goto *story05_after
*story05_glossary
  gosub *glossary
  goto *story05_after

;;;;;第6話;;;;;
*story06
  mov %adv_noroi_off, 0
  csp SP_R : csp SP_L : print E_FAST
  stop
  talk_mode
  bgm ms_kyoto
  bg "img/blackboard.bmp", E_FAST
  r_in ari_n
  l_in suzu_n
Suzuka: "Samejima-san"\
r_show ari_qes
Arisa: "Hmm, what?"\
Suzuka: "He's 57 years old, right?"\
Arisa: "I think he is, but what about that?"\
l_show suzu_dot
Suzuka: "Well, if we were using magic, we'd be "magic girls", but in Samejima-san's case..."\
r_show ari_dere
Arisa: "Magic! W250...! W250...! W500 old man?"\
l_show suzu_dere
Suzuka: "I think old man is a bit harsh"\
r_show ari_do
Arisa: "Shut up, shut up, shut up! Just be a magician!"\

csp SP_R : csp SP_L : print 1
  bg "img/title#06.bmp", E_VFAST
  wait 1000
  delay 2000
  bg "img/blackboard.bmp", E_FAST

bgm ms_setsume
  speak_mode
  r_show ari_n
Arisa: "Let's start with an example this time.@ #33FF33/ (if (= x 0) 1 (- x 1))#FFFFFF If this expression is evaluated, if the value of x is 0, it becomes 1, otherwise, it becomes the number obtained by subtracting 1 from x."\
  r_show suzur_nc
Suzuka: "#33FF33if#FFFFFF and #33FF33=#FFFFFF are appearing for the first time.@/ = checks if the first argument and the second argument are the same number, right?@/ And if returns either the second or the third argument by looking at that result, right?"\
  r_show ari_n
Arisa: "= is a function that takes two numbers as arguments and returns the value #33FF33#t#FFFFFF if the two numbers are equal, and the value #33FF33#f#FFFFFF if they are different.@/ #t and #f are values used in Scheme to represent true (#FFFF33true#FFFFFF) and false (#FFFF33false#FFFFFF)./ The type is called #FFFF33boolean#FFFFFF, and the only values of this type are #t and #f.@/ On the other hand, if is a special form that takes three expressions.@/ It evaluates the first argument, and if that value is true, it evaluates the second argument and that becomes the result.@/ If it evaluates the first argument and the value is false, it evaluates the third argument and that becomes the result.@/ True and false refer to #t and #f, as I mentioned earlier, but be careful because any value other than #f is treated as true.@/ So, when we say false, it's only #f, but when we say true, it refers to all values other than #f."\
  r_show suzur_excc
Suzuka: "The operation of if is quite complex.@/ If the value evaluated from the first argument is true, the third argument is #FFFF33not evaluated#FFFFFF, and if the value evaluated from the first argument is false, the second argument is #FFFF33not evaluated#FFFFFF."\
  r_show ari_n
Arisa: "There is a similar special form called #33FF33cond#FFFFFF.@ #33FF33/ (cond (condition1 exec1) (condition2 exec2) ... (conditionN execN) (else execE))#FFFFFF When this expression is evaluated, it'll first evaluate condition1, and if it's true, it will evaluate exec1 and return that value.@/ If it's false, it will evaluate condition2, and if it's true, it will evaluate exec2 and return that value.@/ It repeats this for conditionN as well, and if that's false too, it evaluates execE and returns that value.@/ You can write as many condition expressions as you like."\
  r_show suzur_nc
Suzuka: "cond evaluates each condition expression in order, and evaluates the corresponding execution expression for the one that becomes true, returning that value.@/ If all conditions are false, it evaluates the execution expression execE that follows else and returns that value.@/ If you rewrite the previous expression using this, it can be written as #33FF33/ (cond ((= x 0) 1) (else (- x 1)))#FFFFFF"\
  r_show ari_n
Arisa: "cond, like if, also has arguments that are not evaluated.@/ From the examples so far, there's no problem evaluating both #33FF33 1 #FFFFFF and #33FF33(- x 1)#FFFFFF, but/ there's a case where it's a problem if both are evaluated.@ #33FF33/ (define fact (lambda (n) (if (= n 0) 1 (* n (fact (- n 1))))))#FFFFFF Sorry it's hard to read, but this defines a function to find the factorial.@/ The factorial of n is the product 'n × (n-1) × (n-2) × ... × 1'.@/ When you evaluate #33FF33(fact 3)#FFFFFF, it calculates 3 × 2 × 1, which results in 6."\
  r_show suzur_dotc
Suzuka: "Initially, assuming the actual argument is not 0, result comes from multiplying #33FF33n#FFFFFF by #33FF33(fact (- n 1))#FFFFFF.@/ Although fact is called inside itself, since the actual argument keeps getting smaller, it eventually becomes 0.@/ Then, instead of calling fact, it returns 1, so it's definitely calculating the factorial."\
  r_show ari_n
Arisa: "Here, the characteristic that 'if has unevaluated arguments' is being used.@/ If both the second and third arguments were always evaluated, fact would be called even when n is 0,/ and the calls to fact would never end."\
  r_show suzur_n
Suzuka: "It's interesting that a function calls itself.@/ At the point when the lambda expression is being evaluated, fact's value hasn't been defined yet,/ it's a bit puzzling how it works well..."\
  r_show ari_n
Arisa: "A function that calls itself is known as a #33FF33recursive call#FFFFFF.@/ It's sometimes abbreviated as recursion.@/ Before fact is defined, a call to fact is written inside the lambda, but/ explaining why this works well involves explaining environments again.@/ As I mentioned before, functions created when lambda is called maintain the environment of that time.@/ Later, when fact is defined, the binding to the function is added to the environment, but/ functions just point to the environment, so the new binding is properly reflected./ So, it works well."\
  r_show suzur_ase
Suzuka: "Even though my head is kind of spinning, I want to try practicing something anyway."\
  r_show ari_n
Arisa: "Expressions using recursive calls can, at worst, never end their evaluation.@/ In NSCLisper, if evaluation takes too long, it will ask if you want to forcibly end the evaluation.@/ However, forcing it to end will also terminate the program itself.@/ Therefore, I suggest saving at this point.@/ Also, if you're not confident in your answer, I recommend pressing the Tab key to see a hint."\

gosub *ex_init
*ex06
  mov $problem_label, "*ex06_problem"
  mov $tab_label, "*ex06_tab"
  mov $ret_label, "*ex06"
  mov $suc_label, "*ex06_check"
  goto *ex_rep
*ex06_problem
!s0Arisa: "Define the function s as 'a function that receives n as an argument and returns 1 + 2 + ... + n'. /
However, you can think of it as having one argument, and only a number."!sd
  return
*ex06_check
  gosub *pop : gosub *pop
  ;;;検証1
  mov $sarg0, "(s 0)"
  gosub *input_to_lobject
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *eval_form
  mov %arg0, %ret
  gosub *get_data
  mov $sarg0, "*ex06_miss"
  if %ret != 0 goto *ex_check_fail
  ;;;検証2
  mov $sarg0, "(s 6)"
  gosub *input_to_lobject
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *eval_form
  mov %arg0, %ret
  gosub *get_data
  mov $sarg0, "*ex06_2_prev"
  if %ret == 21 goto *ex_check_pass
  mov $sarg0, "*ex06_miss"
  goto *ex_check_fail
*ex06_miss
  textclear
  r_show ari_die
  Arisa: "No, try again!"
  r_show ari_n
  inc %adv_tmp
  goto *ex06

*ex06_2_prev
  mov $sarg0, "s"
  gosub *create_symbol
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *find_var
  mov %arg0, %ret
  gosub *cdr
  mov %arg0, %ret
  gosub *push     ;S(s)
*ex06_2
  mov $problem_label, "*ex06_2_problem"
  mov $tab_label, "*ex06_2_tab"
  mov $ret_label, "*ex06_2"
  mov $suc_label, "*ex06_2_check"
  goto *ex_rep
*ex06_2_problem
!s0Arisa: "Call s with arguments #33FF3310#FFFFFF"!sd
  return
*ex06_2_check
  gosub *pop      ;ret<S(input, s)
  mov %arg0, %ret
  gosub *pop      ;input<S(s)
  gosub *get_data
  mov $sarg0, "*ex06_end"
  if %ret == 55 gosub *pop : goto *ex_check_pass_end
;;;sの再定義をcheck;;;
  mov $sarg0, "s"
  gosub *create_symbol
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *find_var
  mov %arg0, %ret
  gosub *cdr
  mov %arg0, %ret
  gosub *pop      ;s<S()
  mov $sarg0, "*ex06_2_miss"
  if %arg0 != %ret goto *ex_check_fail
  mov %arg0, %ret
  gosub *push     ;S(s)
  mov $sarg0, "*ex06_2_normal_miss"
  goto *ex_check_fail
;;;end;;;
*ex06_2_normal_miss
  textclear
  r_show ari_die
Arisa: "No, try again!"
  r_show ari_n
  inc %adv_tmp
  goto *ex06_2

*ex06_2_miss
  textclear
  r_show ari_muka
Arisa: "……You're doing something quite interesting. @/
  r_show ari_do
Start over from the beginning!!!"\
  r_show ari_n
  inc %adv_tmp
  goto *ex06

*ex06_tab
csel "Continue", *ex06, "Hint", *ex06_hint,  "Return to Title", *ex06_bye
*ex06_2_tab
csel "Continue", *ex06_2, "Hint", *ex06_2_hint,  "Return to Title", *ex06_2_bye

*ex06_bye
  mov %adv_rmode, 1        ;Right click enabled
  textclear
  csp SP_R
  stop
  gosub *pop      ;new env<S()
  goto *title

*ex06_2_bye
  gosub *pop      ;s<S()
  goto *ex06_bye

*ex06_hint
  textclear
Arisa: "Since it only takes one argument, you can write it as #33FF33 (lambda (n) expression) #FFFFFF. @/
But the difficult part is this expression. @/
It calculates 1 + 2 + ... + (n-1) + n, which is very similar to calculating factorials. @/
When n is 0, it will naturally be 0. @/
Otherwise, it will be n plus 1 + 2 + ... (n-1). @/
s is a function that calculates 1 + 2 + ... n. Since it's a number, if you send n-1 as an argument, you can calculate 1 + 2 + ... (n-1). @/
In other words, you can use a recursive call to call s within s. @/
Then, the definition of s can be written as #33FF330#FFFFFF if n is 0, @or #33FF33(+n(s(-n1)))#FFFFFF otherwise. @/
All you have to do is use if or cond to make this into a formula"\
goto *ex06

*ex06_2_hint
textclear
Arisa: "Just write the formula #33FF33(function argument)#FFFFFF"\
  goto *ex06_2

*ex06_end
  mov %adv_rmode, 1        ;右クリック有効
  gosub *pop  ;new env<S()
  saveon
  mov %save_flag, 1  ;セーブ可能
  textclear
  add %adv_miss, %adv_tmp
  bgm ms_setsume
  if %adv_tmp == 0 goto *s_06_2
  if %adv_tmp >=4   goto *s_06_3
*s_06_1
Arisa: "Not bad"\
goto *s_06_4
*s_06_2
r_show ari_hrt
Arisa: "No problems at all"\
goto *s_06_4
*s_06_3
r_show ari_ase
Arisa: "There are quite a few mistakes"\
  goto *s_06_4
*s_06_4
Arisa "It was so-so."\
  goto *s_06_4
*r_show ari_hrt
Arisa "It seems there is no problem at all."\
  goto *s_06_4
*r_show ari_ase
Arisa "There are quite a few mistakes."\
  goto *s_06_4
*s_06_4

r_show suzur_n
Suzuka: "Even so, the amount of input required for practice questions has increased considerably." \
r_show ari_n
Arisa: "Actually, there is a way to make function definitions a little shorter.
#33FF33/
(define (function name formal parameter 1...formal parameter n)
expression)
(define function name
(lambda (formal parameter 1...formal parameter n)
expression))#FFFFFF
These two expressions are treated as exactly the same." \
r_show suzur_hrt
Suzuka: "It saves me the trouble of writing lambda and one parenthesis. @/
If such a convenient thing existed, I wish you had told me about it sooner." \
r_show ari_n
Arisa: "It's certainly useful, but it makes the system difficult to understand. @/
define is just a special form that creates bindings./
It doesn't have any special mechanism for creating functions. @/
This new way of writing is just a #FFFF33 omission #FFFFFF of the old way of writing."\
r_show suzur_n
Suzuka: "On the other hand, once you understand it, you can use it as much as you like without any problems."\
r_show ari_tun
Arisa: "Well, that's true. @There's also a short way of writing that does the same thing, like quotation marks for quote, called #FFFF33syntax sugar."\
r_show suzur_nc
Suzuka: "It's useful, but when you use it, you should make sure you understand what it means."\

vsp SP_R, 0
  bg black, E_NORMAL
  r_load ari_n
  l_load suzu_n
  bgm ms_after
  bg "img/blackboard.bmp", E_NORMAL
  talk_mode
Suzuka: "I know we can't keep being the ones chased, but what should we do?"\
Arisa: "Let's look for an opportunity and try to get in touch with Nanoha."\
  l_show suzu_qes
Suzuka: "Do you think that will work?"\
  r_show ari_hrt
Arisa: "It seems like Nanoha knows some big shots at the Time-Space Administration Bureau. If we ask her, I'm sure she can smooth things over for us."\
  l_show suzu_ase
Suzuka: "Wow..."\
  r_show ari_n
Arisa: "Well, it would be quite a bother if we asked right away, so let's lay low here until things cool down a bit."\

;;;;;第6話終了;;;;;
  speak_mode
  textclear
  vsp SP_R, 0
  vsp SP_L, 0
  bg black, E_SLOW
;;共通記録の書き換え
  csvopen "arisa.szk", "rc"
  csvread %adv_clear
  csvclose
  if %adv_clear >= 6 goto *story06_after 
  mov %adv_clear, 6
  csvopen "arisa.szk", "wc"
  csvwrite %adv_clear
  csvclose
#FFFF33Additional explanation#FFFFFF has been added.
#FFFF33Glossary#FFFFFF has been updated with a word.\
*story06_after
  r_show suzur_nc
Suzuka: "What should I do?"
csel "Read additional explanation", *story06_condicil, "Read glossary", *story06_glossary, "Return to title", *title_back, "Proceed to Episode 7", *story07

*story06_condicil
  gosub *condicil
  goto *story06_after
*story06_glossary
  gosub *glossary
  goto *story06_after

;;;;;第7話;;;;;
*story07
  mov %adv_noroi_off, 0
  csp SP_R : csp SP_L : print E_FAST
  stop
  talk_mode
  bgm ms_kyoto
  bg "img/blackboard.bmp", E_FAST
  r_in ari_n
  l_in suzu_n
  l_show suzu_qes
Suzuka: "I heard that Nanoha's magic can attack from a distance, but I wonder if you can't do that?"\
r_show ari_tun
Arisa: "Well, even if you put in that kind of magic program, it's pointless if the caster can't use it."\
l_show ":l;img/same.bmp"
Samejima: "I'm ashamed to say, but it seems I can't use it."\
Arisa: "That's right."\
l_show suzu_dotc
Suzuka: "Well, it's a bit disappointing that the effective range of the magic is narrow."\

csp SP_R : csp SP_L : print 1
  bg "img/title#07.bmp", E_VFAST
  wait 1000
  delay 2000
  bgm ms_setsume
  bg "img/blackboard.bmp", E_FAST

speak_mode
  r_show ari_n
Arisa: "I'll talk about variables.
#33FF33/
(define x 1)
(define y 2)
(define f
  (lambda (n)
    (+ n x)))#FFFFFF
Variables defined like x, y, and f can be used from anywhere. @/
For example, you can create a function and use them from inside that function. @/
Such variables are called #FFFF33global variables#FFFFFF." \
  r_show suzur_n
Suzuka: "The variables we've been creating with define are global variables, right?" \
  r_show ari_n
Arisa: "Then, the environment where global variables are bound is called the #FFFF33global environment#FFFFFF. @/
In contrast, the n used as a parameter of f can only be used inside f. @/
Such variables are called #FFFF33local variables#FFFFFF." \
  r_show suzur_excc
Suzuka: "Variables that can only be used within a specific scope are called local variables." \
  r_show ari_n
Arisa: "The range where a variable is visible is called its #FFFF33scope#FFFFFF. @/
The scope of a global variable is the entire program, but the scope of a local variable is limited." \
  r_show suzur_nc
Suzuka: "Since the scope of a global variable is the entire program, it's fine, but the scope of a local variable is limited, so I should be mindful of the scope, right?" \
  r_show ari_n
Arisa: "There's a special form called #33FF33let#FFFFFF that creates local variables.
#33FF33/
(let ((variable1 expression1)
      (variable2 expression2)
      ...
      (variablen expressionn))
  expression)#FFFFFF
When evaluating let, first, expressions 1 to n are evaluated. @/
  show_dgm ":l;img/dgm0701.bmp"
Then, a new environment is created, and the bindings of variable1 to value of expression1, and variable2 to value of expression2 are added repeatedly up to n. @/
  show_dgm ":l;img/dgm0702.bmp"
At the end, the environment where let was evaluated is appended to this new environment. @/
And then, the expression is evaluated in this new environment, and the result becomes the overall result. @/
  show_dgm ":l;img/dgm0703.bmp"
After finishing the let call, evaluations are done in the original environment, so variables 1 to n are only effective within the let. @/
In other words, the scope of variables created inside let is limited to inside let." \
  csp SP_DGM0
  r_show suzur_nc
Suzuka: "So, it's creating temporary variables. I kind of get it, but I’m not sure about how to use it..." \
  r_show ari_n
Arisa: "For instance, suppose you want to create a cons that has both the CAR and CDR of the second element of a list lst.
#33FF33/
(cons (car (cdr lst))
      (car (cdr lst)))#FFFFFF
You can see that the expression to extract the second element of lst appears twice. @/
Evaluating the same expression twice isn’t very elegant, right? @/
That's where you can use let,
#33FF33/
(let
  ((x (car (cdr lst))))
  (cons x x))#FFFFFF
In this case, the expression to extract the second element of lst is evaluated once, and the value is bound to x in a new environment. The expression is then evaluated using that x. @/
The results are the same, but this way, you save the effort of doing the same calculation twice." \
  r_show suzur_n
Suzuka: "Indeed, that's a bit convenient." \
  r_show ari_n
Arisa: "But creating a new environment and adding bindings is something I mentioned about functions as well, right? @/
Actually, this expression can also be written like this:
#33FF33/
((lambda (x)
   (cons x x))
 (car (cdr lst)))#FFFFFF
A function created with lambda is called with the second element of lst attached. @/
In this case, x is bound in the new environment, resulting in exactly the same outcome as using let." \
  r_show suzur_excc
Suzuka: "With let, you can readily understand the correspondence between x and its binding of the second element of lst, but with lambda, the parameter x and the actual argument, the second element of lst, are a bit apart, so it’s a bit hard to understand." \
  r_show ari_exc
Arisa: "Even though they serve the same role, let makes creating local variables easier to understand, right? @/
Actually, let is syntactic sugar for lambda. @/
Lambda just creates a function, but let does both creation and invocation, so it might seem a bit different. However, any expression written with let can be rewritten using lambda." \
  r_show suzur_n
Suzuka: "Following quote and function definition with define, let is the third syntactic sugar, right?" \
  r_show ari_n
Arisa: "Now let's see let being used inside a function.
#33FF33/
(define f
  (lambda (n)
    (let
     ((m (+ n 1)))
     (* n m))))#FFFFFF
From outside the function f, you can't see n and m, and even inside f, m is not visible from outside let. @/
  show_dgm ":l;img/dgm0704.bmp"
In other words, the inner variables are not visible from the outer side and any outer variables are visible from the inside." \
  csp SP_DGM0
  r_show suzur_qes
Suzuka: "It feels like I’ve understood, but not quite… Oh! let can be rewritten with lambda, right? @/
If so, can’t this expression be rewritten so lambda appears inside lambda?" \
  r_show ari_n
Arisa: "Nice observation. This expression can be rewritten as follows:
#33FF33/
(define f
  (lambda (n)
    ((lambda (m)
       (* n m))
     (+ n 1))))#FFFFFF
What I want you to remember here is the mechanism of lambda. @/
Functions maintain the environment they were evaluated in when lambda was called." \
  r_show suzur_dotc
Suzuka: "Umm, first, the outer lambda expression is evaluated as an argument to define. @/
At this time, the resulting function?namely f?maintains the global environment, right? @/
  show_dgm ":l;img/dgm0705.bmp"
Lambda doesn't evaluate its arguments, so the inner lambda expression isn't evaluated yet. @/
At this point, evaluating #33FF33(f 16) #FFFFFF creates a new environment where n is bound to 16. @/
  show_dgm ":l;img/dgm0706.bmp"
Following that is the environment maintained by the function?the global environment. Let's call this resultant environment Env E. @/
With this Env E, #33FF33(+ n 1) #FFFFFF is evaluated as an argument, and the inner lambda expression is evaluated as a function. /
The function created temporarily here maintains Env E. @/
  show_dgm ":l;img/dgm0707.bmp"
Then, invoking the function with the value 17 of #33FF33(+ n 1) #FFFFFF creates a new environment where m is bound to 17. @/
Following that is the environment maintained by the function?Env E. @/
  show_dgm ":l;img/dgm0708.bmp"
Thus, the final environment created allows seeing all bindings of m, n, and the global environment." \
  csp SP_DGM0
  r_show ari_ase
Arisa: "You understood it in one go... @This is the true form of 'inner can see outer, outer can't see inner,' but it's normal to not fully understand at first. @/
In such cases, it's good to remember solidly that #FFFF33inner can see outer#FFFFFF." \
  r_show suzur_qes
Suzuka: "So, is it time for practice problems as usual?" \
  r_show ari_tun
Arisa: "Hmm... Let is merely a convenient way to use lambda, so posing problems is a bit..." \
  r_show suzur_hrt
Suzuka: "Just after making it look like there might be no problems, that's cruel..." \
  r_show ari_n
Arisa: "I'll give supplementary explanations about lists in preparation for the problems. @/
There’s a function called #33FF33null?#FFFFFF that returns #t if its argument is an empty list, and #f otherwise.
#33FF33/
(null? '())  ⇒ #t
(null? '(a)) ⇒ #f#FFFFFF" \
  r_show suzur_nc
Suzuka: "Since it returns #t or #f, it seems like a function that could be used with if or cond." \
  r_show ari_n
Arisa: "Functions that return #t or #f are called #FFFF33predicates#FFFFFF. @/
There are many predicates with names ending in a question mark." \
  r_show suzur_n
Suzuka: "So, functions like #33FF33null?#FFFFFF and #33FF33= #FFFFFF are called predicates." \
  r_show ari_n
Arisa: "You can think of an empty list as 'a list with 0 elements,'. @/
Also, using cdr on a list with only one element returns an empty list. @/
  show_dgm ":l;img/dgm0709.bmp"
You can understand if you draw a diagram of a list. @/
Then, remember that cdr can be considered a function that creates a list by taking out the first element. @/
From these, you can also think of cdr as a function that creates a list with one less element than the original list." \

csp SP_DGM0
  gosub *ex_init
*ex07
  mov $problem_label, "*ex07_problem"
  mov $tab_label, "*ex07_tab"
  mov $ret_label, "*ex07"
  mov $suc_label, "*ex07_check"
  goto *ex_rep
*ex07_problem
!s0Arisa: "Define the function len as a function that receives x as an argument and returns the number of elements in x./
However, you can assume that there is only one argument, and that it is a list."!sd
  return
*ex07_check
  gosub *pop : gosub *pop
  ;;;検証1
  mov $sarg0, "(len '())"
  gosub *input_to_lobject
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *eval_form
  mov %arg0, %ret
  gosub *get_data
  mov $sarg0, "*ex07_miss"
  if %ret != 0 goto *ex_check_fail
  ;;;検証2
  mov $sarg0, "(len '(1 2 3 4 5))"
  gosub *input_to_lobject
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *eval_form
  mov %arg0, %ret
  gosub *get_data
  mov $sarg0, "*ex07_2_prev"
  if %ret == 5 goto *ex_check_pass
  mov $sarg0, "*ex07_miss"
  goto *ex_check_fail
*ex07_miss
  textclear
  r_show ari_die
Arisa: "Incorrect. Try again!"\
  r_show ari_n
  inc %adv_tmp
  goto *ex07

*ex07_2_prev
  mov $sarg0, "len"
  gosub *create_symbol
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *find_var
  mov %arg0, %ret
  gosub *cdr
  mov %arg0, %ret
  gosub *push     ;S(len)
*ex07_2
  mov $problem_label, "*ex07_2_problem"
  mov $tab_label, "*ex07_2_tab"
  mov $ret_label, "*ex07_2"
  mov $suc_label, "*ex07_2_check"
  goto *ex_rep
*ex07_2_problem
!s0Alisa "Call len with the argument #33FF33'(a b c)#FFFFFF."!sd
  return
*ex07_2_check
  gosub *pop      ;ret<S(input, len)
  mov %arg0, %ret
  gosub *pop      ;input<S(len)
  gosub *get_data
  mov $sarg0, "*ex07_end"
  if %ret == 3 gosub *pop : goto *ex_check_pass_end
;;;lenの再定義をcheck;;;
  mov $sarg0, "len"
  gosub *create_symbol
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *find_var
  mov %arg0, %ret
  gosub *cdr
  mov %arg0, %ret
  gosub *pop      ;len<S()
  mov $sarg0, "*ex07_2_miss"
  if %arg0 != %ret goto *ex_check_fail
  mov %arg0, %ret
  gosub *push     ;S(len)
  mov $sarg0, "*ex07_2_normal_miss"
  goto *ex_check_fail
;;;end;;;
*ex07_2_normal_miss
  textclear
  r_show ari_die
Alisa "That's wrong. Try again!"
  r_show ari_n
  inc %adv_tmp
  goto *ex07_2

*ex07_2_miss
  textclear
  r_show ari_muka
Arisa: "……You're doing something quite interesting, aren't you? @/
  r_show ari_do
Start over from the beginning!!!"\
  r_show ari_n
  inc %adv_tmp
  goto *ex07

*ex07_tab
csel "Continue", *ex07, "Hint", *ex07_hint,  "Return to Title", *ex07_bye
*ex07_2_tab
csel "Continue", *ex07_2, "Hint", *ex07_2_hint,  "Return to Title", *ex07_2_bye

*ex07_bye
  mov %adv_rmode, 1        ;Right-click enabled
  textclear
  csp SP_R
  stop
  gosub *pop      ;new env<S()
  goto *title

*ex07_2_bye
  gosub *pop      ;l<S(new env)
  goto *ex07_bye

*ex07_hint
  textclear
Arisa: "Since we only receive one argument, we can write it as #33FF33(lambda (x) expression)#FFFFFF.@/
This time, as in the last time, it looks like it will work if we use recursion.@/
Let's say we want to count the elements of the list #33FF33(a1 a2...an)#FFFFFF.@/
When n is 0 - that is, when it is an empty list, the number of elements will naturally be 0.@/
The number of elements is calculated by adding 1 to the number of elements in #33FF33(a2 a3...an)#FFFFFF. @/
This list can be made by taking the CDR of the original list. @/
In other words, the definition of len can be written as #33FF33０#FFFFFF if x is an empty list, @otherwise #33FF33(＋　1　(len(cdr　x))))#FFFFFF. @/
You can check if x is an empty list by using #33FF33null? #FFFFFF. @/
All you have to do is make this into an equation using if or cond"\
goto *ex07

*ex07_2_hint
textclear
Arisa: "Just write the equation #33FF33(function argument)#FFFFFF"\
  goto *ex07_2

*ex07_end
  mov %adv_rmode, 1        ;右クリック有効
  gosub *pop  ;new env<S()
  saveon
  mov %save_flag, 1  ;セーブ可能
  textclear
  add %adv_miss, %adv_tmp
  bgm ms_setsume
  if %adv_tmp == 0 goto *s_07_2
  if %adv_tmp >=2   goto *s_07_3
*s_07_1
Arisa: "Not bad"\
goto *s_07_4
*s_07_2
r_show ari_hrt
Arisa: "No problems at all"\
goto *s_07_4
*s_07_3
r_show ari_ase
Arisa: "There are quite a few mistakes"\
  goto *s_07_4
*s_07_4

r_show ari_n
Arisa "The scope of variables in Scheme is determined at the point where the expression is written. @/
This scope agreement is called #FFFF33lexical scope#FFFFFF. @/
Scheme and Common Lisp use lexical scope, but / 
many Lisp dialects, including elisp, use / 
#FFFF33dynamic scope#FFFFFF, where the scope is not determined until the expression is evaluated. @/
Since the two major forces of Lisp dialects use lexical scope, /
I will omit the discussion on dynamic scope here."\
  r_show suzur_nc
Suzuka "Lexical scope means you can see from the inside to the outside, but not from the outside to the inside."\
  r_show ari_n
Arisa "This time's content is: you can create local variables using let, @/
let is sugar syntax for lambda, @/
it's not a problem to write lambda inside lambda, @/
pay attention to how the environment is created in such cases. @/
That's the idea."\
  r_show suzur_n
Suzuka "Nevertheless, the practice problems seemed like a continuation of the previous recursion."\
  r_show ari_n
Arisa "Recursion is arguably the most important thing when writing programs in Lisp, @/
so I want you to be able to use it properly. @/
That's why I gave problems on recursion."\
  r_show suzur_nc
Suzuka "Certainly, being able to understand recursion made it possible to #FFFF33repeat#FFFFFF calculations."\
  r_show ari_exc
Arisa "When performing the same calculation repeatedly in Lisp, use recursion. @/
If you're familiar with other programming languages, you might think 'doing that is slow and consumes memory', but it's okay. @/
I'll talk about it later, but Lisp has a solution for that, so you can rest assured and use recursion."\

vsp SP_R, 0
  bg black, E_NORMAL
  r_load ari_n
  l_load suzu_n
  bgm ms_after
  bg "img/blackboard.bmp", E_NORMAL
  talk_mode
Arisa: "By the way, have you heard the story that Martians use Lisp?"\
  l_show suzu_dot
Suzuka: "It's amazing how it assumes Martians exist..."\
  r_show ari_tun
Arisa: "Kyoto's λ Mountain is famous, but actually, on Mars too... it exists."\
  l_show suzu_excc
Suzuka: "No way!"\
  r_show ari_exc
Arisa: "There's a λ character on a Martian crater! This character is proof that Martians use Lisp!!"\
  l_show suzu_exc
Suzuka: "Wha... what!?"\
  r_show ari_n
Arisa: "Well, that's if Martians exist."\
  l_show suzu_ase
Suzuka: "I was surprised for now, but even if there are Martians, I think there are issues with how this story progresses..."\

;;;;;第7話終了;;;;;
  speak_mode
  textclear
  vsp SP_R, 0
  vsp SP_L, 0
  bg black, E_SLOW
;;共通記録の書き換え
  csvopen "arisa.szk", "rc"
  csvread %adv_clear
  csvclose
  if %adv_clear >= 7 goto *story07_after
  mov %adv_clear, 7
  csvopen "arisa.szk", "wc"
  csvwrite %adv_clear
  csvclose
#FFFF33Supplementary explanation#FFFFFF has been added.
#FFFF33Glossary#FFFFFF has been updated.\
*story07_after
  r_show suzur_nc
Suzuka: "What should I do?"
csel "Read the supplementary explanation", *story07_condicil, "Read the glossary", *story07_glossary, "Return to title", *title_back, "Proceed to Episode 8", *story08

*story07_condicil
  gosub *condicil
  goto *story07_after
*story07_glossary
  gosub *glossary
  goto *story07_after

;;;;;第8話;;;;;
*story08
  mov %adv_noroi_off, 0
  csp SP_R : csp SP_L : print E_FAST
  stop
  talk_mode
  bgm ms_kyoto
  bg "img/blackboard.bmp", E_FAST
  r_in ari_n
  l_in suzu_n
Suzuka: "Prescriptions from the doctor can be written very carefully."\
Arisa: "They have pictures of the medicine in color, and the time to take the medicine is written in detail."\
l_show suzu_ase
Suzuka: "They also write a lot about the side effects of the medicine, and it makes me strangely worried."\

csp SP_R : csp SP_L : print 1
  bg "img/title#08.bmp", E_VFAST
  wait 1000
  delay 2000
  bg "img/blackboard.bmp", E_FAST

bgm ms_setsume
speak_mode
r_show ari_n
Arisa: "Let's try updating the value of a variable." \
r_show suzur_qes
Suzuka: "Until now, once you define a variable, its value never changes. @/
Are you going to change the value of a variable?" \
r_show ari_n
Arisa: "Well, let's take a look at an example.
#33FF33/
(define x 9)
(set! x 19) #FFFFFF
If you evaluate these two expressions in order and then evaluate #33FF33x#FFFFFF, the result will be 19." \
r_show suzur_n
Suzuka: "The value of x has changed from 9 to 19. @/
In other words, #33FF33(set! x 19) #FFFFFF rebinds x to 19." \
r_show ari_n
Arisa: "That's not quite right. @/
Actually, the #FFFF33 variable that we've been using so far is bound to a value #FFFFFF, which is not an accurate expression. @/
Actually, the variable is bound to a "box that can store only one value". @/
Then, the value of the variable is assigned to that box. @/
If you don't update the value of the variable, you can think of the variable and the value as directly linked, @/
but if you update the value of the variable, you have to think of the variable and the box as linked, /
and the value of the variable as being in that box." \
r_show suzur_n
Suzuka: "So then, set! rewrites the contents of that box." \
r_show ari_n
Arisa: "If you've understood the above, you'll know that #33FF33set! #FFFFFF is a special form.@/
You can tell by looking at how the first argument x is not evaluated and is treated as a symbol.@
#33FF33 (set! variable name expression) #FFFFFF
This allows you to change the contents of the box associated with the variable./
However, be careful because set! only changes the value of the variable,/
it does not create a new variable."\
r_show suzur_nc
Suzuka: "You need to create a variable before using set!."\
r_show ari_n
Arisa: "Also, set! is meaningful because it changes the value of the variable, and the value of the expression has no particular meaning.@/
In NScLisper, when you call set!, it returns #t, but it is not recommended to use this result.@/
This set! In this way, when the result value is meaningless, but the effect is meaningful, it is called an operation with #FFFF33side effects#FFFFFF." \
r_show suzur_dotc
Suzuka: "I can't use the value returned by set!. Then,
#33FF33/
(define (set - x! m n)
(set! x (+ m n)))#FFFFFF
I can't use the value returned by a function that uses set! like this...@/
It would be convenient if the value of x after the change was the value returned by the function." \
r_show ari_n
Arisa: "In that case, you can use the special form #33FF33begin#FFFFFF,
#33FF33/
(define (set - x! m n)
(begin
(set! x (+ m n))
x))#FFFFFF
and the value returned by the function will be the value of x after the change. @/
begin is a special form that takes any number of arguments, evaluates them in order starting from the first argument, and uses the result of evaluating the last argument as the overall value." \
r_show suzur_excc
Suzuka: "It evaluates all the arguments, but only uses the value of the last argument, so it's useful for putting expressions with side effects in between." \
r_show ari_n
Arisa: "Actually, when you define a function, begin is used implicitly, so you can write it like this:
#33FF33/
(define (set-x! m n)
(set! x (+ m n))
x)#FFFFFF
. @/
Of course, when you use lambda, you can write it like this:
#33FF33/
(define set-x!
(lambda (m n)
(set! x (+ m n))
x))#FFFFFF
"\
r_show suzur_nc
Suzuka: "In other words, when you define a function, you can write any number of expressions, and in that case, the expressions are evaluated in order, and the value of the last expression is used as the result of the entire function."\
r_show ari_n
Arisa: "You can write let, which is a syntactic sugar for lambda, as well, as follows:
#33FF33/
(let (...)
expression 1
...
expression n) #FFFFFF
This evaluates expressions 1 through n in order in the new environment, and the result of the entire expression is the value obtained by evaluating expression n." \
r_show suzur_n
Suzuka: "let is essentially the same as lambda, so it can do the same thing." \
r_show ari_n
Arisa: "You can also do the same thing with cond.
#33FF33
(cond (condition expression execution expression 1

...

execution expression n)

...)#FFFFFF
If you write it like this, if the result of evaluating the condition expression is true, execution expressions 1 to n will be evaluated in order, and the result of the entire expression will be the value of the execution expression n.\
r_show suzur_dotc
Suzuka: "If we continue with this flow, I wonder if we can do if too./
Well, how do we use if...
#33FF33/
(if condition expression

expression A

expression B)#FFFFFF@
r_show suzur_qes
Huh? if can only take three arguments, so can't we do something similar?"\
r_show ari_n
Arisa: "Unfortunately, if can only write one expression when the condition is true and one expression when it is false.@/
If you want to write multiple expressions, you can use cond or use begin inside if."\
r_show suzur_nc
Suzuka: "Um,
#33FF33/
(if condition
(begin
expression A1
...
expression An)
...)#FFFFFF
something like that."\
r_show ari_n
Arisa: "Let's go back to the topic of set!. The function we saw a while ago
#33FF33/
(define (set-x! m n)
(set! x (+ m n))
x)#FFFFFF
Let's think about what this means for a moment."\
r_show suzur_nc
Suzuka: "Well, this function set-x! takes two arguments and changes the value of x to their sum. @/
But I wonder if I need to define x with define before I do this." \
r_show ari_n
Arisa: "That's right. The x I'm touching here is the x outside the function.
#33FF33/
(define x 0)
(define (set-x! m n)
(set! x (+ m n))
x)
x ⇒0
(set-x! 9 19) ⇒28
x ⇒28#FFFFFF
From this result, we can see that the value of x on the outside has changed." \
r_show suzur_n
Suzuka: "I'm sure you touch the outside from the inside. This is the same when changing the value of a variable." \
r_show ari_n
Alisa: "Let's change this a little bit,
#33FF33/
(define x 0)
(define (set -x2! x n)

(set! x (+ x n))

x)
x ⇒ 0

(set - x! 9 19) ⇒ 28
x ⇒ 0#FFFFFF
If you do this, the outer x will not change.\
r_show suzur_dotc
Suzuka: "Well, in this case, the name x is used as an argument to set - x2!, so /
that x takes precedence over the outer x. @/
r_show suzur_qes
So, does that mean that the value update by set! is performed on the inner x, not the outer x?"\
r_show ari_exc
Arisa: "Exactly! You can do some interesting things by applying this. @/
But before that, let's review a bit. @/
In the let section, we did an example of writing a lambda inside a lambda."\
r_show suzur_n
Suzuka: "Yes, that's right. You can see the outside from the inside, but you can't see the inside from the outside." \
r_show ari_n
Arisa: "In that example, the function created in the inner lambda was called on the spot, but you can also do this.
#33FF33/
(define ma
(lambda (n)
(lambda (x)
(+n x))))#FFFFFF
What kind of function do you think this is?" \
r_show suzur_dotc
Suzuka: "Looking at the outer lambda, it's a function that takes one argument.@/
And the content is a lambda call -- that is, it creates a function and returns it...@/
r_show suzur_exc
The result of calling the function ma is a new function!?" \
r_show ari_n
Arisa: "When you evaluate an expression, it returns a value. Functions are also a type of value, so it's not strange. @/
lambda is a special form that returns a function. Similarly, ma is just a function that returns a function." \
r_show suzur_ase
Suzuka: "Well, if you look at the inner lambda, it's creating a function that takes one argument and returns the sum of it and n. @/
...Hmm, I don't really understand how to use it." \
r_show ari_n
Arisa: "Well, let's actually use it.
#33FF33/
(define a5 (ma 5)) ⇒ a5
(define a9 (ma 9)) ⇒ a9
(a5 5) ⇒ 10 (= 5 + 5)
(a9 5) ⇒ 14 (= 9 + 5)
(a5 1) ⇒ 6 (= 5 + 1)
(a9 1) ⇒ 10 (= 9 + 1)#FFFFFF@
a5 and a9 are bound by the newly created function, but as you can see from the results, it's important that the value n used in each remains intact."\
r_show suzur_nc
Suzuka: "n is the formal argument of the function ma, right? Even after the call to ma is finished, it continues to be used in the function created by the lambda inside." \
r_show ari_n
Arisa: "This is possible because the function remembers the environment. @/
For example, in the case of a5, it remembers the environment in which the lambda evaluation inside ma was evaluated -- that is, the environment that "n is 5" -- so it works. /
It's exactly the same in the case of a9." \
r_show suzur_qes
Suzuka: "That's kind of complicated. By the way, what do you mean by 'interesting'?" \
r_show ari_n
Alisa: "Combine this example with set!.
#33FF33/
(define ma2
(lambda (n)
(lambda (x)
(set! n (+ n x))
n))#FFFFFF
This time we're changing the stored value of n./
Now, let's try using this in the same way as before."\
r_show suzur_nc
Suzuka: Well,
#33FF33/
(define a4 (ma2 4))
(a4 8) ⇒ 12 (= 4 + 8)
(a4 8) ⇒ 20 (= 12 + 8)
(a4 8) ⇒ 28 (= 20 + 8)
(a4 8) ⇒ 36 (= 28 + 8)#FFFFFF
If you call it with an argument of 8, the result will increase by 8.
Right. @/
The value of n stored in the function has been properly changed." \
r_show ari_n
Arisa: "By the way, this function can also be used like this:
#33FF33/
((ma2 4) 8) ⇒ 12#FFFFFF
@/
All functions that return functions are allowed to be written like this:
#33FF33/
((function argument) argument)#FFFFFF
@/
However, this is only for Scheme, and some Lisp dialects do not allow this writing style, so be careful." \
r_show suzur_n
Suzuka: "So in Scheme, functions that return functions can be written like lambda." \
r_show ari_die
Arisa: "set! is useful, but it can cause confusion if overused, so you should think carefully about when to use it." \
r_show suzur_excc
Suzuka: "I guess that means you have to be careful about side effects."
r_show ari_n
Arisa: "Now, shall we do some practice questions?"

gosub *ex_init
*ex08
  mov $problem_label, "*ex08_problem"
  mov $tab_label, "*ex08_tab"
  mov $ret_label, "*ex08"
  mov $suc_label, "*ex08_check"
  goto *ex_rep
*ex08_problem
!s0Arisa: "Define function f as 'When it receives x as an argument, it returns #33FF33, a function that takes one argument, x, and returns its sum #FFFFFF'./
However, you can think of it as having only one argument, a number."!sd
  return
*ex08_check
  gosub *pop : gosub *pop
  ;;;検証1
  mov $sarg0, "((f 9) 99)"
  gosub *input_to_lobject
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *eval_form
  mov %arg0, %ret
  gosub *get_data
  mov $sarg0, "*ex08_miss"
  if %ret != 108 goto *ex_check_fail
  ;;;検証2
  mov $sarg0, "((f 2) 5)"
  gosub *input_to_lobject
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *eval_form
  mov %arg0, %ret
  gosub *get_data
  mov $sarg0, "*ex08_2_prev"
  if %ret == 7 goto *ex_check_pass
  mov $sarg0, "*ex08_miss"
  goto *ex_check_fail
*ex08_miss
  textclear
  r_show ari_die
Arisa: "No, try again!"
  r_show ari_n
  inc %adv_tmp
  goto *ex08

*ex08_2_prev
  mov $sarg0, "f"
  gosub *create_symbol
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *find_var
  mov %arg0, %ret
  gosub *cdr
  mov %arg0, %ret
  gosub *push     ;S(f)
*ex08_2
  mov $problem_label, "*ex08_2_problem"
  mov $tab_label, "*ex08_2_tab"
  mov $ret_label, "*ex08_2"
  mov $suc_label, "*ex08_2_check"
  goto *ex_rep
*ex08_2_problem
!s0Arisa: "Call the function returned by #33FF33(f 6)#FFFFFF with the argument #33FF33 66#FFFFFF!sd
  return
*ex08_2_check
  gosub *pop      ;ret<S(input, f)
  mov %arg0, %ret
  gosub *pop      ;input<S(f)
  gosub *get_data
  mov $sarg0, "*ex08_end"
  if %ret == 72 gosub *pop : goto *ex_check_pass_end
;;;fの再定義をcheck;;;
  mov $sarg0, "f"
  gosub *create_symbol
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *find_var
  mov %arg0, %ret
  gosub *cdr
  mov %arg0, %ret
  gosub *pop      ;f<S()
  mov $sarg0, "*ex08_2_miss"
  if %arg0 != %ret goto *ex_check_fail
  mov %arg0, %ret
  gosub *push     ;S(f)
  mov $sarg0, "*ex08_2_normal_miss"
  goto *ex_check_fail
;;;end;;;
*ex08_2_normal_miss
  textclear
  r_show ari_die
Arisa: "No, try again!"\
  r_show ari_n
  inc %adv_tmp
  goto *ex08_2

*ex08_2_miss
  textclear
  r_show ari_muka
Arisa: "……This is quite an interesting thing you're doing.@/
  r_show ari_do
Start over from the beginning!!!"\
  r_show ari_n
  inc %adv_tmp
  goto *ex08

*ex08_tab
csel "Continue", *ex08, "Hint", *ex08_hint,  "Return to Title", *ex08_bye
*ex08_2_tab
csel "Continue", *ex08_2, "Hint", *ex08_2_hint,  "Return to Title", *ex08_2_bye

*ex08_bye
  mov %adv_rmode, 1        ;右クリック有効 (Right-click enabled)
  textclear
  csp SP_R
  stop
  gosub *pop      ;new env<S()
  goto *title

*ex08_2_bye
  gosub *pop      ;f<S(new env)
  goto *ex08_bye

*ex08_hint
  textclear
Arisa: "Since it takes one argument, you can write #33FF33(lambda (x) expression)#FFFFFF.@/
The return value is a "function that takes one argument", so you can write #33FF33(lambda (n) ...)#FFFFFF for the #33FF33 expression#FFFFFF part.@/
All you have to do is complete the #33FF33...#FFFFFF part"\
goto *ex08

*ex08_2_hint
textclear
Arisa: "You simply write the expression #33FF33(function argument)#FFFFFF,/
but for this #33FF33 function#FFFFFF, you can write #33FF33(f 6)#FFFFFF"\
  goto *ex08_2

*ex08_end
  mov %adv_rmode, 1        ;右クリック有効
  gosub *pop  ;new env<S()
  saveon
  mov %save_flag, 1  ;セーブ可能
  textclear
  add %adv_miss, %adv_tmp
  bgm ms_setsume
  if %adv_tmp == 0 goto *s_08_2
  if %adv_tmp >=2   goto *s_08_3
*s_08_1
Arisa: "Not bad"\
goto *s_08_4
*s_08_2
r_show ari_hrt
Arisa: "No problems at all"\
goto *s_08_4
*s_08_3
r_show ari_ase
Arisa: "There are quite a few mistakes"\
  goto *s_08_4
*s_08_4

r_show ari_n
Arisa: "Today's topic is the continuation of side effects and functions."\
  r_show suzur_n
Suzuka: "The concept of a function returning another function was new."\
  r_show ari_n
Arisa: "All values are treated equally. @/
That's why if you can use numbers as return values for functions, you can also use symbols and functions. @/
In the same way, if you can send numbers as arguments, you can also send symbols and functions. @/
We often used numbers in explanations, but there is absolutely nothing special about numbers."\
  r_show suzur_qes
Suzuka: "However, since functions remember the environment where lambda is evaluated, /
it's a bit mysterious how they can retain the newly created environment. @/
How exactly do they distinguish what to keep and what to discard?"\
  r_show ari_n
Arisa: "In Lisp, only things that can never be used again are discarded. @/
Conversely, anything that might be used later is retained, which is why it works well. @/
Earlier, I mentioned 'values can be thought of as being in boxes,' but these boxes have a finite number. @/
However, if there is a box with an unnecessary value, that value is discarded and the box is reused, so running out of boxes is a rare occurrence."\
  r_show suzur_n
Suzuka: "Reusing sounds environmentally friendly."\
  r_show ari_ase
Arisa: "Well, if you say it's environmentally friendly, it is... @/
  r_show ari_n
This mechanism of distinguishing necessary from unnecessary things and reusing boxes is called GC (Garbage Collection). @/
  r_show ari_tun
Some language with a coffee-like name boasted about having GC, /
but Lisp has been using GC for far longer!"\

vsp SP_R, 0
  bg black, E_NORMAL
  r_load ari_n
  l_load ":l;img/same.bmp" ;;;
  bgm ms_after
  bg "img/blackboard.bmp", E_NORMAL
  talk_mode
Samejima: "Hmmmm!!!"\
r_show ari_qes
Arisa: "Samejima? What's wrong?"\
Samejima: "No, nothing. Miss Arisa, I'm sorry for the sudden notice, but I'll be out for a while."\
Arisa: "No problem, but... is there something urgent?"\
Samejima: "That's about it."\
mov %adv_noroi_off, 1;;;
csp SP_R : csp SP_L
bg black, E_NORMAL
l_show ":l;img\same.bmp"
Samejima: "This presence... it's getting closer... I sense something unusual!"\
Samejima: "I must protect you two even if it costs me my life!!!"\

;;;;;第8話終了;;;;;
  speak_mode
  textclear
  vsp SP_R, 0
  vsp SP_L, 0
  bg black, E_SLOW
;;共通記録の書き換え
  csvopen "arisa.szk", "rc"
  csvread %adv_clear
  csvclose
  if %adv_clear >= 8 goto *story08_after
  mov %adv_clear, 8
  csvopen "arisa.szk", "wc"
  csvwrite %adv_clear
  csvclose
#FFFF33Additional Explanation#FFFFFF has been added.
#FFFF33Glossary#FFFFFF has words added.\
*story08_after
  r_show suzur_nc
Suzuka: "What should I do?"
csel "Read Additional Explanation", *story08_condicil, "Read Glossary", *story08_glossary, "Return to Title", *title_back, "Proceed to Episode 9", *story09

*story08_condicil
  gosub *condicil
  goto *story08_after
*story08_glossary
  gosub *glossary
  goto *story08_after

;;;;;第9話;;;;;
*story09
  mov %adv_noroi_off, 0
  csp SP_R : csp SP_L : print E_FAST
  stop
  talk_mode
  bgm ms_kyoto
  bg "img/blackboard.bmp", E_FAST
  r_in ari_n
  l_in suzu_n
  r_show ari_qes
Arisa: "Samejima just ran out with a lot of energy." \
l_show suzu_nc
Suzuka: "Maybe pursuers were coming this way and he went off to fight alone..." \
r_show ari_tun
Arisa: "No way. There's no way Samejima would do something so cool." \
l_show suzu_n
Suzuka: "That's true." \

csp SP_R : csp SP_L : print 1
  bg "img/title#09.bmp", E_VFAST
  wait 1000
  delay 2000
  bgm ms_setsume
  bg "img/blackboard.bmp", E_FAST

speak_mode
  r_show ari_n
Alisa: "By using quote, you can create as many symbols as you want.@/
Symbols made from the same sequence of characters are the same thing.
#33FF33/
(define x 'a)
(define y 'a)#FFFFFF
When you evaluate these two expressions, the values of x and y become #FFFF33exactly the same#FFFFFF"\
  r_show suzur_qes
Suzuka: "Indeed, when you evaluate x and y, they both become #33FF33a#FFFFFF, so they're the same, right?@/
Is this something special?"\
  r_show ari_n
Alisa: "At the moment when the first expression is #FFFF33read#FFFFFF, a value of 'type is symbol, and the content is the sequence of 'a is created and put into a box.@/
From then on, even if you evaluate #33FF33'a#FFFFFF, or if #33FF33a#FFFFFF appears in another expression, the content of the box created first is used, and no new value is created.@/
  show_dgm ":l;img/dgm0901.bmp"
In other words, in the first example, both x and y are reusing the same value"\
  csp SP_DGM0
  r_show suzur_n
Suzuka: "Once a symbol is created, it's reused. It's environmentally friendly"\
  r_show ari_ase
Alisa: "That's enough about that......@/
  r_show ari_n
Symbols with the same content are all identical, so you can tell by looking at the display if they are the same or not"\
  r_show suzur_nc
Suzuka: "Symbols are the same if their contents are the same.@/
In other words, if the display is the same, they're the same thing"\
  r_show ari_n
Alisa: "On the other hand, this doesn't work with cons.
#33FF33/
(define z (cons 'a 'b))
(define w (cons 'a 'b))#FFFFFF
When you #FFFF33display#FFFFFF the values of z and w, they both become #33FF33(a . b)#FFFFFF.@/
As I said before, symbols a and b are reused.@/
  show_dgm ":l;img/dgm0902.bmp"
But the cons holding them is different"\
  r_show suzur_qes
Suzuka: "So, does that mean z and w have different values?"\
  r_show ari_n
Alisa: "The cons function first creates a value of 'type is cons, and both the CAR and CDR parts are empty.@/
Then it puts the first argument into the CAR part and the second argument into the CDR part of the cons.@/
In other words, even if the contents are the same, cons are never reused and a new one is always used"\
  csp SP_DGM0
  r_show suzur_nc
Suzuka: "Even though both the CAR and CDR are the same, there exist two separate values.@/
It's kind of like having people with the same first and last name.@/
By the way,
#33FF33
(define z '(a . b))
(define w '(a . b))#FFFFFF
What about in this case?@/
Will this also result in different cons being used?"\
  r_show ari_n
Alisa: "That's no good either. In that case, it's possible that the same cons is assigned to z and w, or different cons are assigned.@/
Since the result is not guaranteed, it's not good to think of them as the same entity.@/
However,
#33FF33
(define p '(a . b))
(define q p)#FFFFFF
In this case, p and q will be the same cons.@/
  show_dgm ":l;img/dgm0903.bmp"
q is bound to the value of p?namely, the cons made?so it's only natural that the same cons is used"\
  csp SP_DGM0
  r_show suzur_qes
Suzuka: "I get that there are values that are #FFFF33completely identical#FFFFFF, @/
but there are also values where even if the contents are the same, they're different.#FFFF33 Even though the display is the same, one is completely identical while another is different#FFFFFF, why is that? Is there something to be cautious about?"\
  r_show ari_n
Alisa: "First point: Whether values are identical is determined by a function called #33FF33eq?#FFFFFF.@/
If they are identical, you get #t, and if they are not, you get #f.@/
However, this function can't be used for cons or lists because you can't tell just by looking at them; you need to see their contents. Instead, you use a function called #33FF33equal?#FFFFFF.@/
eq? compares without looking at the contents, so it's very fast, but equal? takes some time as it checks the contents sequentially for cons"\
  r_show suzur_n
Suzuka: "Can't you use equal? to compare symbols?"\
  r_show ari_n
Alisa: "You can. If something is true with eq?, it will also be true with equal?.@/
On the other hand, just because something is true with equal?, it won't necessarily be true with eq?.
#33FF33/
(eq? 'a 'a)                ⇒ #t
(equal? 'a 'a)             ⇒ #t
(eq? '(a) '(a))            ⇒ #f
(equal? '(a) '(a))         ⇒ #t#FFFFFF
For symbols, both eq? and equal? give the same result.@/
Basically, if they #FFFF33look the same#FFFFFF, then comparing with equal? results in true.@/
Except for functions, though"\
  r_show suzur_excc
Suzuka: "So, you can compare symbols using eq? very quickly, but for cons or lists, you need to use equal?, which isn't as fast"\
  r_show ari_n
Alisa: "Another point is that using identical elements results in different actions when performing destructive operations on lists.
#33FF33/
(define x (cons 'a 'b))
(set-car! x 'c)
(set-cdr! x 'd)#FFFFFF
Evaluating these expressions in order would make the value of x
#33FF33(c . d)#FFFFFF.@/
Just like with set!, you should not rely on the returned value of set-car! or set-cdr!"\
  r_show suzur_nc
Suzuka: "#33FF33set-car!#FFFFFF and #33FF33set-car!#FFFFFF, as their names suggest, are functions that rewrite the CAR and CDR parts of a cons.@/
It's not the returned value that's important, but the rewriting of the contents of the cons, so this is operations with side effects too"\
  r_show ari_n
Alisa: "Because it destructively rewrites the original contents of a cons, this is called a #FFFF33destructive operation#FFFFFF.@/
While it can be convenient, if you bring up what we talked about earlier, it becomes a bit troublesome......
#33FF33/
(define x (cons 'a 'b))
(define y (cons 'a 'b))
(define z y)
(set-car! x 'c)
(set-cdr! y 'd)#FFFFFF
Evaluating these expressions in sequence gives
x the value #33FF33(c . b)#FFFFFF,@
y the value #33FF33(a . d)#FFFFFF,@
and z the value #33FF33(a . d)#FFFFFF.@
  show_dgm ":l;img/dgm0904.bmp"
Even z, which wasn't directly rewritten, changes along with y's change, which is the point"\
  csp SP_DGM0
  r_show suzur_n
Suzuka: "y and z are bound to the same cons, so that kind of thing happens"\
  r_show ari_n
Alisa: "Well, with something this obvious, it's fine, but
#33FF33/
(define x
      (cons 8
            (cons 9
                  (cons 10 '()))))
(define y (cdr x))#FFFFFF
At this point, x is #33FF33(8 9 10)#FFFFFF,
and y is #33FF33(9 10)#FFFFFF.@/
Here,
#33FF33/
(set-car! y 19)#FFFFFF
If you evaluate this, y's value becomes #33FF33(19 10)#FFFFFF, but,@/
x's value is also rewritten to #33FF33(8 19 10)#FFFFFF.@/
  show_dgm ":l;img/dgm0905.bmp"
The cause is the same as before, but this one's a bit harder to notice"\
  csp SP_DGM0
  r_show suzur_T_T
Suzuka: "Since y shares a part of x, rewriting y rewrites x too.@/
This is scary because if you're not careful, you could easily end up rewriting a variable you didn't mean to"\
  r_show ari_n
Alisa: "To avoid such situations, one of the simplest ways is not to use destructive operations on lists.@/
But there are situations where you want to use them, so in those cases, be sure to carefully consider whether lists are shared or not"\
  r_show ari_n
Alisa: "Now, for a practice problem, but it's not exactly ideal to immediately practice something I said 'shouldn't be used'.@/
  r_show ari_tun
So I'll give you a different problem!@ It's definitely not because creating a problem was a hassle!!"\
  r_show suzur_dere
Suzuka: "Alisa, you don't need to be so desperate"\
  r_show ari_n
Alisa: "So, before the practice problem, I'll give you a hint.@/
Previously, we made a function to find the factorial, but this time we'll make it a bit differently
#33FF33/
(define (fact2 n)
  (fact2i n 1))
(define (fact2i n x)
  (if (= n 0)
        x
        (fact2i (- n 1)
                (* x n))))#FFFFFF
When finding the factorial of 3, you use it like #33FF33(fact2 3)#FFFFFF"\
  r_show suzur_nc
Suzuka: "Now there are two functions.@/
Though it seems like fact2 just calls fact2i.@/
fact2i is recursive, but #33FF33n#FFFFFF keeps getting smaller, eventually reaching 0, so the calls will end at some point, just like before"\
  r_show ari_n
Alisa: "The focus should be on #33FF33x#FFFFFF.@/
Suppose you evaluate #33FF33(fact2 3)#FFFFFF.@/
When fact2i is called initially, x is 1 and n is 3.@/
Next, when fact2i is called, x is 1×3 and n is 2,@/
and when x becomes 1×3×2×1, n is 0, so the result of fact2i is 6.@/
See, it's a little complicated, but it calculates the factorial properly"\
  r_show suzur_n
Suzuka: "It's like x holds the number in the middle of the calculation.@/
Since x starts at 1, even when calculating the factorial of 0, you correctly get the result of 1"\
  r_show ari_n
Alisa: "If you don't quite understand it, carefully go over the factorial function from earlier.@/
Got it? You should thoroughly review it now, it's an enormous hint for the practice problem!"\

gosub *ex_init
*ex09_prev
  ;;定義済み関数
  mov $sarg0, "(define (s n) (si n 0))"
  gosub *input_to_lobject
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *eval_form
  mov $sarg0, "s"
  gosub *create_symbol
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *find_var
  mov %arg0, %ret
  gosub *cdr
  mov %arg0, %ret
  gosub *push     ;S(s)
  ;;
*ex09
  mov $problem_label, "*ex09_problem"
  mov $tab_label, "*ex09_tab"
  mov $ret_label, "*ex09"
  mov $suc_label, "*ex09_check"
  goto *ex_rep
*ex09_problem
!s0Arisa: "Define the function si so that evaluating #33FF33(s n) #FFFFFF returns 1 + 2 + ... + n./
ただし、ｓは次のように定義されているわ
#33FF33/
（ｄｅｆｉｎｅ　（ｓ　ｎ）
　（ｓｉ　ｎ　０））#FFFFFF"!sd
  return
*ex09_check
  gosub *pop : gosub *pop
  ;;;検証1
  mov $sarg0, "(s 0)"
  gosub *input_to_lobject
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *eval_form
  mov %arg0, %ret
  gosub *get_data
  mov $sarg0, "*ex09_miss"
  if %ret != 0 goto *ex_check_fail
  ;;;検証2
  mov $sarg0, "(s 6)"
  gosub *input_to_lobject
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *eval_form
  mov %arg0, %ret
  gosub *get_data
  mov $sarg0, "*ex09_2_prev"
  if %ret == 21 gosub *pop : goto *ex_check_pass  ;s<S()
  mov $sarg0, "*ex09_miss"
  goto *ex_check_fail
*ex09_miss
;;;sの再定義をcheck;;;
  mov $sarg0, "s"
  gosub *create_symbol
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *find_var
  mov %arg0, %ret
  gosub *cdr
  mov %arg0, %ret
  gosub *pop      ;s<S()
  if %arg0 != %ret goto *ex09_miss2
  mov %arg0, %ret
  gosub *push     ;S(s)
  ;;;END
  textclear
  r_show ari_die
Arisa: "No, let's start again!"\
r_show ari_n
inc %adv_tmp
goto *ex09
*ex09_miss2
r_show ari_muka
Arisa: "...That's a pretty interesting thing to do. @/
r_show ari_do
Let's start again from the beginning!!!"\
  r_show ari_n
  inc %adv_tmp
  gosub *pop      ;toplevel_env<S()
  gosub *ex_init_env : goto *ex09_prev

*ex09_2_prev
  mov $sarg0, "si"
  gosub *create_symbol
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *find_var
  mov %arg0, %ret
  gosub *cdr
  mov %arg0, %ret
  gosub *push     ;S(si)
*ex09_2
  mov $problem_label, "*ex09_2_problem"
  mov $tab_label, "*ex09_2_tab"
  mov $ret_label, "*ex09_2"
  mov $suc_label, "*ex09_2_check"
  goto *ex_rep
*ex09_2_problem
!s0Arisa: "Call #FFFF33s#FFFFFF with arguments #33FF3310#FFFFFF"!sd
  return
*ex09_2_check
  gosub *pop      ;ret<S(input, si)
  mov %arg0, %ret
  gosub *pop      ;input<S(si)
  gosub *get_data
  mov $sarg0, "*ex09_end"
  if %ret == 55 gosub *pop : goto *ex_check_pass_end
  mov $sarg0, "*ex09_2_normal_miss"
  goto *ex_check_fail
*ex09_2_normal_miss
;;;siの再定義をcheck;;;
  mov $sarg0, "si"
  gosub *create_symbol
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *find_var
  mov %arg0, %ret
  gosub *cdr
  mov %arg0, %ret
  gosub *pop      ;si<S()
  if %arg0 != %ret goto *ex09_2_miss
  mov %arg0, %ret
  gosub *push     ;S(si)
;;;end;;;
  textclear
  r_show ari_die
Arisa: "No, try again!"
  r_show ari_n
  inc %adv_tmp
  goto *ex09_2

*ex09_2_miss
  textclear
  r_show ari_muka
Arisa: "……You're doing something quite interesting. @/
  r_show ari_do
Start over from the beginning!!!"\
  r_show ari_n
  inc %adv_tmp
  gosub *pop      ;toplevel_env<S()
  gosub *ex_init_env : goto *ex09_prev

*ex09_tab
csel "Continue", *ex09, "Hint", *ex09_hint,  "Return to Title", *ex09_bye
*ex09_2_tab
csel "Continue", *ex09_2, "Hint", *ex09_2_hint,  "Return to Title", *ex09_2_bye

*ex09_bye
  mov %adv_rmode, 1        ;Right-click enabled
  textclear
  csp SP_R
  stop
  sub %sp, 2      ;new env, s(si) <S()
  goto *title

*ex09_2_bye
  goto *ex09_bye

*ex09_hint
  textclear
Arisa: "Since it takes two arguments, you can write it as #33FF33(lambda (n x) expression)#FFFFFF.@/
Needless to say, you will be writing a recursive expression.@/
Naturally, you should subtract 1 from n each time.@/
Also, decide in advance that if n is 0, it will return x.@/
Then, the whole thing can be written as
#33FF33/
(define si
(lambda (n x)
(if (= n 0)
x
(si (- n 1) ?))))#FFFFFF
.@/
#33FF33? Try your best to think about what to put in the #FFFFFF part. @/
The important thing is that x contains the result of the calculation up to that point. @/
Also, don't forget that x is 0 at first. @/
Think about the cases where n is 0, 1, and 2, and if it works correctly in all three cases, it's probably correct. @/
...Well, actually, it's enough to think about the cases 0 and n+1 and find that it's correct. @/
If you still can't figure it out, somehow look at the factorial example I mentioned a little before this problem"\
goto *ex09

;;;3/13;;;
;Yunoha
;: "I'm relying on the kindness of others to feed me,
; but I know I shouldn't eat this much...
; Yunoha will have to endure the small meal from tomorrow..."
; Yunoha wiped the tears from her eyes with her small hands,
; as if she was forcing herself,
; she gave a painful smile.
; Instead of this hint, the explanation of factorials in the main text should be more detailed.

*ex09_2_hint
textclear
Arisa: "Just write the formula #33FF33 (function argument) #FFFFFF"\
  goto *ex09_2

*ex09_end
  mov %adv_rmode, 1        ;右クリック有効
  gosub *pop  ;new env<S()
  saveon
  mov %save_flag, 1  ;セーブ可能
  textclear
  add %adv_miss, %adv_tmp
  bgm ms_setsume
  if %adv_tmp == 0 goto *s_09_2
  if %adv_tmp >=4   goto *s_09_3
*s_09_1
Arisa: "Not bad"\
goto *s_09_4
*s_09_2
r_show ari_hrt
Arisa: "No problems at all"\
goto *s_09_4
*s_09_3
r_show ari_ase
Arisa: "There are quite a few mistakes"\
  goto *s_09_4
*s_09_4

r_show suzur_qes
Suzuka: "I wrote the problem I did before in a different way, but is there any point?"\
r_show ari_n
Arisa: "Okay, let's write the recursive function again.
#33FF33/
(define (fact2i n x)
(if (= n 0)
x
(fact2i (- n 1)
(* x n))))#FFFFFF
The important thing to note here is the end of the function. @/
It just calls fact2i, right?"\
r_show suzur_n
Suzuka: "Indeed, nothing is done after the call. @/
The recursive function I wrote before
#33FF33(* n (fact (- n 1)))#FFFFFF
like this, where multiplication is done after the call."\
r_show ari_n
Arisa: "Normally, when you do recursion, new environments are created one after another, but if you make a recursive call at the end of a function and then do nothing after that, there's no need to save the environment. @/
So in that case, the process is automatically optimized. @/
For example, in the case of fact2i, instead of "calling fact2i", @/
it rewrites the bindings of n and x and evaluates the contents of the function again. @/
The result is the same as when you call a function normally, but since you don't create an environment unnecessarily, it's faster and doesn't take up space. @/
r_show ari_hrt
This should give peace of mind to anyone who was worried about "Is it okay to do loops with recursion?" \
r_show suzur_nc
Suzuka: "When you say 'make a recursive call at the end of a function', it doesn't become a function call, it rewrites the arguments and repeats the evaluation of the contents of the function again." \
r_show ari_n
Arisa: "Recursive calls at the end of a function are called #FFFF33tail recursion#FFFFFF, and making this into a simple repetition is called #FFFF33tail recursion optimization#FFFFFF.@/
Many Lisp programs have tail recursion optimization.@/
So Lisp doesn't need special syntax for repetition.@/
r_show ari_ase
...Well, even if you don't need it, they have it.@/
r_show ari_n
Also, in Scheme, even if it's not recursive, the same optimization is done when calling another function at the end of a function, and it's called/
#FFFF33tail call optimization#FFFFFF or/
#FFFF33true tail recursion optimization#FFFFFF.@/
However, I'll leave this out here."\
r_show suzur_n
Suzuka: "I see that I can write recursion with confidence. @/
But Arisa-chan. @/
r_show suzur_qes
Wasn't this a list? "\
r_show ari_do
Arisa: "Shut up shut up shut up!!"\

stop;;;bgm;;;
  vsp SP_R, 0
  bg black, E_NORMAL
;;  bg "img/blackboard.bmp", E_NORMAL
mov %adv_noroi_off, 1
  bg black, E_NORMAL
  talk_mode
Osaka, some place   PM  23:15\
  l_show ":l;img/jiku2.bmp"
Agent: "Haa... Why do I have to do the troublesome task of searching for a criminal..."\
Agent: "The information on the hiding place is vague, as always they are doing a sloppy job..."\
Agent: "Even though I'm dealing with an old man, I was given a powerful device, but I don't need something this powerful."\
  r_in ":l;img/same.bmp"
Samejima: "... Then shall we try it?"\
Agent: "Ah! You're the!! That #FFFF33 magic old man #FFFFFF!"\
Samejima: "... (Kill)"\
  stop
  csp SP_R : csp SP_L
  bg black, E_WIPE2
  bgm ms_battle2
  gosub *battle09
  if %ret == 0 goto *battle09_after
  ;;Defeat
  textclear
  stop
  goto *title
*battle09_after
  bgm ms_ab2
  l_load ":l;img/jiku2.bmp"
  r_load ":l;img/same.bmp"
  print E_FAST
Samejima: "Retreat! If you retreat, I won't take your life!"\
Agent: "Hii, hiiii---!"\
  l_out
Samejima: "For now, have I managed to escape this situation..."\
Samejima: "However, it's only a matter of time before my current hideout is discovered..."\
Samejima: "Now then, what to do..."\

;;;;;第9話終了;;;;;
  speak_mode
  textclear
  vsp SP_R, 0
  vsp SP_L, 0
  bg black, E_SLOW
;;共通記録の書き換え
  csvopen "arisa.szk", "rc"
  csvread %adv_clear
  csvclose
  if %adv_clear >= 9 goto *story09_after
  mov %adv_clear, 9
  csvopen "arisa.szk", "wc"
  csvwrite %adv_clear
  csvclose
#FFFF33Supplementary explanation#FFFFFF has been added.
#FFFF33Glossary#FFFFFF has been updated with new terms.\
*story09_after
  r_show suzur_nc
Suzuka: "What should I do?"
csel "Read supplementary explanation", *story09_condicil, "Read glossary", *story09_glossary, "Return to title", *title_back, "Proceed to episode 10", *story10

*story09_condicil
  gosub *condicil
  goto *story09_after
*story09_glossary
  gosub *glossary
  goto *story09_after

;;;;;第10話;;;;;
*story10
  mov %adv_noroi_off, 0
  csp SP_R : csp SP_L : print E_FAST
  stop
  talk_mode
  bgm ms_kyoto
  bg "img/blackboard.bmp", E_FAST
  r_in ari_n
  l_in suzu_n
Suzuka "It’s also good to install a new magic program into the device, but what do you think about enhancing the device itself?"\
  r_show ari_qes
Arisa "Do you have any leads?"\
  l_show suzu_hrt
Suzuka "Actually, the instruction manual includes a bit about how to modify the device, so I was thinking of trying it out."\
  r_show ari_ase
Arisa "Can a device be modified that easily?"\

csp SP_R : csp SP_L : print 1
  bg "img/title#10.bmp", E_VFAST
  wait 1000
  delay 2000
  bgm ms_setsume
  bg "img/blackboard.bmp", E_FAST

speak_mode
  r_show ari_n
Arisa: "Putting that aside, let's write the recursive function we did last time.@
#33FF33/
(define (cont? x l)
  (cond
    ((null? l) #f)
    ((eq? x (car l)) #t)
    (else
      (cont? x (cdr l)))))#FFFFFF
This function cont?, as defined, takes a symbol and a list, /
and returns #t if the symbol is contained as an element of the list, or #f if it is not.@
#33FF33/
(cont? 'b '(a b c)) ⇒ #t
(cont? 'd '(a b c)) ⇒ #f#FFFFFF
As a result, it evaluates like this."\
  r_show suzur_nc
Suzuka: "If the received list is an empty list, it cannot possibly contain the symbol, so #f. @/
If not, it compares the first element of the list with the received symbol, if they are the same, #t. @/
Otherwise, it recurses with the list’s CDR ? the list with the first element removed and the symbol as arguments."\
  r_show ari_n
Arisa: "Since it recurses at the end of the function, this does not become a function call but, instead, @/
rewrites the binding of l and evaluates again.@
#33FF33(cont? 'b '(a b c))#FFFFFF
When you evaluate this, initially, the value of #33FF33l#FFFFFF is #33FF33(a b c)#FFFFFF, @/
and you evaluate the else part in cond, rewriting the value of #33FF33l#FFFFFF to #33FF33(b c)#FFFFFF, @/
and then once more, the contents of the function are evaluated, and it evaluates to true in the part of cond's #33FF33(eq? x (car l))#FFFFFF,/
resulting in #33FF33#t#FFFFFF."\
  r_show suzur_n
Suzuka: "When recursing, if you send the CDR of the list, it’s like the function that returns the length of the list, isn’t it?"\
  r_show ari_n
Arisa: "Rewriting that into this format would be,
#33FF33/
(define (len l)
  (leni l 0))
(define (leni l n)
  (if (null? l)
      n
      (leni (cdr l)
            (+ n 1))))#FFFFFF
You can write it like this."\
  r_show suzur_excc
Suzuka: "By carrying along the intermediate state as an argument, you’re managing it well."\
  r_show ari_n
Arisa: "For now, let’s leave the talk about tail recursion at this."\
  r_show suzur_n
Suzuka: "When writing recursion, it’s better to write it in this form as much as possible, right?"\
  r_show ari_n
Arisa: "Changing the subject, until now, a function would accept at least one argument. /
However, there are functions that do not accept any arguments.
#33FF33/
(define f
  (lambda ()
    57))#FFFFFF
This function f takes no arguments and always returns 57. @/
When calling it, you write it as #33FF33(f)#FFFFFF."\
  r_show suzur_nc
Suzuka: "Thinking the same way, when using the syntactic sugar of define, @/
#33FF33/
(define (f)
  57)#FFFFFF
it should be like this, right?"\
  r_show ari_n
Arisa: "Well, in Lisp, there is a function called #33FF33eval#FFFFFF.@/
This function takes an expression and returns the result of evaluating it.
#33FF33/
(eval '9)             ⇒ 9
(eval '(+ 1 2))       ⇒ 3#FFFFFF
As you can see, when you pass a list, it evaluates it as an expression."\
  r_show suzur_n
Suzuka: "A list that is a value is treated as an expression by the eval function, isn’t it?"\
  r_show ari_n
Arisa: "Moreover, there’s a function called #33FF33read#FFFFFF,@/
when you call it, it enters an input waiting state and takes the input as a list.@/
When using it, it’s invoked without arguments like #33FF33(read)#FFFFFF."\
  r_show suzur_n
Suzuka: "The read function accepts input and returns it as a list, symbol, or number, right?"\
  r_show ari_n
Arisa: "Combining read and eval,
#33FF33/
(eval (read))#FFFFFF
if you write it like this, it accepts the input once and evaluates it.@
  r_show ari_exc
Then, you can do the same operation that interpreters normally do."\
  r_show suzur_T_T
Suzuka: "That's amazing. But interpreters do three things: 'read', 'evaluate', and 'display', right?@/
This alone seems to lack the 'display' part."\
  r_show ari_n
Arisa: "To display a value on the screen, use the #33FF33write#FFFFFF function.@/
This displays the first argument directly on the screen, so
#33FF33/
(write (eval (read)))#FFFFFF
With this, you read the expression, evaluate it, and then display it."\
  r_show suzur_qes
Suzuka: "That's quite something. But, this only does the interpreter's sequence of operations once, right?@/
Can't it be repeated or anything?"\
  r_show ari_n
Arisa: "You can manage it by using function recursion.
#33FF33
(define (repl)
  (write (eval (read)))
  (repl))#FFFFFF
If you invoke repl like this, it continually repeats the sequence of operations."\
  r_show suzur_nc
Suzuka: "The repl function has two statements so it evaluates them in order. @/
First, it takes input, evaluates it, and then displays it, @/
Next, it recurses, but since it’s at the end of the function, it simply repeats the content of the function for evaluation."\
  r_show ari_n
Arisa: "Finally, let’s make it so that when an input #33FF33exit#FFFFFF comes, it terminates.
#33FF33
(define (repl)
  (let ((i (read)))
    (cond
      ((eq? i 'exit) #t)
      (else
       (write (eval i))
       (repl)))))#FFFFFF
A local variable i is now bound to the input expression, and it uses the value of i. @/
This means the sequence of operations continues until an exit input is received."\
  r_show suzur_n
Suzuka: "If you apply this, it seems like you could do quite a lot, doesn't it?"\
  r_show ari_n
Arisa: "Well, with that, there won’t be any practice problems this time.@/
You can type freely for the first time in a while.@/
However, if you are making a REPL, there is a risk of defining a function that may never end, so,@/
It would be better to save now."\

gosub *ex_init
*ex10
  mov $problem_label, "*ex10_problem"
  mov $tab_label, "*ex10_end"
  mov $ret_label, "*ex10"
  mov $suc_label, "*ex10_check"
  goto *ex_rep
*ex10_problem
!s0Arisa "Press the Tab key to finish when you're satisfied."!sd
  return
*ex10_check
  gosub *pop : gosub *pop
  inc %adv_tmp
  goto *ex10

*ex10_end
  mov %adv_rmode, 1        ;右クリック有効
  gosub *pop
  saveon
  mov %save_flag, 1  ;セーブ可能
  textclear
  bgm ms_setsume
  if %adv_tmp == 1 goto *s_10_2
  if %adv_tmp == 0 goto *s_10_1
Arisa: "Well, that's about it."

goto *s_10_3
*s_10_1
r_show ":l;img/arin.bmp"
Arisa: "Arin."

Arisa: "What do you mean, you never tried it..."

goto *s_10_3
*s_10_2
Arisa: "Is one try enough? Well, it's fine..."
  goto *s_10_3
*s_10_3

r_show ari_n
Arisa: "Changing the topic again, but the function to create cons.@/
If the second argument is a list, it can be considered a function that returns a list with an additional element at the head of the original list. 
#33FF33/
(cons 'a '(b c)) ⇒ (a b c) #FFFFFF
You can understand why this happens by drawing a diagram of the list structure."\
;; Display diagram?
  r_show suzur_excc
Suzuka: "I see, that makes sense."\
  r_show ari_n
Arisa: "Now, using this, let's try creating a function that reverses the order of elements in a list."\
  r_show suzur_n
Suzuka: "A function that, if you receive #33FF33(a b c)#FFFFFF, returns #33FF33(c b a)#FFFFFF."\
  r_show ari_n
Arisa: "Let's consider writing it in a tail-recursive form. In that case, the overall structure would be,
#33FF33/
(define (rev l)
  (revi l A))
(define (revi l x)
  B) #FFFFFF
From here, you only need to think about A and B.@/
First, if the received list is an empty list, the return value will also be an empty list.@/
If not, when looking at the list sent as an argument, usually, you start from the first element.@/
Therefore, you'll be recurring while taking the CDR of l.@/
If revi is supposed to return x at the end, what do you think should be written in place of A?"\
  r_show suzur_nc
Suzuka: "Um, revi recurs as long as l has elements, but @/
if l is an empty list, it will return x.@
Thinking from the case where l is an empty list from the beginning, the part of A is an empty list #33FF33'()#FFFFFF."\
  r_show ari_n
Arisa: "Exactly. That makes this function,
#33FF33/
(define (rev l)
  (revi l '()))
(define (revi l x)
  (if
    (null? l)
    x
    (revi (cdr l) C))) #FFFFFF
Now, we need to think about the part of C.@/
Here, you use cons, which I mentioned earlier."\
  r_show suzur_dotc
Suzuka: "Let's think about an actual call like #33FF33(rev '(a b c))#FFFFFF.@/
Since you look at the elements from the start of the list, by the time you see #33FF33a#FFFFFF, make x #33FF33(a)#FFFFFF, and @/
when you see #33FF33b#FFFFFF, make x #33FF33(b a)#FFFFFF, and @/
when you see #33FF33c#FFFFFF, make x #33FF33(c b a)#FFFFFF and recur, and it should work fine.@/
This means you're effectively adding the head element of l to the original x, so you can use cons. @/
  r_show suzur_n
Therefore, you should make #33FF33(cons (car l) x)#FFFFFF the new x and recur."\
  r_show ari_n
Arisa: "That's right. So ultimately,
#33FF33/
(define (rev l)
  (revi l '()))
(define (revi l x)
  (if
    (null? l)
    x
    (revi
      (cdr l)
      (cons (car l) x)))) #FFFFFF
Writing it this way completes the function.@/
Functions using tail recursion might be hard to write initially, but if you think about it step by step like this, it's surprisingly easy."\
  r_show suzur_n
Suzuka: "It feels like we talked about several independent topics this time."\
  r_show ari_n
Arisa: "It means that by incorporating a little new into what we've covered so far, you can write quite a lot.@/
However, non-tail recursion is also important, so you need to practice that one, too.@/
If you have extra time, writing a function that takes#33FF33(a b)#FFFFFF and #33FF33(c d)#FFFFFF and returns #33FF33(a b c d)#FFFFFF might be a good exercise."\

vsp SP_R, 0
  bg black, E_NORMAL
  r_load ari_ase
  l_load suzu_hrt
  bgm ms_after
  bg "img/blackboard.bmp", E_NORMAL
  talk_mode
Suzuka: "As expected, ○tsu parts are very useful"

Arisa: "I can't believe that device parts are sold on Teramachi Street..."

Suzuka: "I'm glad that I was able to strengthen it properly by following the instructions"

Arisa: "And what's more, what a helpful instruction manual..."

Suzuka: "With this, your attack power should increase by 120% at the very least, and your one-hit kill skill should increase by 63%"

Arisa: "Suzuka, there are very few people who can look at those numbers and understand the source of the information"
Suzuka: "As expected, the parts are convenient."
Arisa: "Who would have thought that device parts would be sold on Teramachi Street..."
Suzuka: "I'm glad it worked as strengthened when I did it according to the manual."
Arisa: "And what a helpful manual it is..."
Suzuka: "With this, at the very least, attack power will increase by 120%, and the skill for a one-hit kill should improve by 63%."
Arisa: "Suzuka, hardly anyone will get the reference from those numbers."

;;;;;第10話終了;;;;;
  speak_mode
  textclear
  vsp SP_R, 0
  vsp SP_L, 0
  bg black, E_SLOW
;;共通記録の書き換え
  csvopen "arisa.szk", "rc"
  csvread %adv_clear
  csvclose
  if %adv_clear >= 10 goto *story10_after
  mov %adv_clear, 10
  csvopen "arisa.szk", "wc"
  csvwrite %adv_clear
  csvclose
#FFFF33Supplementary explanation #FFFFFF has been added.
#FFFF33Glossary #FFFFFF has been added with a word.\
*story10_after
  r_show suzur_nc
Suzuka: "What should I do?"
csel "Read the supplementary explanation", *story10_condicil, "Read the glossary", *story10_glossary, "Return to title", *title_back, "Proceed to Episode 11", *story11

*story10_condicil
  gosub *condicil
  goto *story10_after
*story10_glossary
  gosub *glossary
  goto *story10_after

;;;;;第11話;;;;;
*story11
  mov %adv_noroi_off, 0
  csp SP_R : csp SP_L : print E_FAST
  stop
  talk_mode
  bgm ms_kyoto
  bg "img/blackboard.bmp", E_FAST
  r_in ari_n
  l_in suzu_n
  l_show suzu_nc
Suzuka: "Even so, I wonder how long we'll be in Kyoto."\
r_show ari_tun
Arisa: "I thought we'd wait until things calmed down, but Samejima told me it's still not a good time to move."\
l_show suzu_dotc
Suzuka: "That's a problem..."\
Arisa: "Maybe I should contact Nanoha now."\
l_show suzu_n
Suzuka: "We need to wait until things calm down a bit, otherwise it'll be a bother."\
r_show ari_ase
Arisa: "I was fine with getting the device, but I think it was a mistake to kill one of the station staff. I'm a bit regretful."\

csp SP_R : csp SP_L : print 1
  bg "img/title#11.bmp", E_VFAST
  wait 1000
  delay 2000
  bgm ms_setsume
  bg "img/blackboard.bmp", E_FAST

speak_mode
  r_show ari_n
Arisa: "Previously, we talked about 'functions that return functions.'"\
  r_show suzur_nc
Suzuka: "I believe it was something like,
#33FF33/
(define (f n)
  (lambda (x)
    (+ x n)))#FFFFFF
like this, right?"\
  r_show ari_n
Arisa: "Now, let's try creating a function that takes a function as an argument.
#33FF33/
(define (c72 g)
  (g 72))#FFFFFF
The function c72 defined like this takes a function as its argument and calls it with 72. @/
Let's actually use it.
#33FF33
(c72
  (lambda (n) (+ n 1)))#FFFFFF
The value of this expression will be 73."\
  r_show suzur_excc
Suzuka: "Because in the new environment g is bound to the function created by evaluating the lambda expression,/
#33FF33(g 72)#FFFFFF is actually the same as #33FF33((lambda ...) 72)#FFFFFF, right?"\
  r_show ari_n
Arisa: "But just doing that isn't very interesting, so let's write something a bit more practical. @/
For example, let's consider a function that takes a list like #33FF33(2 5 9)#FFFFFF,/
and returns the sum of those numbers."\
  r_show suzur_nc
Suzuka: "In that case,
#33FF33/
(define (sum l)
  (sumi l 0))
(define (sumi l x)
  (if
    (null? l)
    x
    (sumi (cdr l)
          (+ x (car l)))))#FFFFFF
writing it like this works well."\
  r_show ari_n
Arisa: "Then next, how about a function similar to that, which takes a list and returns the product of all its elements?"\
  r_show suzur_nc
Suzuka: "That would be almost the same.
#33FF33/
(define (mul l)
  (muli l 1))
(define (muli l x)
  (if
    (null? l)
    x
    (muli (cdr l)
          (* x (car l)))))#FFFFFF
Compared to earlier, the initial value of x is 1, and '+' is changed to '*'."\
  r_show ari_n
Arisa: "It's almost the same, right? In such cases,
#33FF33/
(define (f g n l)
  (fi g l n))
(define (fi g l x)
  (if
    (null? l)
    x
    (fi g
        (cdr l)
        (g x (car l)))))#FFFFFF
would be good. @
For addition, you can write #33FF33(f + 0 '(2 5 9))#FFFFFF and for multiplication, you can write #33FF33(f * 1 '(2 5 9))#FFFFFF. @
This way you save the effort of writing similar functions twice."\
  r_show suzur_n
Suzuka: "By taking a function as an argument, you can handle similar functions with just one function, right?"\
  r_show ari_n
Arisa: "There is a typical function called map. @/
This function takes a 'function' and a 'list' and creates a list by applying the function to each element of the list.
#33FF33/
(map null? '(a () b))#FFFFFF
The result of this expression is #33FF33(#f #t #f)#FFFFFF. @/
#33FF33(null? a)#FFFFFF is #33FF33#f#FFFFFF,
#33FF33(null? ())#FFFFFF is #33FF33#t#FFFFFF,
#33FF33(null? b)#FFFFFF is #33FF33#f#FFFFFF.
These are put in a list as the result."\
  r_show suzur_nc
Suzuka: "So then,
#33FF33/
(map
  (lambda (n) (* n n))
  '(3 5 8))#FFFFFF
The value of this expression will be #33FF33(9 25 64)#FFFFFF."\
  r_show ari_n
Arisa: "When you attach a function that takes two arguments as the first argument of map, you should attach two lists.
#33FF33/
(map
  +
  '(1 3 5)
  '(2 4 6))#FFFFFF
The result of this expression will be #33FF33(3 7 11)#FFFFFF. @/
You see how one element from each of the two lists is being used, right?"\
  r_show suzur_qes
Suzuka: "So, map determines the number of lists it receives based on how many arguments the first function takes?"\
  r_show ari_n
Arisa: "That's right. But well,/
as for now, as long as you understand the form where map takes a function that takes one argument -- #33FF33(map function list)#FFFFFF --, that's fine."\
  r_show suzur_n
Suzuka: "If you know it's one list, you could write it using recursion while taking the CDR."\
  r_show ari_exc
Arisa: "Well then, shall we write it? @/
As a practice exercise."\
  r_show suzur_n
Suzuka: "!?"\
  r_show ari_n
Arisa: "Well, since it's harsh to start immediately, I'll give you a little hint. @/
First, let's make a function that takes a list and returns a list that's exactly the same.
#33FF33
(define (f l)
  (if
    (null? l)
    '()
    (cons
     (car l)
     (f (cdr l)))))#FFFFFF
Take each element out of the list one by one and connect them using cons."\
  r_show suzur_nc
Suzuka: "Take the CAR of the received list, and make a cons with that as the CAR part. @/
In the CDR part of that cons, you'd put the result of calling f with the CDR of the received list as an argument. @/
Indeed, the same list is created."\
  r_show ari_n
Arisa: "Next, let's think of a function that takes a list containing only numbers and returns a list with 1 added to each element.
#33FF33
(define (g l)
  (if
    (null? l)
    '()
    (cons
     (+ 1 (car l))
     (g (cdr l)))))#FFFFFF
This is a big hint, so take your time to look carefully."\
  r_show suzur_nc
Suzuka: "This function g creates a list with 1 added to each element of the list. @/
So,
#33FF33/
(g '(1 2 3))#FFFFFF
can be rewritten as
#33FF33/
(map
  (lambda (x) (+ 1 x))
  '(1 2 3))#FFFFFF
Considering that, the #33FF33(+ 1 (car l))#FFFFFF part of the definition of g corresponds to #33FF33(+ 1 x)#FFFFFF, @/
So by slightly modifying this part, it seems like we could define map that takes just one list."\
  r_show ari_n
Arisa: "Well then, let's try doing it."\

gosub *ex_init
*ex11
  mov $problem_label, "*ex11_problem"
  mov $tab_label, "*ex11_tab"
  mov $ret_label, "*ex11"
  mov $suc_label, "*ex11_check"
  goto *ex_rep
*ex11_problem
!s0Arisa: "Define the function map1 as a simple version of map that takes two arguments: 'a function that takes one argument' and 'a list'."!sd
  return
*ex11_check
  gosub *pop : gosub *pop
  ;;;検証1
  mov $sarg0, "(map1 (lambda (x) (* x 2)) '(19))"
  gosub *input_to_lobject
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *eval_form
  mov %arg0, %ret
  gosub *get_tag
  mov $sarg0, "*ex11_miss"
  if %ret != TAG_CONS goto *ex_check_fail
  gosub *car      ;CAR( '(38) ) ?
  mov %arg0, %ret
  gosub *get_data
  mov $sarg0, "*ex11_miss"
  if %ret != 38 goto *ex_check_fail
  ;;;検証2
  mov $sarg0, "(map1 number? '(1 a))"
  gosub *input_to_lobject
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *eval_form
  mov %arg0, %ret
  gosub *get_tag
  mov $sarg0, "*ex11_miss"
  if %ret != TAG_CONS goto *ex_check_fail
  gosub *push     ;S( (#t #f)? )
  gosub *car      ;CAR( (#t #f)? )
  mov $sarg0, "*ex11_miss"
  if %ret != %sharp_t gosub *pop : goto *ex_check_fail
  gosub *pop      ;(#t #f) < S()
  mov %arg0, %ret
  gosub *cdr     ;CDR( (#t #f)? ) => (#f)?
  mov %arg0, %ret
  gosub *get_tag
  mov $sarg0, "*ex11_miss"
  if %ret != TAG_CONS goto *ex_check_fail
  gosub *car      ;CAR( (#f)? )
  mov $sarg0, "*ex11_2_prev"
  if %ret == %sharp_f goto *ex_check_pass
  mov $sarg0, "*ex11_miss"
  goto *ex_check_fail
*ex11_miss
  textclear
  r_show ari_die
Arisa: "That's not right. Try again!"\
  r_show ari_n
  inc %adv_tmp
  goto *ex11

*ex11_2_prev
  mov $sarg0, "map1"
  gosub *create_symbol
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *find_var
  mov %arg0, %ret
  gosub *cdr
  mov %arg0, %ret
  gosub *push     ;S(map1)
*ex11_2
  mov $problem_label, "*ex11_2_problem"
  mov $tab_label, "*ex11_2_tab"
  mov $ret_label, "*ex11_2"
  mov $suc_label, "*ex11_2_check"
  goto *ex_rep
*ex11_2_problem
!s0Arisa: "Call map1 with the arguments 
#33FF33 (lambda (x) (+ x 1)) #FFFFFF and 
#33FF33' (1 2) #FFFFFF"!sd
  return
*ex11_2_check
  gosub *pop     ;ret<S(input, map1)
  mov %arg0, %ret
  gosub *pop     ;input<S(map1)
  gosub *get_tag
  mov $sarg0, "*ex11_2_miss_check"
  if %ret != TAG_CONS goto *ex_check_fail
  gosub *push     ;S( (2 3)?, map1 )
  gosub *car
  mov %arg0, %ret
  gosub *get_data
  mov $sarg0, "*ex11_2_miss_check"
  if %ret != 2 goto *ex_check_fail
  gosub *pop      ;(2 3)? < S(map1)
  mov %arg0, %ret
  gosub *cdr      ;CDR( (2 3)? ) => (3)?
  mov %arg0, %ret
  gosub *get_tag
  mov $sarg0, "*ex11_2_miss_check"
  if %ret != TAG_CONS goto *ex_check_fail
  gosub *car      ;CAR( (3)? ) => 3?
  mov %arg0, %ret
  gosub *get_data
  mov $sarg0, "*ex11_end"
  if %ret == 3  gosub *pop : goto *ex_check_pass_end
*ex11_2_miss_check
;;;map1の再定義をcheck;;;
  mov $sarg0, "map1"
  gosub *create_symbol
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *find_var
  mov %arg0, %ret
  gosub *cdr
  mov %arg0, %ret
  gosub *pop      ;map1<S()
  if %arg0 != %ret goto *ex11_2_miss
  mov %arg0, %ret
  gosub *push     ;S(map1)
;;;end;;;
  textclear
  r_show ari_die
Alisa: "That's not right. Try again!"\
  r_show ari_n
  inc %adv_tmp
  goto *ex11_2

*ex11_2_miss
  textclear
  r_show ari_muka
Arisa: "...... You sure do some interesting things. @/
  r_show ari_do
Start over from the beginning!!!"\
  r_show ari_n
  inc %adv_tmp
  goto *ex11

*ex11_tab
csel "Continue", *ex11, "Hint", *ex11_hint,  "Return to Title", *ex11_bye
*ex11_2_tab
csel "Continue", *ex11_2, "Hint", *ex11_2_hint,  "Return to Title", *ex11_2_bye

*ex11_bye
  mov %adv_rmode, 1        ;Right-click enabled
  textclear
  csp SP_R
  stop
  gosub *pop      ;new env<S()
  goto *title

*ex11_2_bye
  gosub *pop      ;map1<S(new env)
  goto *ex11_bye

*ex11_hint
  textclear
Arisa: "It takes two arguments, so write it as #33FF33(lambda (f l) expression)#FFFFFF.@/
Then, a function that returns a list with 1 added to each element of the list.
#33FF33
(define (g l)
(if
(null? l)
'()
(cons
(+1 (car l))
(g (cdr l)))))#FFFFFF
Just rewrite this definition a bit.@/
First, as I said, the number of arguments changes. @/
Then, the part #33FF33(+1(car l))#FFFFFF. @/
Here, we are adding 1 to the elements of the list, but when map1 receives the function f, it uses the function that called f with the elements of the list as arguments, so we can write it as #33FF33(f (car l))#FFFFFF. @/
For the recursive part, l takes the CDR, but f is used as is, so we can write it as #33FF33(map1 f (cdr l))#FFFFFF"\
goto *ex11

*ex11_2_hint
textclear
Arisa: "Just write the formula #33FF33(function argument argument)#FFFFFF"\
  goto *ex11_2

*ex11_end
  mov %adv_rmode, 1        ;右クリック有効
  gosub *pop  ;new env<S()
  saveon
  mov %save_flag, 1  ;セーブ可能
  textclear
  add %adv_miss, %adv_tmp
  bgm ms_setsume
  if %adv_tmp == 0 goto *s_11_2
  if %adv_tmp >=4   goto *s_11_3
*s_11_1
Arisa "It was okay."\
  goto *s_11_4
*s_11_2
  r_show ari_hrt
Arisa "There seems to be no problem at all."\
  goto *s_11_4
*s_11_3
  r_show ari_ase
Arisa "There are quite a few mistakes."\
  goto *s_11_4
*s_11_4

r_show ari_n
Arisa: "How was it? I think it's pretty difficult when you're not used to it, but/
The interesting thing about Lisp is that you can naturally write functions that receive functions and functions that return functions like this"\
r_show suzur_dot
Suzuka: "But I think you've done a lot of different things so far, but you've only touched on them and haven't made anything proper"\
r_show ari_n
Arisa: "Well, I guess that's the limit of Lyrical Lisp. @/
If you want to study properly, you have to read a proper book"\
r_show suzur_ase
Suzuka: "...You're up to episode 11 and your lines are terrible"\
r_show ":l;img/arin.bmp"
Arisa: "Arin"\
r_show ari_n
Arisa: "Okay, let's try to make something more substantial next time"\

vsp SP_R, 0
  bg black, E_NORMAL
  r_load ari_tun
  l_load suzu_n
  bgm ms_after
  bg "img/blackboard.bmp", E_NORMAL
  talk_mode
Arisa "Even though it's bothersome, we should probably get in touch with Nanoha soon. Otherwise, spring break will be over."\
  l_show suzu_nc
Suzuka "That's true. Not being able to act is also a problem, so I guess we have no choice."\
  r_show ari_exc
Arisa "Then, it's already late today, so let's call tomorrow."\
  l_show suzu_n
Suzuka "Yeah."\

;;;;;第11話終了;;;;;
  speak_mode
  textclear
  vsp SP_R, 0
  vsp SP_L, 0
  bg black, E_SLOW
;;共通記録の書き換え
  csvopen "arisa.szk", "rc"
  csvread %adv_clear
  csvclose
  if %adv_clear >= 11 goto *story11_after
  mov %adv_clear, 11
  csvopen "arisa.szk", "wc"
  csvwrite %adv_clear
  csvclose
#FFFF33Supplementary Explanation#FFFFFF has been added.
#FFFF33Glossary#FFFFFF has been updated with new terms.\
*story11_after
  r_show suzur_nc
Suzuka: "What should I do?"
csel "Read Supplementary Explanation", *story11_condicil, "Read Glossary", *story11_glossary, "Return to Title", *title_back, "Proceed to Episode 12", *story12

*story11_condicil
  gosub *condicil
  goto *story11_after
*story11_glossary
  gosub *glossary
  goto *story11_after

;;;;;第12話;;;;;
*story12
  mov %adv_noroi_off, 0
  csp SP_R : csp SP_L : print E_FAST
  stop
  talk_mode
  bgm ms_kyoto
  bg "img/blackboard.bmp", E_FAST
  r_in ari_n
  l_in suzu_n
  r_show ari_qes
Arisa: "That's strange..."\
  l_show suzu_qes
Suzuka: "What's wrong?"\
Arisa: "I tried calling Nanoha, but she's not answering.
        I also sent an email, but there's no reply..."\
Suzuka: "Is she busy, I wonder?"\
  r_show ari_tun
Arisa: "No choice then. Let's wait a little longer and try calling again."\

csp SP_R : csp SP_L : print 1
  bg "img/title#12.bmp", E_VFAST
  wait 1000
  delay 2000
  bgm ms_setsume
  bg "img/blackboard.bmp", E_FAST

speak_mode
  r_show ari_n
Arisa: "The symbol #FFFF33o#FFFFFF looks like a dango, right?"\
  r_show suzur_qes
Suzuka: "You think so?"\
  r_show ari_muka
Arisa: "This is a point where you have to say 'I see' or the conversation won't continue!"\
  r_show suzur_qes
Suzuka: "So, what's up with the dango?"\
  r_show ari_n
Arisa: "In the list, there's one dango #33FF33(o)#FFFFFF, two dango #33FF33(o o)#FFFFFF. @/
These are just lists, but you can also think of them as 1 and 2, right? @/
In this way, it seems like we can express 'numbers' using lists instead of actual numbers."\
  r_show suzur_n
Suzuka: "Uh, you mean we should think of a list like #33FF33(o o o)#FFFFFF as 3, right?"\
  r_show ari_n
Arisa: "Exactly. More specifically, consider the number of the symbol #33FF33o#FFFFFF in the list as the 'number.' @/
Here, let's call the symbol #33FF33o#FFFFFF a 'dango.' @/
As a special case, let's represent 0 using an empty list. @/
For example,
0 is #33FF33()#FFFFFF
1 is #33FF33(o)#FFFFFF
2 is #33FF33(o o)#FFFFFF
3 is #33FF33(o o o)#FFFFFF
That's how you should think of it. @/
Let's call the numbers created this way 'dango numbers.' @/
Now we'll think about arithmetic operations using these."\
  r_show suzur_nc
Suzuka: "Using cons,
#33FF33(cons 'o '(o o))#FFFFFF
becomes #33FF33(o o o)#FFFFFF, which makes it increase by 1, and using cdr,
#33FF33(cdr '(o o))#FFFFFF
becomes #33FF33(o)#FFFFFF, which makes it decrease by 1, right?"\
  r_show ari_n
Arisa: "Let's define such calculations as functions. @/
However, writing lists directly like #33FF33'(o o)#FFFFFF isn't cool, so we'll make it so that all dango number calculations can be done with function calls alone. @/
Let's create three important functions for now. @/
First, a function that returns the dango number representing 0.
#33FF33/
(define (zero)
 '( ))#FFFFFF@
And then, a function that receives a dango number and returns the dango number with 1 added to it.
#33FF33/
(define (inc n)
 (cons 'o n))#FFFFFF@
Lastly, a function that receives a dango number and returns the dango number with 1 subtracted from it.
#33FF33/
(define (dec n)
 (cdr n))#FFFFFF@
With these three functions, you can freely create numbers of dango."\
  r_show suzur_excc
Suzuka: "Uh, you get the dango number 0 with #33FF33zero#FFFFFF, and with #33FF33inc#FFFFFF you get the dango number one larger,
so you can create them like this:
0 is #33FF33(zero)#FFFFFF
1 is #33FF33(inc (zero))#FFFFFF
2 is #33FF33(inc (inc (zero)))#FFFFFF
3 is #33FF33(inc (inc (inc (zero))))#FFFFFF
You can indeed represent any natural number this way."\
  r_show ari_n
Arisa: "Next, let's think about addition of dango numbers.@
When you calculate
'(o) plus (o o)'.
First, transfer one dango from the right #33FF33(o o)#FFFFFF to the left #33FF33(o)#FFFFFF. @/
Then the left is #33FF33(o o)#FFFFFF, and the right is #33FF33(o)#FFFFFF. @/
Since there's still dango left in the right, transfer another dango,/
then the left is #33FF33(o o o)#FFFFFF, and the right becomes an empty list. @/
There's no more dango to transfer from the right, so addition ends. @/
Thus, 1 plus 2 becomes 3."\
  r_show suzur_nc
Suzuka: "If there's no dango on the right, return the dango number on the left. @/
If there is dango on the right, transfer one to the left and repeat the calculation. @/
Written as an expression, it's like this:
#33FF33/
(define (add x y)
  (if (null? y)
      x
      (add (inc x)
           (dec y))))#FFFFFF
You can write it like this. @/
The value of this expression is #33FF33(o o o)#FFFFFF, so you can see it properly calculates 1 plus 2."\
  r_show ari_n
Arisa: "Next is subtraction. @
Consider '(o o o) minus (o o)'.
Since both the right and left have dango left, remove one dango from both sides. @/
Then the left becomes #33FF33(o o)#FFFFFF, and the right becomes #33FF33(o)#FFFFFF. @/
Repeat this as both sides still have dango. @/
Then the left becomes #33FF33(o)#FFFFFF, and the right becomes an empty list. @/
The right has no dango left, so the subtraction ends. @/
This way, 3 minus 2 becomes 1. @/
Unlike addition, it's a bit tricky because if the subtracting number is larger than the subtracted number, the calculation needs to stop once the left dango runs out. @/
That way, for subtraction like 2 minus 3, the answer is 0."\
  r_show suzur_nc
Suzuka: "If either dango on either side runs out, return the dango number on the left. @/
If there is dango, remove one from both sides and repeat the calculation. @/
Written as an expression, it's like this:
#33FF33/
(define (sub x y)
  (cond
    ((null? x) x)
    ((null? y) x)
    (else
     (sub (dec x)
          (dec y)))))#FFFFFF
You can write it like this. @/
The value of this expression is #33FF33(o)#FFFFFF, so you can see it properly calculates 2 minus 1."\
  r_show ari_n
Arisa: "Now, when it comes to multiplication, it gets a bit difficult. @/
This time, let's think about 'x times y' instead of specific numbers. @/
This can be thought of as 'adding x to 0, y times.' @/
Therefore,
#33FF33/
(define (mul x y)
  (muli x y (zero)))#FFFFFF
and by using recursion in #33FF33muli#FFFFFF, you can perform multiplication. @/
Why don't you actually try it out? @/
If it seems difficult, you can view a hint with the Tab key."\

gosub *ex_init
*ex12_prev
  ;;定義済み関数
  mov $sarg0, "(begin (define (zero) '()) (define (inc x) (cons 'o x)) (define (dec x) (cdr x)) )"
  gosub *input_to_lobject
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *eval_form
  mov $sarg0, "(define (add x y) (if (null? y) x (add (inc x) (dec y))))"
  gosub *input_to_lobject
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *eval_form
  mov $sarg0, "(define (mul x y) (muli x y (zero)))"
  gosub *input_to_lobject
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *eval_form
  ;;
*ex12
  mov $problem_label, "*ex12_problem"
  mov $tab_label, "*ex12_tab"
  mov $ret_label, "*ex12"
  mov $suc_label, "*ex12_check"
  goto *ex_rep
*ex12_problem
!s0Arisa: "Define the function muli./
However, zero, inc, dec, add, and mul are already defined./
Muli is called #33FF33 (mul x y (zero)) #FFFFFF from within mul."!sd
  return
*ex12_check
  gosub *pop : gosub *pop
  ;;;検証1
  mov $sarg0, "(mul (inc (zero)) (zero))"
  gosub *input_to_lobject
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *eval_form
  mov %arg0, %ret
  gosub *adv_length
  mov $sarg0, "*ex12_miss"
  if %ret != 0 goto *ex_check_fail
  ;;;検証2
  mov $sarg0, "(mul (inc (inc (zero))) (inc (inc (inc (zero)))))"
  gosub *input_to_lobject
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *eval_form
  mov %arg0, %ret
  gosub *adv_length
  mov $sarg0, "*ex12_2_prev"
  if %ret == 6 goto *ex_check_pass
  mov $sarg0, "*ex12_miss"
  goto *ex_check_fail
*ex12_miss
  textclear
  r_show ari_die
Arisa: "That's not right. Try again!"\
  r_show ari_n
  inc %adv_tmp
  goto *ex12

*ex12_2_prev
  mov $sarg0, "muli"
  gosub *create_symbol
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *find_var
  mov %arg0, %ret
  gosub *cdr
  mov %arg0, %ret
  gosub *push     ;S(muli)
*ex12_2
  mov $problem_label, "*ex12_2_problem"
  mov $tab_label, "*ex12_2_tab"
  mov $ret_label, "*ex12_2"
  mov $suc_label, "*ex12_2_check"
  goto *ex_rep
*ex12_2_problem
!s0Arisa: "Use the function mul to calculate the number of rounds, '2 times 3'"!sd
  return
*ex12_2_check
  gosub *pop     ;ret<S(input, muli)
  mov %arg0, %ret
  gosub *pop     ;input<S(muli)
  gosub *adv_length
  mov $sarg0, "*ex12_end"
  if %ret == 6 gosub *pop : goto *ex_check_pass_end
  mov $sarg0, "*ex12_2_normal_miss"
  goto *ex_check_fail
*ex12_2_normal_miss
;;;muliの再定義をcheck;;;
  mov $sarg0, "muli"
  gosub *create_symbol
  mov %arg0, %ret
  mov %arg1, %toplevel_env
  gosub *find_var
  mov %arg0, %ret
  gosub *cdr
  mov %arg0, %ret
  gosub *pop      ;muli<S()
  if %arg0 != %ret goto *ex12_2_miss
  mov %arg0, %ret
  gosub *push     ;S(muli)
;;;end;;;
  textclear
  r_show ari_die
Alisa: "That's not right. Try again!"
  r_show ari_n
  inc %adv_tmp
  goto *ex12_2

*ex12_2_miss
  textclear
  r_show ari_muka
Arisa: "……You're doing quite interesting things. @/
  r_show ari_do
Start over from the beginning!!!"\
  r_show ari_n
  inc %adv_tmp
  goto *ex12

*ex12_tab
csel "Continue", *ex12, "Hint", *ex12_hint,  "Return to Title", *ex12_bye
*ex12_2_tab
csel "Continue", *ex12_2, "Hint", *ex12_2_hint,  "Return to Title", *ex12_2_bye

*ex12_bye
  mov %adv_rmode, 1        ;Right click enabled
  textclear
  csp SP_R
  stop
  gosub *pop      ;new env<S()
  goto *title

*ex12_2_bye
  gosub *pop      ;muli<S(new env)
  goto *ex12_bye

*ex12_hint
  textclear
Arisa: "There are three arguments to receive, so you can write it as #33FF33(lambda (x yn) expression)#FFFFFF.@/
The important thing here is that "x times y" can be rephrased as "add x to 0 y times".@/
"y times" can be rephrased as "as long as y has dumplings".@/
So, if y is not an empty list, leave x as x, subtract 1 from y, and set n to "n plus x" and recurse.@/
Specifically,
#33FF33(mul x (dec y) (add n x))#FFFFFF
That's right.@/
Then, use if to return #33FF33n#FFFFFF if y is an empty list, and recurse if not."\
goto *ex12

*ex12_2_hint
textclear
Arisa: "Multiplication of the number of dumplings can be expressed as #33FF33 (mul number of dumplings number of dumplings) #FFFFFF. @/
2 is #33FF33 (inc (inc (zero))) #FFFFFF, /
3 is #33FF33 (inc (inc (inc (zero)))) #FFFFFF"\
goto *ex12_2

*ex12_end
  mov %adv_rmode, 1        ;右クリック有効
  gosub *pop  ;new env<S()
  saveon
  mov %save_flag, 1  ;セーブ可能
  textclear
  add %adv_miss, %adv_tmp
  bgm ms_setsume
  if %adv_tmp == 0 goto *s_12_2
  if %adv_tmp >=2   goto *s_12_3
*s_12_1
Arisa: "That was so-so."
  goto *s_12_4
*s_12_2
  r_show ari_hrt
Arisa: "It looks like there's no problem at all."
  goto *s_12_4
*s_12_3
  r_show ari_ase
Arisa: "There are quite a few mistakes."
  goto *s_12_4
*s_12_4

r_show ari_n
Arisa "Good job. You did well."\
  r_show suzur_qes
Suzuka "Is it division next?"\
  r_show ari_n
Arisa "Since you could write multiplication by yourself, I'm sure you can write division by yourself too.@/
That's why I won't explain it here, but maybe you can try it in free mode."\
  r_show suzur_qes
Suzuka "I think it's amazing to be able to do arithmetic without using numbers, but @/
by the way, is this useful for anything?"\
  r_show ari_dere
Arisa "......If you say that, it's the end of it."\
  r_show suzur_exc
Suzuka "Well, if you ask whether Lyrical Lisp itself is useful, I'd have trouble answering, @/
so in that sense, maybe it's correct as the last practice problem for Lyrical Lisp."\
  r_show ari_ase
Arisa "Suzuka, that's not really helping..."\

stop
  vsp SP_R, 0
  bg black, E_NORMAL
  r_load ari_n
  l_load suzu_n
  bg "img/blackboard.bmp", E_NORMAL
  talk_mode
  lsp SP_FILL, ":c;img/nano_pink.bmp", 0, 0
  print E_FAST
  csp SP_FILL
  print E_FAST
  bgm ms_nano
  l_show suzu_qes
Suzuka: "Didn't you just see a pink light?"\
  r_show ari_exc
Alisa: "That pink... no way!!"\
  l_show":l;img/same.bmp"
Samejima: "Both of you, please run away!"\
  mov %adv_noroi_off, 1
  csp SP_R : csp SP_L
  print E_FAST
  quake 6,400  
  delay 1000
  bg "img/yama_b.bmp", E_LWIPE_FAST
  r_in ari_n
Alisa: "We somehow shook them off!?"\
  l_in ":l;img/nano.bmp"
Nanoha: "They're already catching up..."\
  r_show ari_tun
Alisa: "Ah!!!"\
Nanoha: "The people who stole the device and harmed the officers were Alisa and her friends..."\
  r_show ari_ase
Alisa: "Nanoha..."\
Nanoha: "I guess the reason is probably something like wanting to use magic or something."\
Nanoha: "I'll hear what you have to say in a way fitting for devils."\
  r_show ":l;img/same.bmp"
Samejima: "I had hoped we could talk peacefully..."\

stop
  csp SP_R : csp SP_L
  bg black, E_WIPE2
  bgm ms_battlen
  gosub *battle12
  if %ret == 0 goto *battle12_after_win
*battle12_after_lost
  bgm ms_epilogue1
  l_load ":l;img/nano.bmp"
  r_load ari_n
  bg "img/yama_b.bmp", E_FAST

Nanoha: "Arisa-chan, will you be able to get caught quietly?"\
r_show ari_tun
Arisa: "Samejima... it's your turn."\
r_show ":l;img/same.bmp"
Samejima: "Your turn?"\
r_show ari_n
bgm ms_epilogue2
Arisa: "Taking responsibility is the adult's job. There's no need for children to take it."\
r_show ":l;img/same.bmp"
Samejima: "That... that means..."\
l_in ":l;img/jiku2.bmp"
Officer: "This old man! This guy attacked me!"\
Samejima: "Hey, hey! You!"\
Officer: "Hi, hiiiiiiiiii!"\
l_out
r_show suzur_n
Suzuka: "We didn't attack anyone"\
l_show ":l;img/nano.bmp"
Nanoha: "It's true that the records say that all the attacks were made by the 'old man' - that is, Samejima-san..."\
r_show ari_n
Arisa: "We didn't do anything! The one at fault is probably Samejima! I'm sure of it!!"\
r_show ":l;img/same.bmp"
Samejima (Miss Arisa, what do you mean by 'probably' and 'surely'...?)\
Nanoha: "Hmm, I'm not really sure what's going on anymore. What should I do?"\
r_show suzur_dere
Suzuka: "Nanoha-chan! I can't believe we are! We've been friends forever!"\
Nanoha: "Suzuka-chan! W250...! W250...! W500 Yes. I believe in you.

I believe in you two!!"\
r_show ":l;img/same.bmp"
Samejima (I've always been looking after Lady Arisa, so my position is...)\
Nanoha: "Then, please take this man to Ursula"\
l_show ":l;img/jiku.bmp"
Officer: "Understood. Nanoha-san!!"\
csp SP_R : csp SP_L
lsph SP_CRC, ":a;img/same_curcle.bmp", 0, 0
bg black, E_SLOW
c_show ":l;img/same.bmp"
vsp SP_CRC, 1
print E_CURCLE
;;Effect
Samejima: "I'm sick of magic..." \
csp SP_C : print E_SLOW
Ending 1: #FFFF33 Sad Samejima #FFFFFF\
gosub *save_allclear
csp SP_CRC
gosub *ending
;;;
textclear
csp SP_R : csp SP_L
stop
goto *title
;;;

*battle12_after_win
  stop
;;  bgm ms_epilogue2
  l_load suzu_dot
  r_load ari_ase
  bg "img/yama_b.bmp", E_FAST
Suzuka: "Hawawa……"\
Arisa: "We did it……"\
  l_show ":l;img/same.bmp"
鮫島: "It's alright. I held back. Their lives
　　　should not be in danger"\
  l_show suzu_dere
Suzuka: "Samejima-san……"\
  r_show ari_dere
Arisa: "Was insanely strong……"\
  csp SP_R : csp SP_L
  bg black, E_SLOW
Afterward, the three were captured by the Time-Space Administration Bureau. However, as a special case, the three received a sentence of probationary observation.\
However, Samejima was engaged as a contract mage for the Time-Space Administration Bureau.\
  bgm ms_nano
Later, during a certain mission, Samejima was seriously injured and is currently under treatment.\
The circumstances leading to the serious injury are currently under investigation.\
It is suspected that an S+ class equivalent mage attacked him.\
The medical officer who performed Samejima's first aid heard the following words:\
Samejima: "ああ、!w300pink light……!w300I can see pink
　　　light……"\
Ending 2 『#FFFF33Pink Light#FFFFFF』\
  gosub *save_allclear
  gosub *ending
  ;;;
  textclear
  csp SP_R : csp SP_L
  stop
  goto *title
  ;;;

;;;;(define (muli x y n) (if (null? y) n (muli x (dec y) (add x n))))
;; Episode 2 Start MesBox

*save_allclear
;; Common record update
  csvopen "arisa.szk", "rc"
  csvread %adv_clear
  csvclose
  if %adv_clear >= 12 return
  mov %adv_clear, 12
  csvopen "arisa.szk", "wc"
  csvwrite %adv_clear
  csvclose
  return

;;;;;第12話終了;;;;;
  speak_mode
  textclear
  vsp SP_R, 0
  vsp SP_L, 0
  bg black, E_SLOW
;;共通記録の書き換え
  csvopen "arisa.szk", "rc"
  csvread %adv_clear
  csvclose
  if %adv_clear >= 12 goto *story12_after
  mov %adv_clear, 12
  csvopen "arisa.szk", "wc"
  csvwrite %adv_clear
  csvclose
#FFFF33Supplementary explanation#FFFFFF has been added.
#FFFF33Glossary#FFFFFF has been updated with new terms.\
*story12_after
  r_show suzur_nc
Suzuka: "What should I do?"
csel "Read supplementary explanation", *story12_condicil, "Read glossary", *story12_glossary, "Return to title", *title_back, "Proceed to Episode 13", *story13

*story12_condicil
  gosub *condicil
  goto *story12_after
*story12_glossary
  gosub *glossary
  goto *story12_after

Arisa "Well, with that, let's move on to the next explanation."\
  r_show suzu_n
Suzuka "This is getting troublesome, so let's end it here."\
Arisa "!?"\
Suzuka "Well then, goodbye everyone."\
  r_show ":l;img/arin.bmp"
Arisa "Ariin"\
end

*adv_length
  mov %arg2, 0
*adv_length_l1
  gosub *get_tag
  if %ret != TAG_CONS mov %ret, %arg2 : return 
  mov %arg1, %arg0
  mov %arg0, %arg2
  gosub *push     ;S(count)
  mov %arg0, %arg1
  gosub *cdr      ;lst = CDR(lst)
  mov %arg0, %ret
  gosub *pop      ;count<S()
  mov %arg2, %ret
  inc %arg2
  goto *adv_length_l1

*sc
  itoa $sarg0, %tmp
  if %tmp < 10 mov $sarg0, "sc/000" + $sarg0 + ".bmp"
  if %tmp >= 10 && %tmp < 100 mov $sarg0, "sc/00" + $sarg0 + ".bmp"
  if %tmp >= 100 && %tmp < 1000 mov $sarg0, "sc/0" + $sarg0 + ".bmp"
  if %tmp >= 1000 mov $sarg0, "sc/" + $sarg0 + ".bmp"
  getscreenshot 320, 240
  savescreenshot $sarg0
  inc %tmp
  return

;;4.3sec=130frm

;;Flower, Frame, Samejima, Zafira, Staff (Text)
*ending
  saveoff   ;;;

lsph SP_INU01, ":l;img/inu01.bmp", 0, 0          ;344x131
  lsph SP_INU02, ":l;img/inu02.bmp", 0, 0
  lsph SP_INU01_R, ":l;img/inu01_r.bmp", 0, 0
  lsph SP_INU02_R, ":l;img/inu02_r.bmp", 0, 0
  lsph SP_SAME_HEAD, ":l;img/same_head.bmp", 0, 0  ;192x287(147)
  lsph SP_SAME_BODY, ":l;img/same_body.bmp", 0, 0  ;192x214(107)
  lsph SP_SAME_FOOT, ":l;img/same_foot.bmp", 0, 0  ;192x24
  lsph SP_FLOWER, ":l;img/flower.bmp", 0, 0        ;362x235
  lsph SP_S, ":l;img/s.bmp", 0, 0                  ;34x76
  lsph SP_ST, ":l;img/st.bmp", 0, 0                ;76x34
  lsph SP_EFRAME, ":l;img/eframe.bmp", 0, 0
  lsph SP_FILL, ":l;img/curtain.bmp", 0, 0
  mov %adv_tmp3, 0 ;Added each frame
  mov %adv_sx, 896
  mov %adv_sy, 538
  mov %adv_sr, 0

mov %adv_ix, 972
  mov %adv_id, 0
  mov %arg0, 60
  mov %arg1, 530

bgmfadeout 3000
  bgm ms_ending
*ending_loop0
  resettimer
  gosub *draw_back
  gosub *draw_frame
  gosub *draw_staff
  draw
  ;;comment;;gosub *sc
  inc %adv_tmp3
  waittimer 33
  if %adv_tmp3 == 272 goto *ending_loop1
  goto *ending_loop0

*ending_loop1
  resettimer
  gosub *draw_back
  gosub *draw_frame
  gosub *draw_inu
  gosub *draw_staff
  draw
  ;;comment;;gosub *sc
  sub %adv_ix, 9
  inc %adv_tmp3
  waittimer 33
;;  if %adv_ix < -344 goto *ending_loop2_pre  ;Ideally, control using adv_tmp3
  if %adv_tmp3 == 667 goto *ending_loop2_pre
  goto *ending_loop1

*ending_loop2_pre
*ending_loop2
  resettimer
  gosub *draw_back
  gosub *draw_frame
  gosub *draw_yurasame
  gosub *draw_staff
  draw
  ;;comment;;gosub *sc
  sub %adv_sx, 20
  inc %adv_tmp3
  waittimer 33
  if %adv_sx <= 650 goto *ending_loop2_2       ;Moved
  goto *ending_loop2

*ending_loop2_2
  resettimer
  gosub *draw_back
  gosub *draw_frame
  gosub *draw_yurasame
  gosub *draw_staff
  draw
  ;;comment;;gosub *sc
  add %adv_sr, 7
  mod %adv_sr, 360
  inc %adv_tmp3
  waittimer 33
  if %adv_tmp3 == 1090 goto *ending_loop3_pre
  goto *ending_loop2_2

*ending_loop3_pre
  mov %adv_id, 1
  mov %adv_ix, -344
  mov %arg0, 60
  mov %arg1, 530
*ending_loop3
  resettimer
  gosub *draw_back
  gosub *draw_frame
  gosub *draw_yurasame
  gosub *draw_inu
  gosub *draw_staff
  draw
  ;;comment;;gosub *sc
  add %adv_sr, 7
  mod %adv_sr, 360
  add %adv_ix, 9
  inc %adv_tmp3
  waittimer 33
  if %adv_tmp3 == 1515 goto *ending_loop4_pre
  goto *ending_loop3

*ending_loop4_pre
  mov %adv_id, 0
  mov %adv_ix, 972
  mov %arg0, 55
  mov %arg1, 500
*ending_loop4
  resettimer
  gosub *draw_back
  gosub *draw_frame
  gosub *draw_inu
  gosub *draw_yurasame
  gosub *draw_staff
  draw
  ;;comment;;gosub *sc
  add %adv_sr, 7
  mod %adv_sr, 360
  sub %adv_ix, 5
  inc %adv_tmp3
  waittimer 33
;;  if %adv_ix < -344 goto *ending_loop5_pre
  if %adv_tmp3 == 2030 goto *ending_loop5_pre
  goto *ending_loop4

*ending_loop5_pre
  mov %adv_id, 1
  mov %adv_ix, -344
  mov %arg0, 200
  mov %arg1, 500
*ending_loop5
  resettimer
  gosub *draw_back
  gosub *draw_frame
  gosub *draw_yurasame
  gosub *draw_inu
  gosub *draw_staff
  draw
  ;;comment;;gosub *sc
  add %adv_sr, 7
  mod %adv_sr, 360
  add %adv_ix, 27
  inc %adv_tmp3
  waittimer 33
;;  if %adv_ix > 972 goto *ending_loop6_pre
  if %adv_tmp3 == 2424 goto *ending_loop6_pre
  goto *ending_loop5

*ending_loop6_pre
  mov %adv_id, 0
  mov %adv_ix, 972
  mov %arg0, 55
  mov %arg1, 60
*ending_loop6
  resettimer
  gosub *draw_back
  gosub *draw_frame
  gosub *draw_inu
  gosub *draw_yurasame
  gosub *draw_staff
  draw
  ;;comment;;gosub *sc
  add %adv_sr, 7
  mod %adv_sr, 360
  sub %adv_ix, 5
  inc %adv_tmp3
  waittimer 33
;;  if %adv_ix < -344 goto *ending_loop7_pre
  if %adv_tmp3 == 3060 goto *ending_loop7_pre
  goto *ending_loop6

*ending_loop7_pre
  mov %adv_ix, 1300    ;Using Zafira's coordinates
*ending_loop7
  resettimer
  gosub *draw_back
  gosub *draw_frame
  gosub *draw_yurasame
  drawsp2 SP_FILL, 0, 255, %adv_ix, 300, 100, 100, 0
  draw
  ;;comment;;gosub *sc
  add %adv_sr, 7
  mod %adv_sr, 360
  inc %adv_tmp3
  sub %adv_ix, 55
  if %adv_ix < 300 mov %adv_ix, 300
  waittimer 33
  if %adv_tmp3 == 3224 goto *ending_end
;;  if %adv_tmp3 == 3133 goto *ending_end
  goto *ending_loop7

*ending_end
  stop
  bgmfadeout 100
  csp SP_INU01
  csp SP_INU02
  csp SP_INU01_R
  csp SP_INU02_R
  csp SP_SAME_HEAD
  csp SP_SAME_BODY
  csp SP_SAME_FOOT
  csp SP_FLOWER
  csp SP_S
  csp SP_ST
  csp SP_EFRAME
  csp SP_FILL
  return

;;;;;;;;;;
;;;draw_inu
;;in     : adv_ix, adv_id, adv_tmp3, arg0, arg1
;;change : adv_tmp
;;;;;;;;;;
*draw_inu
  mov %adv_tmp, %adv_tmp3
  mod %adv_tmp, 20
  if %adv_tmp < 10 && %adv_id == 0 drawsp2 SP_INU01, 0, 255, %adv_ix, %arg1, %arg0, %arg0, 0
  if %adv_tmp < 10 && %adv_id == 1 drawsp2 SP_INU01_R, 0, 255, %adv_ix, %arg1, %arg0, %arg0, 0
  if %adv_tmp >= 10 && %adv_id == 0 drawsp2 SP_INU02, 0, 255, %adv_ix, %arg1, %arg0, %arg0, 0
  if %adv_tmp >= 10 && %adv_id == 1 drawsp2 SP_INU02_R, 0, 255, %adv_ix, %arg1, %arg0, %arg0, 0
  return

;;;;;;;;;;
;;;draw_yurasame
;;in     : adv_sx, adv_sy, adv_sr
;;change : adv_tmp, adv_tmp1, adv_tmp2
;;;;;;;;;;
*draw_yurasame
  ;Calculate angle
  sin %adv_tmp, %adv_sr
  mul %adv_tmp, 10
  div %adv_tmp, 1000
  ;Calculate Y reduction
  cos %adv_tmp1, %adv_tmp
  mul %adv_tmp1, 97
  div %adv_tmp1, 1000
  ;Calculate X reduction
  sin %adv_tmp2, %adv_tmp
  mul %adv_tmp2, 97
  div %adv_tmp2, 1000
  drawsp2 SP_SAME_HEAD, 0, 255, %adv_sx-%adv_tmp2, %adv_sy-%adv_tmp1, 100, 100, 0
  drawsp2 SP_SAME_FOOT, 0, 255, %adv_sx, %adv_sy+10, 100, 100, 0
  drawsp2 SP_SAME_BODY, 0, 255, %adv_sx, %adv_sy, 100, 100, %adv_tmp
  return

;;change : adv_tmp
*draw_back
  ;0-3060 (765x4(G^, B_, R^, G_))
  if %adv_tmp3 < 765 goto *draw_back_l1
  if %adv_tmp3 < 1530 goto *draw_back_l2
  if %adv_tmp3 < 2295 goto *draw_back_l3
  if %adv_tmp3 < 3060 goto *draw_back_l4
  goto *draw_back_l5

*draw_back_l1
  mov %adv_tmp, %adv_tmp3
  mul %adv_tmp, 150
  div %adv_tmp, 754
  add %adv_tmp, 50
  drawfill 50, %adv_tmp, 200
  return

*draw_back_l2
  mov %adv_tmp, %adv_tmp3
  sub %adv_tmp, 765
  mul %adv_tmp, 150
  div %adv_tmp, 754
  mov %adv_tmp, 150 - %adv_tmp
  add %adv_tmp, 50
  drawfill 50, 200, %adv_tmp
  return

*draw_back_l3
  mov %adv_tmp, %adv_tmp3
  sub %adv_tmp, 1530
  mul %adv_tmp, 150
  div %adv_tmp, 754
  add %adv_tmp, 50
  drawfill %adv_tmp, 200, 50
  return

*draw_back_l4
  mov %adv_tmp, %adv_tmp3
  sub %adv_tmp, 2295
  mul %adv_tmp, 150
  div %adv_tmp, 754
  mov %adv_tmp, 150 - %adv_tmp
  add %adv_tmp, 50
  drawfill 200, %adv_tmp, 50
  return

*draw_back_l5
  drawfill 200, 50, 50
  return

;;
*draw_frame
  if %adv_tmp3 < 90 return
  if %adv_tmp3 > 130 drawsp2 SP_EFRAME, 0, 255, 400, 300, 100, 100, 0 : return

drawsp2 SP_FLOWER, 0, 255, 400, 100, 80, 80, 0
  if %adv_tmp3 <= 99 return
  ;TL;[100, 102]
  mov %adv_tmp2, %adv_tmp3
  sub %adv_tmp2, 100
  mul %adv_tmp2, -76
  add %adv_tmp2, 207
  if %adv_tmp2 < 55 mov %adv_tmp2, 55
  for %adv_tmp = 207 to %adv_tmp2 step -76
    drawsp2 SP_ST, 0, 255, %adv_tmp, 80, 100, 100, 0
    next
  if %adv_tmp3 <= 102 return

;L[103, 108]
  mov %adv_tmp2, %adv_tmp3
  sub %adv_tmp2, 103
  mul %adv_tmp2, 76
  add %adv_tmp2, 138
  if %adv_tmp2 > 518 mov %adv_tmp2, 518
  for %adv_tmp = 138 to %adv_tmp2 step 76
    drawsp2 SP_S, 0, 255, 40, %adv_tmp, 100, 100, 0
    next
  if %adv_tmp3 <= 108 return

;B[109, 117]
  mov %adv_tmp2, %adv_tmp3
  sub %adv_tmp2, 109
  mul %adv_tmp2, 76
  add %adv_tmp2, 99
  if %adv_tmp2 > 707 mov %adv_tmp2, 707
  for %adv_tmp = 99 to %adv_tmp2 step 76
    drawsp2 SP_ST, 0, 255, %adv_tmp, 530, 100, 100, 0
    next
  if %adv_tmp3 <= 117 return

;R[118, 123]
  mov %adv_tmp2, %adv_tmp3
  sub %adv_tmp2, 118
  mul %adv_tmp2, -76
  add %adv_tmp2, 518
  if %adv_tmp2 < 138 mov %adv_tmp2, 138
  for %adv_tmp = 518 to %adv_tmp2 step -76
    drawsp2 SP_S, 0, 255, 760, %adv_tmp, 100, 100, 0
    next
  if %adv_tmp3 <= 123 return

;TR[124, 126]
  mov %adv_tmp2, %adv_tmp3
  sub %adv_tmp2, 124
  mul %adv_tmp2, -76
  add %adv_tmp2, 745
  if %adv_tmp2 < 593 mov %adv_tmp2, 593
  for %adv_tmp = 745 to %adv_tmp2 step -76
    drawsp2 SP_ST, 0, 255, %adv_tmp, 80, 100, 100, 0
    next
;  if %adv_tmp3 <= 126 return
  return

;3060/22 = 139...2
*draw_staff
  if %adv_tmp3 < 141 return
  if %adv_tmp3 == 141 gosub *draw_staff_l1
  if %adv_tmp3 == 280 gosub *draw_staff_l2
  if %adv_tmp3 == 419 gosub *draw_staff_l3
  if %adv_tmp3 == 558 gosub *draw_staff_l4
  if %adv_tmp3 == 697 gosub *draw_staff_l5
  if %adv_tmp3 == 836 gosub *draw_staff_l6
  if %adv_tmp3 == 975 gosub *draw_staff_l7
  if %adv_tmp3 == 1114 gosub *draw_staff_l8
  if %adv_tmp3 == 1253 gosub *draw_staff_l9
  if %adv_tmp3 == 1392 gosub *draw_staff_l10
  if %adv_tmp3 == 1531 gosub *draw_staff_l11
  if %adv_tmp3 == 1670 gosub *draw_staff_l12
  if %adv_tmp3 == 1809 gosub *draw_staff_l13
  if %adv_tmp3 == 1948 gosub *draw_staff_l14
  if %adv_tmp3 == 2087 gosub *draw_staff_l15
  if %adv_tmp3 == 2226 gosub *draw_staff_l16
  if %adv_tmp3 == 2365 gosub *draw_staff_l17
  if %adv_tmp3 == 2504 gosub *draw_staff_l18
  if %adv_tmp3 == 2643 gosub *draw_staff_l19
  if %adv_tmp3 == 2782 gosub *draw_staff_l20
  if %adv_tmp3 == 2921 gosub *draw_staff_l21
  mov %adv_tmp, %adv_tmp3
  sub %adv_tmp, 2
  mod %adv_tmp, 139
  if %adv_tmp < 8 mul %adv_tmp, 8 : goto *draw_staff_draw
  if %adv_tmp >= 132 mov %adv_tmp, 139 - %adv_tmp : mul %adv_tmp, 8 : goto *draw_staff_draw
  mov %adv_tmp, 255
*draw_staff_draw
  drawsp2 SP_TMP, 0, %adv_tmp, 400, 250, 100, 100, 0
  drawsp2 SP_TMP1, 0, %adv_tmp, 400, 285, 100, 100, 0
  drawsp2 SP_TMP2, 0, %adv_tmp, 400, 320, 100, 100, 0
  drawsp2 SP_TMP3, 0, %adv_tmp, 400, 355, 100, 100, 0
  return

*draw_staff_l1
  lsph SP_TMP,  ":s/30,30,1;#FFFFFFPlanning      Karasumidou", 0, 0
  lsph SP_TMP1, ":s/30,30,1;#FFFFFF", 0, 0
  lsph SP_TMP2, ":s/30,30,1;#FFFFFF", 0, 0
  lsph SP_TMP3, ":s/30,30,1;#FFFFFF", 0, 0
  return

*draw_staff_l2
  lsph SP_TMP,  ":s/30,30,1;#FFFFFFProduction Produce　　　Mido", 0, 0
  lsph SP_TMP1, ":s/30,30,1;#FFFFFF", 0, 0
  lsph SP_TMP2, ":s/30,30,1;#FFFFFF", 0, 0
  lsph SP_TMP3, ":s/30,30,1;#FFFFFF", 0, 0
  return

*draw_staff_l3
  lsph SP_TMP,  ":s/30,30,1;#FFFFFFGeneral Management　　　Mido", 0, 0
  lsph SP_TMP1, ":s/30,30,1;#FFFFFF", 0, 0
  lsph SP_TMP2, ":s/30,30,1;#FFFFFF", 0, 0
  lsph SP_TMP3, ":s/30,30,1;#FFFFFF", 0, 0
  return

*draw_staff_l4
  lsph SP_TMP,  ":s/30,30,1;#FFFFFFGame System Design       zick", 0, 0
  lsph SP_TMP1, ":s/30,30,1;#FFFFFF", 0, 0
  lsph SP_TMP2, ":s/30,30,1;#FFFFFF", 0, 0
  lsph SP_TMP3, ":s/30,30,1;#FFFFFF", 0, 0
  return

*draw_staff_l5
  lsph SP_TMP,  ":s/30,30,1;#FFFFFFMain Scenario       zick", 0, 0
  lsph SP_TMP1, ":s/30,30,1;#FFFFFF", 0, 0
  lsph SP_TMP2, ":s/30,30,1;#FFFFFF", 0, 0
  lsph SP_TMP3, ":s/30,30,1;#FFFFFF", 0, 0
  return

*draw_staff_l6
  lsph SP_TMP,  ":s/30,30,1;#FFFFFFBonus Scenario      nathki", 0, 0
  lsph SP_TMP1, ":s/30,30,1;#FFFFFF", 0, 0
  lsph SP_TMP2, ":s/30,30,1;#FFFFFF", 0, 0
  lsph SP_TMP3, ":s/30,30,1;#FFFFFF", 0, 0
  return

*draw_staff_l7
  lsph SP_TMP,  ":s/30,30,1;#FFFFFFScreen Production       zick", 0, 0
  lsph SP_TMP1, ":s/30,30,1;#FFFFFF", 0, 0
  lsph SP_TMP2, ":s/30,30,1;#FFFFFF", 0, 0
  lsph SP_TMP3, ":s/30,30,1;#FFFFFF", 0, 0
  return

*draw_staff_l8
  lsph SP_TMP,  ":s/30,30,1;#FFFFFFMain Graphic         taso", 0, 0
  lsph SP_TMP1, ":s/30,30,1;#FFFFFF", 0, 0
  lsph SP_TMP2, ":s/30,30,1;#FFFFFF", 0, 0
  lsph SP_TMP3, ":s/30,30,1;#FFFFFF", 0, 0
  return

*draw_staff_l9
  lsph SP_TMP,  ":s/30,30,1;#FFFFFFSubgraphic         Haruma K7", 0, 0
  lsph SP_TMP1, ":s/30,30,1;#FFFFFF                         bugyo", 0, 0
  lsph SP_TMP2, ":s/30,30,1;#FFFFFF                         Mido     ", 0, 0
  lsph SP_TMP3, ":s/30,30,1;#FFFFFF", 0, 0
  return

*draw_staff_l10
  lsph SP_TMP,  ":s/30,30,1;#FFFFFFDotter Haruma K7", 0, 0
  lsph SP_TMP1, ":s/30,30,1;#FFFFFF", 0, 0
  lsph SP_TMP2, ":s/30,30,1;#FFFFFF", 0, 0
  lsph SP_TMP3, ":s/30,30,1;#FFFFFF", 0, 0
  return

*draw_staff_l11
  lsph SP_TMP,  ":s/30,30,1;#FFFFFFMagic Circle Provided by Seizitu", 0, 0
  lsph SP_TMP1, ":s/30,30,1;#FFFFFF", 0, 0
  lsph SP_TMP2, ":s/30,30,1;#FFFFFF", 0, 0
  lsph SP_TMP3, ":s/30,30,1;#FFFFFF", 0, 0
  return

*draw_staff_l12
  lsph SP_TMP,  ":s/30,30,1;#FFFFFFMain Programmer          zick", 0, 0
  lsph SP_TMP1, ":s/30,30,1;#FFFFFF", 0, 0
  lsph SP_TMP2, ":s/30,30,1;#FFFFFF", 0, 0
  lsph SP_TMP3, ":s/30,30,1;#FFFFFF", 0, 0
  return

*draw_staff_l13
  lsph SP_TMP,  ":s/30,30,1;#FFFFFFMini Game       zick", 0, 0
  lsph SP_TMP1, ":s/30,30,1;#FFFFFF", 0, 0
  lsph SP_TMP2, ":s/30,30,1;#FFFFFF", 0, 0
  lsph SP_TMP3, ":s/30,30,1;#FFFFFF", 0, 0
  return

*draw_staff_l14
  lsph SP_TMP,  ":s/30,30,1;#FFFFFFOther miscellaneous tasks     Bugyo", 0, 0
  lsph SP_TMP1, ":s/30,30,1;#FFFFFF", 0, 0
  lsph SP_TMP2, ":s/30,30,1;#FFFFFF", 0, 0
  lsph SP_TMP3, ":s/30,30,1;#FFFFFF", 0, 0
  return

*draw_staff_l15
  lsph SP_TMP,  ":s/30,30,1;#FFFFFFHousekeeper       jaru   ", 0, 0
  lsph SP_TMP1, ":s/30,30,1;#FFFFFF                        nathki", 0, 0
  lsph SP_TMP2, ":s/30,30,1;#FFFFFF", 0, 0
  lsph SP_TMP3, ":s/30,30,1;#FFFFFF", 0, 0
  return

*draw_staff_l16
  lsph SP_TMP,  ":s/30,30,1;#FFFFFFCat Ears　　　nathki", 0, 0
  lsph SP_TMP1, ":s/30,30,1;#FFFFFF", 0, 0
  lsph SP_TMP2, ":s/30,30,1;#FFFFFF", 0, 0
  lsph SP_TMP3, ":s/30,30,1;#FFFFFF", 0, 0
  return

*draw_staff_l17
  lsph SP_TMP,  ":s/30,30,1;#FFFFFFDebug         nathki", 0, 0
  lsph SP_TMP1, ":s/30,30,1;#FFFFFF                  Tech      ", 0, 0
  lsph SP_TMP2, ":s/30,30,1;#FFFFFF                  taku      ", 0, 0
  lsph SP_TMP3, ":s/30,30,1;#FFFFFF                  Rin       ", 0, 0
  return

*draw_staff_l18
  lsph SP_TMP,  ":s/30,30,1;#FFFFFFWeb Promotion      bokko", 0, 0
  lsph SP_TMP1, ":s/30,30,1;#FFFFFF                   bugyo", 0, 0
  lsph SP_TMP2, ":s/30,30,1;#FFFFFF", 0, 0
  lsph SP_TMP3, ":s/30,30,1;#FFFFFF", 0, 0
  return

*draw_staff_l19
  lsph SP_TMP,  ":s/30,30,1;#FFFFFFMusic provided by SENTIVE", 0, 0
  lsph SP_TMP1, ":s/30,30,1;#FFFFFF", 0, 0
  lsph SP_TMP2, ":s/30,30,1;#FFFFFF", 0, 0
  lsph SP_TMP3, ":s/30,30,1;#FFFFFF", 0, 0
  return

*draw_staff_l20
  lsph SP_TMP,  ":s/30,30,1;#FFFFFFSupporter       nao", 0, 0
  lsph SP_TMP1, ":s/30,30,1;#FFFFFF               Arumi-san", 0, 0
  lsph SP_TMP2, ":s/30,30,1;#FFFFFF", 0, 0
  lsph SP_TMP3, ":s/30,30,1;#FFFFFF", 0, 0
  return

*draw_staff_l21
  lsph SP_TMP,  ":s/30,30,1;#FFFFFFProduction       λ＋Karasumidou", 0, 0
  lsph SP_TMP1, ":s/30,30,1;#FFFFFF", 0, 0
  lsph SP_TMP2, ":s/30,30,1;#FFFFFF", 0, 0
  lsph SP_TMP3, ":s/30,30,1;#FFFFFF", 0, 0
  return

*title_back
  stop
  csp SP_R
  bg black, 1
  goto *title