;;;;;;;;;;
;;;íçà”
;;;  Supplementary explanation and glossary are accessed with gosub
;;;;;;;;;;

;;;;;Supplementary Explanation;;;;;
;;;Jump to each supplement with goto (necessary due to choices)
;;;Jump from each supplement to *condicil_loop with goto
;;;Judgment in clear status is performed at *condicil_loop
;;;;;
*condicil
  speak_mode
  textclear
  csp SP_R : csp SP_L
  r_load ari_n
  bg "img/blackboard.bmp", E_FAST
*condicil_loop
  if %adv_clear == 0 goto *condicil_00
  if %adv_clear == 1 goto *condicil_01
  if %adv_clear == 2 goto *condicil_02
  if %adv_clear == 3 goto *condicil_03
  if %adv_clear == 4 goto *condicil_04
  if %adv_clear == 5 goto *condicil_05
  if %adv_clear == 6 goto *condicil_06
  if %adv_clear == 7 goto *condicil_07
  if %adv_clear == 8 goto *condicil_08
  if %adv_clear == 9 goto *condicil_09
  if %adv_clear == 10 goto *condicil_10
  if %adv_clear == 11 goto *condicil_11
  if %adv_clear == 12 goto *condicil_12
*condicil_end
  textclear
  csp SP_R
  bg black, E_FAST
  return

*condicil_00
Arisa "Select the supplementary explanation you want to read."
  csel "About this software", *cdc_game, "Back", *condicil_end
*condicil_01
Arisa "Select the supplementary explanation you want to read."
  csel "About this software", *cdc_game, "Back", *condicil_end
*condicil_02
Arisa "Select the supplementary explanation you want to read."
  csel "About this software", *cdc_game, "Evaluation of symbols and expressions", *cdc_eval, "Back", *condicil_end
*condicil_03
Arisa "Select the supplementary explanation you want to read."
  csel "About this software", *cdc_game, "Evaluation of symbols and expressions", *cdc_eval, "How to check types", *cdc_type, "Back", *condicil_end
*condicil_04
Arisa "Select the supplementary explanation you want to read."
  csel "About this software", *cdc_game, "Evaluation of symbols and expressions", *cdc_eval, "How to check types", *cdc_type, "list", *cdc_list, "How to draw diagrams", *cdc_chart, "Improper lists", *cdc_improperlist, "Back", *condicil_end
*condicil_05
Arisa "Select the supplementary explanation you want to read."
  csel "About this software", *cdc_game, "Evaluation of symbols and expressions", *cdc_eval, "How to check types", *cdc_type, "list", *cdc_list, "How to draw diagrams", *cdc_chart, "Improper lists", *cdc_improperlist, "cxr", *cdc_cxr, "Back", *condicil_end
*condicil_06
Arisa "Select the supplementary explanation you want to read."
  csel "About this software", *cdc_game, "Evaluation of symbols and expressions", *cdc_eval, "How to check types", *cdc_type, "list", *cdc_list, "How to draw diagrams", *cdc_chart, "Improper lists", *cdc_improperlist, "cxr", *cdc_cxr, "Create if with cond?", *cdc_condif, "Recursion by substitution", *cdc_recursion, "Back", *condicil_end
*condicil_07
Arisa "Select the supplementary explanation you want to read."
  csel "About this software", *cdc_game, "Evaluation of symbols and expressions", *cdc_eval, "How to check types", *cdc_type, "list", *cdc_list, "How to draw diagrams", *cdc_chart, "Improper lists", *cdc_improperlist, "cxr", *cdc_cxr, "Create if with cond?", *cdc_condif, "Recursion by substitution", *cdc_recursion, "Scope differences by dialect", *cdc_scope, "Back", *condicil_end
*condicil_08
Arisa "Select the supplementary explanation you want to read."
  csel "About this software", *cdc_game, "Evaluation of symbols and expressions", *cdc_eval, "How to check types", *cdc_type, "list", *cdc_list, "How to draw diagrams", *cdc_chart, "Improper lists", *cdc_improperlist, "cxr", *cdc_cxr, "Create if with cond?", *cdc_condif, "Recursion by substitution", *cdc_recursion, "Scope differences by dialect", *cdc_scope, "Functions with exclamation mark!", *cdc_ban, "Back", *condicil_end
*condicil_09
Arisa "Select the supplementary explanation you want to read."
  csel "About this software", *cdc_game, "Evaluation of symbols and expressions", *cdc_eval, "How to check types", *cdc_type, "list", *cdc_list, "How to draw diagrams", *cdc_chart, "Improper lists", *cdc_improperlist, "cxr", *cdc_cxr, "Create if with cond?", *cdc_condif, "Recursion by substitution", *cdc_recursion, "Scope differences by dialect", *cdc_scope, "Functions with exclamation mark!", *cdc_ban, "Tail recursion by substitution", *cdc_tailrecursion, "Shared structure of lists", *cdc_listshare, "Back", *condicil_end
*condicil_10
Arisa "Select the supplementary explanation you want to read."
  csel "About this software", *cdc_game, "Evaluation of symbols and expressions", *cdc_eval, "How to check types", *cdc_type, "list", *cdc_list, "How to draw diagrams", *cdc_chart, "Improper lists", *cdc_improperlist, "cxr", *cdc_cxr, "Create if with cond?", *cdc_condif, "Recursion by substitution", *cdc_recursion, "Scope differences by dialect", *cdc_scope, "Functions with exclamation mark!", *cdc_ban, "Tail recursion by substitution", *cdc_tailrecursion, "Shared structure of lists", *cdc_listshare, "eval", *cdc_eval2, "apply", *cdc_apply, "append", *cdc_append, "Back", *condicil_end
*condicil_11
Arisa "Select the supplementary explanation you want to read."
  csel "About this software", *cdc_game, "Evaluation of symbols and expressions", *cdc_eval, "How to check types", *cdc_type, "list", *cdc_list, "How to draw diagrams", *cdc_chart, "Improper lists", *cdc_improperlist, "cxr", *cdc_cxr, "Create if with cond?", *cdc_condif, "Recursion by substitution", *cdc_recursion, "Scope differences by dialect", *cdc_scope, "Functions with exclamation mark!", *cdc_ban, "Tail recursion by substitution", *cdc_tailrecursion, "Shared structure of lists", *cdc_listshare, "eval", *cdc_eval2, "apply", *cdc_apply, "append", *cdc_append, "Rest parameter", *cdc_restparameter, "Back", *condicil_end
*condicil_12
Arisa "Select the supplementary explanation you want to read."
  csel "About this software", *cdc_game, "Evaluation of symbols and expressions", *cdc_eval, "How to check types", *cdc_type, "list", *cdc_list, "How to draw diagrams", *cdc_chart, "Improper lists", *cdc_improperlist, "cxr", *cdc_cxr, "Create if with cond?", *cdc_condif, "Recursion by substitution", *cdc_recursion, "Scope differences by dialect", *cdc_scope, "Functions with exclamation mark!", *cdc_ban, "Tail recursion by substitution", *cdc_tailrecursion, "Shared structure of lists", *cdc_listshare, "eval", *cdc_eval2, "apply", *cdc_apply, "append", *cdc_append, "Rest parameter", *cdc_restparameter, "Division of dango count", *cdc_div, "Back", *condicil_end

*cdc_game
ArisaÅuI'll briefly explain this software. @/
This software is something that makes you feel like youÅfre learning Lisp by actually interacting with it while reading the story. @/
If you seriously want to learn Lisp, I recommend buying a proper book and studying it. @/
Well, I'd still be happy if you played with this software though... @
Besides the main game, thereÅfs this supplementary explanation and glossary. @/
Both are written to explain things that couldn't be said in the main narrative and will increase as the story progresses.Åv\
ArisaÅuFor those who know about Lisp without doing something like this, I've prepared a free mode. @/
This is a feature just for messing around with NScripter. @/
The Lisp dealt with here is Scheme-like, and the names of built-in functions are mostly Scheme. @/
However, as for the content... well, let's say itÅfs an original Lisp dialect. @/
The function and variable namespaces are the same, so things like funcall are unnecessary. @/
However, there are some odd parts here and there, so itÅfs hard to say it's a subset of Scheme.Åv\
  goto *condicil_loop

*cdc_calc
Alisa: Let's briefly review the four arithmetic operations.@
Addition#33FF33(+ 1 1)#FFFFFFÅÀ#33FF332#FFFFFF@
Subtraction#33FF33(- 5 2)#FFFFFFÅÀ#33FF333#FFFFFF@
Multiplication#33FF33(* 6 4)#FFFFFFÅÀ#33FF3324#FFFFFF@
Division#33FF33(/ 9 3)#FFFFFFÅÀ#33FF333#FFFFFF@
"ÅÀ" is used to mean "The evaluation result is..." \
Arisa "The characteristic of all of them is that they are written
#33FF33 (operator number 1 number 2) #FFFFFF
. @/
In the parentheses, the #FFFF33operator and the #FFFFFFoperand appear in that order. @/
In Lisp, this order is the same for all, not just the four arithmetic operations, and expressions are written
#33FF33(operator operand 1 operand 2... operand n) #FFFFFF. \
goto *condicil_loop

*cdc_eval
Alisa: Let's briefly review symbol and expression evaluation.@
First, expression evaluation is performed using two things: the #FFFF33expression#FFFFFF to be evaluated, and the #FFFF33environment#FFFFFF.@/
The environment contains variable binding information.@/
When a symbol is evaluated, the variable's value is searched for in this environment, and that becomes the result.@/
Once #33FF33(define x 2)#FFF When FFF is evaluated, the environment remembers that "x is bound to 2." @/
The same environment is used for subsequent evaluations, so/
#33FF33x#FFFFFF will result in 2. @
On the other hand, when you evaluate a number, the result is the same number as before the evaluation. @/
When evaluating an expression like #33FF33(+6 7)#FFFFFF, 6 is evaluated to 6,
7 is evaluated to 7, and then + is added to give the result 13." \
goto *condicil_loop

*cdc_type
ArisaÅu#FFFF33Type#FFFFFF refers to the kind of value.@/
For example, the type of the value #33FF33'57'#FFFFFF is 'number',@/
while the type of the value #33FF33'shamal'#FFFFFF is 'symbol.'@/
In some programming languages, variables are associated with types,/
but in Lisp, values are associated with types.@/
Therefore, you can bind any variable to a value of any type you like.Åv\
ArisaÅuAdditionally, there are also functions prepared to check the type of values,
#33FF33/
(number? 19) ÅÀ #t
(symbol? 19) ÅÀ #f
(number? 'a) ÅÀ #f
(symbol? 'a) ÅÀ #t#FFFFFF
The function #33FF33number?#FFFFFF returns the value #33FF33#t#FFFFFF if the argument type is a number; otherwise, it returns #33FF33#f#FFFFFF.@/
The function #33FF33symbol?#FFFFFF returns the value #33FF33#t#FFFFFF if the argument type is a symbol; otherwise, it returns #33FF33#f#FFFFFF.@/
The meaning and usage of these two values will be covered in episode 6.@/
For now, remember that there are functions to check the #FFFF33type of a value#FFFFFF.Åv\
  goto *condicil_loop

*cdc_list
Arisa: "There's a handy function for making lists, #33FF33list#FFFFFF.@
This function takes any number of arguments, and is used like this:@
#33FF33/
(list 1 2 3) ÅÀ (1 2 3) #FFFFFF
This alone might seem the same as writing #33FF33'(1 2 3) #FFFFFF, but@
#33FF33/
(define x 2) ÅÀ x
(list 1 x 3) ÅÀ (1 2 3) #FFFFFF
As you can see from this example, list evaluates its arguments.@/
Even if you simply quote a list, #33FF33'(1 x 3) #FFFFFF,/
the value of the expression will only be #33FF33(1 x 3) #FFFFFF.@/
Please consider this difference and use quote and list appropriately."\
  goto *condicil_loop

*cdc_chart
ArisaÅuWhen thinking about the structure of a list, it's effective to draw diagrams. @/
Diagrams can surprisingly be drawn with simple rules.Åv\
ArisaÅuLet's consider a list like #33FF33ÅiA X Y BÅj#FFFFFF. @/
First, when you see the list, draw two boxes, draw an arrow downward from the first box, and describe the first element there. In this case, it's #33FF33A#FFFFFF.@/
Then, draw an arrow to the right from the second box and there, draw the diagram of the remaining part of the list. @/
  show_dgm ":l;img/dgm_cdc_chart01a.bmp"
The remaining part, in this case, is #33FF33ÅiX Y BÅj#FFFFFF, so this time take out X instead of A and do the same. @/
When you reach the last element of the list, draw an arrow downward from the first box, write the last element there, and draw a slash in the second box. @/
  show_dgm ":l;img/dgm_cdc_chart01b.bmp"
This slash means 'an empty list is included'. With this, you can now draw a simple list diagram.Åv\
  csp SP_DGM0 : print E_FAST
ArisaÅuNext, let's consider a cons like #33FF33ÅiA . BÅj#FFFFFF. @/
This involves drawing two boxes, drawing an arrow to the CAR element from the first, and an arrow to the CDR element from the second. @/
  show_dgm ":l;img/dgm_cdc_chart02a.bmp"
Lastly, let's also consider a poorly-formed list like #33FF33ÅiX A . BÅj#FFFFFF. @/
This initially follows the same method as a normal list, but leaves a cons like #33FF33ÅiA . BÅj#FFFFFF at the end,/
so just follow the same method as before. @/
  show_dgm ":l;img/dgm_cdc_chart02b.bmp"
If you can draw diagrams of normal lists, you should be able to draw this one too.Åv\
  csp SP_DGM0 : print E_FAST
ArisaÅuNow, let's look at a slightly more complex example. @/
The parts we've previously represented in capital letters like #33FF33A#FFFFFF can also be lists. @
#33FF33ÅiÅia . bÅjcÅidÅjÅj#FFFFFF
Let's think about drawing this list. @/
First, following the example, draw two boxes and draw an arrow downward from the first box. @/
Then, you draw the first element, #33FF33Åia . bÅj#FFFFFF, but since this is also a cons,/
draw another box and draw arrows to a and b. @/
  show_dgm ":l;img/dgm_cdc_chart03a.bmp"
Afterward, by applying the rules I've said so far, you should be able to draw the diagram naturally. @/
  show_dgm ":l;img/dgm_cdc_chart03b.bmp"
I recommend you draw a diagram each time you see an appropriate list until you can easily draw diagrams.Åv\
  csp SP_DGM0 : print E_FAST
  goto *condicil_loop

*cdc_improperlist
Arisa: "A list is@
1. An empty list
2. A cons with a list in its CDR.@/
You might feel it's strange to use the word list in "2" when I'm explaining about lists.@/
First of all, from "1", an empty list is a list.@/
Then, from "2", a cons with an empty list in its CDR is also a list.@/
And a cons with that cons as its CDR can also be called a list.@/
Anyway, a list is#FFFF33The CDR of the last cons is always the empty list#FFFFFF.@/
So, what if the CDR of the last cons is something other than an empty list, like#33FF33(a b c)#FFFFFF?@/
This is called#FFFF33a naughty list#FFFFFF.@/
Normally, if you send a naughty list to a "function that does ____ on a list", you'll get an incorrect result.@/
I think it's better not to use naughty lists too much until you understand lists to a certain extent."\
  goto *condicil_loop

*cdc_cxr
Arisa: "In Lisp, there are many times when you want to use car and cdr together. @/
For example, #33FF33(car (car x)) #FFFFFF or #33FF33(car (cdr x)) #FFFFFF. @/
Since these are used frequently, functions are provided to make them easier to write, and they can be written as #33FF33(caar x) #FFFFFF and #33FF33(cadr x) #FFFFFF. @/
#33FF33caar#FFFFFF is a function that takes CAR after taking CAR, /
#33FF33cadr#FFFFFF is a function that takes the CAR after taking the CDR. @/
There are many other similar functions that swap a and d, such as #33FF33cdar#FFFFFF. @/
The names of these functions start with c and end with r. @/
Some systems provide longer names like #33FF33cadaddadr#FFFFFF, but /
NSCLisper only provides two in a row, like #33FF33cxxr#FFFFFF. Be careful.\
  goto *condicil_loop

*cdc_condif
Arisa: Let's create an if using cond.
#33FF33/
 (define my-if
  (lambda (c x y)
   (cond
    (c x)
    (else y))))#FFFFFF
This is how I created the function#33FF33my-if#FFFFFF.@
#33FF33/
 (my-if (= 0 0)
        1
        2)ÅÀ1#FFFFFF
When I tried using it, I got this result, and it seems fine at first glance, but there's actually a problem.@/
Why do you think that is?\
Arisa: The problem is that my-if is a function, so it evaluates the arguments. I'll do it.
#33FF33
(my-if (= n 0)
       0
       (f (- n 1)))#FFFFFF
When you try to evaluate this expression, the function f will be called regardless of the value of n. @/
In other words, if you try to write recursion using my-if, the function will keep being called and will never finish. @/
In other words, since it's a function, you can't write if using cond or vice versa. @/
If you want to do that, you can use something called the #FFFF33macro#FFFFFF, but/
NScLisper doesn't implement macros, so I won't go into detail here.\
  goto *condicil_loop

*cdc_recursion
Arisa: "When thinking about calling a function, we've heard that it's easier to understand if you replace formal arguments with actual arguments.@/
Let's think about this with a function that uses recursion.@
#33FF33/
 (define f
  (lambda (n)
   (if
    (= n 0)
    1
    (* n (f (- n 1))))))#FFFFFF
After defining the function f like this,#33FF33(f 2)#FFFFFF Let's consider the case where the following expression is evaluated. @/
If you replace the formal argument n in the function with the actual argument 2, it becomes as follows. @
#33FF33/
 (if
  (=2 0)
  1
  (*2 (f (-2 1))))))#FFFFFF
Since the third argument is evaluated by @if, what is evaluated is the following expression:
#33FF33/
 (*2 (f (-2 1)))#FFFFFF
@/
In this, #33 It also contains a function call FF33(f (-2 1))#FFFFFF." \
Alisa: Now, let's consider replacing the formal argument n with the actual argument 1 in the f call part of #33FF33(* 2 (f (-2 1)))#FFFFFF. @/
However, the if part will only extract the expression that is evaluated. Then, @
#33FF33/
 (* 2 (* 1 (f (-1 1))))#F FFFFF
Furthermore, if we replace the formal argument n with the actual argument 0, then @
#33FF33/
 (* 2 (* 1 1))#FFFFFF
The function call is finally complete and the value of the expression can be found." \
Arisa: "The important thing here is that with functions like this, the actual calculation (multiplication in this case) has to wait until the recursion is complete. @/
The characteristic of this is that as you replace the evaluated subexpressions, the expression gets longer and longer." \
goto *condicil_loop

*cdc_scope
Alisa: Let's consider the following three expressions.
#33FF33
 (define y 1)
 (define f
  (lambda (x)
   (+x y)))
 (define g
  (lambda (y)
   (f 2)))#FFFFFF
Now, what do you think the value of the expression #33FF33(g 10)#FFFFFF will be?@/
In Scheme, which is a lexical scope, function f cannot see y inside function g.@/
So the value of the global variable y is used, and it becomes #33FF333#FFFFFF.@/
However, in elipse, which is a Lisp dialect, f can see y in g, and the value of the expression becomes #33FF3312#FFFFFF. @/
This is because elipse uses the rule #FFFF33dynamic scope #FFFFFF. @/
In fact, Common Lisp can also partially use dynamic scope, and can do similar things to elipse. @/
I won't go into dynamic scope here, so if you're interested, look it up yourself." \
goto *condicil_loop

*cdc_ban
Arisa: "Starting with #33FF33set! #FFFFFF, there are several functions in Scheme with an exclamation mark at the end of their names. @/
This means that the function is a function that destructively rewrites something. @/
So, functions that call set! internally also have an exclamation mark at the end of their names. @/
By the way, when you pronounce it, this exclamation mark is pronounced as "bang". @/
set! is pronounced as "set bang." \
goto *condicil_loop

*cdc_tailrecursion
Alisa: Let's try using the idea of ??replacing formal arguments with actual arguments for tail-recursive functions.@/
#33FF33/
 (define (f n x)
  (if
   (= n 0)
   x
   (f (- n 1)
      (* n x))))#FFFFFF
Now, let's consider the case where #33FF33(f 2 1)#FFFFFF is evaluated.@/
If we extract only the expression that is evaluated for the if part, first will be changed to @
#33FF33(f (-2 1) (* 2 1))#FFFFFF

This is also a function call, so if you replace the formal parameters n and x with the actual parameters 1 and 2, you get @
#33FF33(f (-1 1) (* 1 2))#FFFFFF

Similarly, if you replace the formal parameters n and x with the actual parameters 0 and 2, you get #33FF332#FFFFFF. @/
Unlike normal recursion, the expression does not become longer even if you replace it with the evaluated subexpression.

So it automatically changes to a simple repetition form."\
  goto *condicil_loop

*cdc_listshare
ArisaÅuWhen performing destructive operations on lists, you need to be concerned about whether the cons is shared. @/
In that case, the minimum thing to remember is that using car and cdr will cause them to be shared. @/
  show_dgm ":l;img/dgm_cdc_listshare01.bmp"
  csp SP_DGM0 : print E_FAST
And using cons will always create a new cons, so it won't be shared. @/
Therefore, when creating a new list, cons will be called repeatedly. @/
For example, let's consider a function to copy a list.
#33FF33/
(define (cp l)
  (if
    (null? l)
    '()
    (cons
      (car l)
      (cp (cdr l)))))#FFFFFF
With this, it looks like you can copy without sharing cons, but actually, there's a problem.Åv\
ArisaÅuIn this definition, if there is a cons in the CAR of the cons like #33FF33 ((a) b) #FFFFFF, that cons will be shared. @/
  show_dgm ":l;img/dgm_cdc_listshare02.bmp"
  csp SP_DGM0 : print E_FAST
So, you can use the predicate #33FF33 pair? #FFFFFF to verify the type is cons and rewrite it like this. @
#33FF33
(define (cp l)
  (if
    (pair? l)
    (cons (cp (car l))
          (cp (cdr l)))
    l))#FFFFFF
Of course, pair? is a function that returns #t if the argument's type is cons, and #f otherwise.
By recursively calling cp in this way, you can copy a list without sharing cons. @/
It might be a little complicated, but if you think about it carefully, you will naturally understand how it works.Åv\
  goto *condicil_loop

*cdc_eval2
Arisa: "When you give a quoted expression as an argument to the function #33FF33eval#FFFFFF, it will evaluate that expression. @/
But don't you think something is missing to evaluate an expression? @/
That's right. To evaluate an expression, you always need an "environment". @/
In NScLisper, eval uses the global environment as the environment to evaluate an expression, /
but some systems specify the environment as the second argument to eval. @/
You'll have to look up the details yourself, such as how to get the environment." \
goto *condicil_loop

*cdc_apply
Arisa: "One of the useful functions in Lisp is #33FF33apply#FFFFFF.@/
This takes a function and a #FFFF33argument list#FFFFFF and calls the function.@/
Let's try using it for now.@
#33FF33
 (apply + '(1 2)) ÅÀ 3
 (apply cons
        '(a b)) ÅÀ (a . b)#FFFFFF
The useful thing about this function is that it allows you to pass arguments to a function in the form of a list.@/
How is it useful...@/
You'll definitely realize how useful it is when you need to use it."\
goto *condicil_loop

*cdc_append
Arisa: "At the end of episode 10, we said/
"A function that takes #33FF33(a b) #FFFFFF and #33FF33(c d) #FFFFFF and returns #33FF33(a b c d) #FFFFFF"/
Let's make something like that. @/
; I want a diagram
All we have to do is replace the empty list at the end of the first argument with the second argument, If you rewrite the function that copies the list a little, it will work. @
#33FF33
 (define (f x y)
  (if
   (null? x)
   y
   (cons
    (car x)
    (f (cdr x) y))))#FFFFFF
By the way, Lisp usually has a function called #33FF33append#FFFFFF that does the same thing.
  goto *condicil_loop

*cdc_restparameter
AlisaÅuUp until now, the functions we've created had a fixed number of arguments, right?@/
Now let's try to create a function that can take an arbitrary number of arguments.@
#33FF33/
(define f
 (lambda x
  x))Å@Å@Å@Å@Å@ÅÀf
(f 1 2 3)Å@ÅÀ(1 2 3)#FFFFFF
Like this, if you write it as #33FF33(lambda variable expression)#FFFFFF,/
the variable is bound to the #FFFF33list of actual arguments#FFFFFF.@/
In the case of a function call like #33FF33(f 1 2 3)#FFFFFF, the list of variables would be #33FF33(1 2 3)#FFFFFFÅv\
AlisaÅuAlso, when taking one or more arbitrary arguments,
/it is good to write it as #33FF33(lambda (x . rest) expression)#FFFFFF. By doing this, x is bound to the first actual argument, and rest is bound to the list of the second and subsequent arguments.@/
In the case of a function call like #33FF33(f 1 2 3)#FFFFFF, the list of the second and subsequent arguments would be #33FF33(2 3)#FFFFFF.@/
Similarly, when taking two or more arbitrary arguments,
/the method is the same even when there are three or more:
#33FF33(lambda (x y . rest) expression)#FFFFFFÅv\
  goto *condicil_loop

*cdc_div
Arisa: "Let's think about dividing the number of dumplings.@/
"x divided by y" can be thought of as finding the number of times y must be subtracted from x before y is greater than x.@/
However, to do this, we first need to create a function that compares which of x and y is greater.@
#33FF33/
 (define (ge? x y)
  (if
   (null? (sub y x))
   #t
   #f))#FFFFFF
This function returns #t if the first argument is greater than or equal to the second argument, and #f if not.@/
Sub is designed to return the number of dumplings as 0 if the subtraction number is greater than or equal to the subtraction number, so we can write it like this."\
Arisa: "Okay, Let's create a division function using this function.

#33FF33/
 (define (div x y)
  (div x y (zero))
 (define (div x y n)
  (if (ge? x y)
   (divi
    (sub x y)
    y (inc n))
  n))#FFFFFF
If y is greater than x, return n.@/
If not, subtract y from x, add 1 to n, and repeat the calculation.@/
This is how you can define division.@/
However, if y is the number of dumplings, 0, the calculation will never finish, so/
it may be better to check with div whether y is 0 or not."\
  goto *condicil_loop

;;;;;Glossary;;;;;
;;;Goto each term with goto (necessary due to choices)
;;;Goto *glossary_loop from each term
;;;Judgment in clear state is done in *glossary_loop
;;;;;
*glossary
  speak_mode
  textclear
  csp SP_R : csp SP_L
  r_load ari_n
  bg "img/blackboard.bmp", E_FAST
  mov %adv_tmp, 0
*glossary_loop
  if %adv_clear == 0 goto *glossary_00
  if %adv_clear == 1 goto *glossary_01
  if %adv_clear == 2 goto *glossary_02
  if %adv_clear == 3 goto *glossary_03
  if %adv_clear == 4 goto *glossary_04
  if %adv_clear == 5 && %adv_tmp == 0 goto *glossary_05
  if %adv_clear == 5 && %adv_tmp == 1 goto *glossary_05_2
  if %adv_clear == 6 && %adv_tmp == 0 goto *glossary_06
  if %adv_clear == 6 && %adv_tmp == 1 goto *glossary_06_2
  if %adv_clear == 7 && %adv_tmp == 0 goto *glossary_07
  if %adv_clear == 7 && %adv_tmp == 1 goto *glossary_07_2
  if %adv_clear == 8 && %adv_tmp == 0 goto *glossary_08
  if %adv_clear == 8 && %adv_tmp == 1 goto *glossary_08_2
  if %adv_clear == 9 && %adv_tmp == 0 goto *glossary_09
  if %adv_clear == 9 && %adv_tmp == 1 goto *glossary_09_2
  if %adv_clear == 10 && %adv_tmp == 0 goto *glossary_10
  if %adv_clear == 10 && %adv_tmp == 1 goto *glossary_10_2
  if %adv_clear == 11 && %adv_tmp == 0 goto *glossary_11
  if %adv_clear == 11 && %adv_tmp == 1 goto *glossary_11_2
  if %adv_clear == 12 && %adv_tmp == 0 goto *glossary_12
  if %adv_clear == 12 && %adv_tmp == 1 goto *glossary_12_2
*glossary_end
  textclear
  csp SP_R
  bg black, E_FAST
  return

*glossary_00
ArisaÅuPlease select the word you want to readÅv
  csel "ÇmÇrÇÉÇkÇâÇìÇêÇÖÇí", *gls_nsclisper, "Return", *glossary_end
*glossary_01
ArisaÅuPlease select the word you want to readÅv
  csel "ÇmÇrÇÉÇkÇâÇìÇêÇÖÇí", *gls_nsclisper, "Lisp", *gls_lisp, "ÇmÇrÇÉÇíÇâÇêÇîÇÖÇí", *gls_nscripter, "Expression", *gls_expr, "Evaluation", *gls_eval, "REPL", *gls_repl, "Operators and Operands", *gls_operator, "Return", *glossary_end
*glossary_02
ArisaÅuPlease select the word you want to readÅv
  csel "ÇmÇrÇÉÇkÇâÇìÇêÇÖÇí", *gls_nsclisper, "Lisp", *gls_lisp, "ÇmÇrÇÉÇíÇâÇêÇîÇÖÇí", *gls_nscripter, "Expression", *gls_expr, "Evaluation", *gls_eval, "REPL", *gls_repl, "Operators and Operands", *gls_operator, "Dialect", *gls_hogen, "Scheme", *gls_scheme,  "Symbol", *gls_symbol, "Number", *gls_num, "Binding", *gls_bind, "Variable", *gls_variable, "Environment", *gls_env, "Return", *glossary_end
*glossary_03
ArisaÅuPlease select the word you want to readÅv
  csel "ÇmÇrÇÉÇkÇâÇìÇêÇÖÇí", *gls_nsclisper, "Lisp", *gls_lisp, "ÇmÇrÇÉÇíÇâÇêÇîÇÖÇí", *gls_nscripter, "Expression", *gls_expr, "Evaluation", *gls_eval, "REPL", *gls_repl, "Operators and Operands", *gls_operator, "Dialect", *gls_hogen, "Scheme", *gls_scheme,  "Symbol", *gls_symbol, "Number", *gls_num, "Binding", *gls_bind, "Variable", *gls_variable, "Environment", *gls_env, "Atom", *gls_atom, "Quote", *gls_quote, "Value", *gls_value, "Function", *gls_function, "Special Form", *gls_special, "Return", *glossary_end
*glossary_04
ArisaÅuPlease select the word you want to readÅv
  csel "ÇmÇrÇÉÇkÇâÇìÇêÇÖÇí", *gls_nsclisper, "Lisp", *gls_lisp, "ÇmÇrÇÉÇíÇâÇêÇîÇÖÇí", *gls_nscripter, "Expression", *gls_expr, "Evaluation", *gls_eval, "REPL", *gls_repl, "Operators and Operands", *gls_operator, "Dialect", *gls_hogen, "Scheme", *gls_scheme,  "Symbol", *gls_symbol, "Number", *gls_num, "Binding", *gls_bind, "Variable", *gls_variable, "Environment", *gls_env, "Atom", *gls_atom, "Quote", *gls_quote, "Value", *gls_value, "Function", *gls_function, "Special Form", *gls_special, "Cons", *gls_cons, "List", *gls_list, "S-expression", *gls_sform, "Address", *gls_address, "Return", *glossary_end
*glossary_05
  mov %adv_tmp, 0
ArisaÅuPlease select the word you want to readÅv
  csel "ÇmÇrÇÉÇkÇâÇìÇêÇÖÇí", *gls_nsclisper, "Lisp", *gls_lisp, "ÇmÇrÇÉÇíÇâÇêÇîÇÖÇí", *gls_nscripter, "Expression", *gls_expr, "Evaluation", *gls_eval, "REPL", *gls_repl, "Operators and Operands", *gls_operator, "Dialect", *gls_hogen, "Scheme", *gls_scheme,  "Symbol", *gls_symbol, "Number", *gls_num, "Binding", *gls_bind, "Variable", *gls_variable, "Environment", *gls_env, "Atom", *gls_atom, "Quote", *gls_quote, "Value", *gls_value, "Function", *gls_function, "Special Form", *gls_special, "Cons", *gls_cons, "List", *gls_list, "S-expression", *gls_sform, "Address", *gls_address, "Mountain É…", *gls_mtlambda, "Lambda", *gls_lambda, "Bound Variable", *gls_bound, "Next", *glossary_05_2, "Return", *glossary_end
*glossary_05_2
  mov %adv_tmp, 1
  csel "Free Variable", *gls_free, "Previous", *glossary_05, "Return", *glossary_end
*glossary_06
  mov %adv_tmp, 0
ArisaÅuPlease select the word you want to readÅv
  csel "ÇmÇrÇÉÇkÇâÇìÇêÇÖÇí", *gls_nsclisper, "Lisp", *gls_lisp, "ÇmÇrÇÉÇíÇâÇêÇîÇÖÇí", *gls_nscripter, "Expression", *gls_expr, "Evaluation", *gls_eval, "REPL", *gls_repl, "Operators and Operands", *gls_operator, "Dialect", *gls_hogen, "Scheme", *gls_scheme,  "Symbol", *gls_symbol, "Number", *gls_num, "Binding", *gls_bind, "Variable", *gls_variable, "Environment", *gls_env, "Atom", *gls_atom, "Quote", *gls_quote, "Value", *gls_value, "Function", *gls_function, "Special Form", *gls_special, "Cons", *gls_cons, "List", *gls_list, "S-expression", *gls_sform, "Address", *gls_address, "Mountain É…", *gls_mtlambda, "Lambda", *gls_lambda, "Bound Variable", *gls_bound, "Next", *glossary_06_2, "Return", *glossary_end
*glossary_06_2
  mov %adv_tmp, 1
  csel "Free Variable", *gls_free, "Recursion", *gls_recursion, "Syntactic Sugar", *gls_syntaxsugar, "Previous", *glossary_06, "Return", *glossary_end
*glossary_07
  mov %adv_tmp, 0
ArisaÅuPlease select the word you want to readÅv
  csel "ÇmÇrÇÉÇkÇâÇìÇêÇÖÇí", *gls_nsclisper, "Lisp", *gls_lisp, "ÇmÇrÇÉÇíÇâÇêÇîÇÖÇí", *gls_nscripter, "Expression", *gls_expr, "Evaluation", *gls_eval, "REPL", *gls_repl, "Operators and Operands", *gls_operator, "Dialect", *gls_hogen, "Scheme", *gls_scheme,  "Symbol", *gls_symbol, "Number", *gls_num, "Binding", *gls_bind, "Variable", *gls_variable, "Environment", *gls_env, "Atom", *gls_atom, "Quote", *gls_quote, "Value", *gls_value, "Function", *gls_function, "Special Form", *gls_special, "Cons", *gls_cons, "List", *gls_list, "S-expression", *gls_sform, "Address", *gls_address, "Mountain É…", *gls_mtlambda, "Lambda", *gls_lambda, "Bound Variable", *gls_bound, "Next", *glossary_07_2, "Return", *glossary_end
*glossary_07_2
  mov %adv_tmp, 1
  csel "Free Variable", *gls_free, "Recursion", *gls_recursion, "Syntactic Sugar", *gls_syntaxsugar, "Global Environment", *gls_globalenv, "Scope", *gls_scope, "Local Variable", *gls_localvar, "Predicate", *gls_predicate, "Mars É…", *gls_mars, "Previous", *glossary_07, "Return", *glossary_end
*glossary_08
  mov %adv_tmp, 0
ArisaÅuPlease select the word you want to readÅv
  csel "ÇmÇrÇÉÇkÇâÇìÇêÇÖÇí", *gls_nsclisper, "Lisp", *gls_lisp, "ÇmÇrÇÉÇíÇâÇêÇîÇÖÇí", *gls_nscripter, "Expression", *gls_expr, "Evaluation", *gls_eval, "REPL", *gls_repl, "Operators and Operands", *gls_operator, "Dialect", *gls_hogen, "Scheme", *gls_scheme,  "Symbol", *gls_symbol, "Number", *gls_num, "Binding", *gls_bind, "Variable", *gls_variable, "Environment", *gls_env, "Atom", *gls_atom, "Quote", *gls_quote, "Value", *gls_value, "Function", *gls_function, "Special Form", *gls_special, "Cons", *gls_cons, "List", *gls_list, "S-expression", *gls_sform, "Address", *gls_address, "Mountain É…", *gls_mtlambda, "Lambda", *gls_lambda, "Bound Variable", *gls_bound, "Next", *glossary_08_2, "Return", *glossary_end
*glossary_08_2
  mov %adv_tmp, 1
  csel "Free Variable", *gls_free, "Recursion", *gls_recursion, "Syntactic Sugar", *gls_syntaxsugar, "Global Environment", *gls_globalenv, "Scope", *gls_scope, "Local Variable", *gls_localvar, "Predicate", *gls_predicate, "Mars É…", *gls_mars, "Side Effect", *gls_sideeffect, "Closure", *gls_closure, "GC", *gls_gc, "Previous", *glossary_08, "Return", *glossary_end
*glossary_09
  mov %adv_tmp, 0
ArisaÅuPlease select the word you want to readÅv
  csel "ÇmÇrÇÉÇkÇâÇìÇêÇÖÇí", *gls_nsclisper, "Lisp", *gls_lisp, "ÇmÇrÇÉÇíÇâÇêÇîÇÖÇí", *gls_nscripter, "Expression", *gls_expr, "Evaluation", *gls_eval, "REPL", *gls_repl, "Operators and Operands", *gls_operator, "Dialect", *gls_hogen, "Scheme", *gls_scheme,  "Symbol", *gls_symbol, "Number", *gls_num, "Binding", *gls_bind, "Variable", *gls_variable, "Environment", *gls_env, "Atom", *gls_atom, "Quote", *gls_quote, "Value", *gls_value, "Function", *gls_function, "Special Form", *gls_special, "Cons", *gls_cons, "List", *gls_list, "S-expression", *gls_sform, "Address", *gls_address, "Mountain É…", *gls_mtlambda, "Lambda", *gls_lambda, "Bound Variable", *gls_bound, "Next", *glossary_09_2, "Return", *glossary_end
*glossary_09_2
  mov %adv_tmp, 1
  csel "Free Variable", *gls_free, "Recursion", *gls_recursion, "Syntactic Sugar", *gls_syntaxsugar, "Global Environment", *gls_globalenv, "Scope", *gls_scope, "Local Variable", *gls_localvar, "Predicate", *gls_predicate, "Mars É…", *gls_mars, "Side Effect", *gls_sideeffect, "Closure", *gls_closure, "GC", *gls_gc, "Destructive List Operation", *gls_listdestructive, "Tail Recursion", *gls_tailrecursion, "Tail Call", *gls_tailcall, "Previous", *glossary_09, "Return", *glossary_end
*glossary_10
  mov %adv_tmp, 0
ArisaÅuPlease select the word you want to readÅv
  csel "ÇmÇrÇÉÇkÇâÇìÇêÇÖÇí", *gls_nsclisper, "Lisp", *gls_lisp, "ÇmÇrÇÉÇíÇâÇêÇîÇÖÇí", *gls_nscripter, "Expression", *gls_expr, "Evaluation", *gls_eval, "REPL", *gls_repl, "Operators and Operands", *gls_operator, "Dialect", *gls_hogen, "Scheme", *gls_scheme,  "Symbol", *gls_symbol, "Number", *gls_num, "Binding", *gls_bind, "Variable", *gls_variable, "Environment", *gls_env, "Atom", *gls_atom, "Quote", *gls_quote, "Value", *gls_value, "Function", *gls_function, "Special Form", *gls_special, "Cons", *gls_cons, "List", *gls_list, "S-expression", *gls_sform, "Address", *gls_address, "Mountain É…", *gls_mtlambda, "Lambda", *gls_lambda, "Bound Variable", *gls_bound, "Next", *glossary_10_2, "Return", *glossary_end
*glossary_10_2
  mov %adv_tmp, 1
  csel "Free Variable", *gls_free, "Recursion", *gls_recursion, "Syntactic Sugar", *gls_syntaxsugar, "Global Environment", *gls_globalenv, "Scope", *gls_scope, "Local Variable", *gls_localvar, "Predicate", *gls_predicate, "Mars É…", *gls_mars, "Side Effect", *gls_sideeffect, "Closure", *gls_closure, "GC", *gls_gc, "Destructive List Operation", *gls_listdestructive, "Tail Recursion", *gls_tailrecursion, "Tail Call", *gls_tailcall, "Previous", *glossary_10, "Return", *glossary_end
*glossary_11
  mov %adv_tmp, 0
ArisaÅuPlease select the word you want to readÅv
  csel "ÇmÇrÇÉÇkÇâÇìÇêÇÖÇí", *gls_nsclisper, "Lisp", *gls_lisp, "ÇmÇrÇÉÇíÇâÇêÇîÇÖÇí", *gls_nscripter, "Expression", *gls_expr, "Evaluation", *gls_eval, "REPL", *gls_repl, "Operators and Operands", *gls_operator, "Dialect", *gls_hogen, "Scheme", *gls_scheme,  "Symbol", *gls_symbol, "Number", *gls_num, "Binding", *gls_bind, "Variable", *gls_variable, "Environment", *gls_env, "Atom", *gls_atom, "Quote", *gls_quote, "Value", *gls_value, "Function", *gls_function, "Special Form", *gls_special, "Cons", *gls_cons, "List", *gls_list, "S-expression", *gls_sform, "Address", *gls_address, "Mountain É…", *gls_mtlambda, "Lambda", *gls_lambda, "Bound Variable", *gls_bound, "Next", *glossary_11_2, "Return", *glossary_end
*glossary_11_2
  mov %adv_tmp, 1
  csel "Free Variable", *gls_free, "Recursion", *gls_recursion, "Syntactic Sugar", *gls_syntaxsugar, "Global Environment", *gls_globalenv, "Scope", *gls_scope, "Local Variable", *gls_localvar, "Predicate", *gls_predicate, "Mars É…", *gls_mars, "Side Effect", *gls_sideeffect, "Closure", *gls_closure, "GC", *gls_gc, "Destructive List Operation", *gls_listdestructive, "Tail Recursion", *gls_tailrecursion, "Tail Call", *gls_tailcall, "Higher Order Function", *gls_higher, "Previous", *glossary_11, "Return", *glossary_end
*glossary_12
  mov %adv_tmp, 0
ArisaÅuPlease select the word you want to readÅv
  csel "ÇmÇrÇÉÇkÇâÇìÇêÇÖÇí", *gls_nsclisper, "Lisp", *gls_lisp, "ÇmÇrÇÉÇíÇâÇêÇîÇÖÇí", *gls_nscripter, "Expression", *gls_expr, "Evaluation", *gls_eval, "REPL", *gls_repl, "Operators and Operands", *gls_operator, "Dialect", *gls_hogen, "Scheme", *gls_scheme,  "Symbol", *gls_symbol, "Number", *gls_num, "Binding", *gls_bind, "Variable", *gls_variable, "Environment", *gls_env, "Atom", *gls_atom, "Quote", *gls_quote, "Value", *gls_value, "Function", *gls_function, "Special Form", *gls_special, "Cons", *gls_cons, "List", *gls_list, "S-expression", *gls_sform, "Address", *gls_address, "Mountain É…", *gls_mtlambda, "Lambda", *gls_lambda, "Bound Variable", *gls_bound, "Next", *glossary_12_2, "Return", *glossary_end
*glossary_12_2
  mov %adv_tmp, 1
  csel "Free Variable", *gls_free, "Recursion", *gls_recursion, "Syntactic Sugar", *gls_syntaxsugar, "Global Environment", *gls_globalenv, "Scope", *gls_scope, "Local Variable", *gls_localvar, "Predicate", *gls_predicate, "Mars É…", *gls_mars, "Side Effect", *gls_sideeffect, "Closure", *gls_closure, "GC", *gls_gc, "Destructive List Operation", *gls_listdestructive, "Tail Recursion", *gls_tailrecursion, "Tail Call", *gls_tailcall, "Higher Order Function", *gls_higher, "Previous", *glossary_12, "Return", *glossary_end

*gls_nsclisper
Arisa: "#FFFF33ÇmScLisper#FFFFFF is a Lisp interpreter created in January 2007 by a university student named #FFFF33zick#FFFFFF. @/
A Lisp interpreter is something that reads, interprets, and calculates programs written in the programming language Lisp. @/
Its unique feature is that it was created on top of #FFFF33ÇmScripter#FFFFFF, which was originally intended for creating games. @/
If you don't understand what I'm talking about, it might be a good idea to think of it as a "high-performance calculator built into the game." @/
That's a bit of a stretch, though. @/
It seems there was no particular reason for creating it, it was just "whimsical," and it never occurred to me that I'd end up using NScLisper to create a game."\
goto *glossary_loop

*gls_lisp
Arisa: #FFFF33Lisp#FFFFFF is a #FFFF33functional language#FFFFFF created by #FFFF33John McCarthy#FFFFFF in 1958. @/
A functional language is a language that makes a computer perform calculations by repeating a simple procedure called #FFFF33function application#FFFFFF. @/
Pure functional languages ??do not allow you to change the value of variables, but Lisp does. @/
The grammar of Lisp programs is very simple, and many people say it is beautiful. @/
However, the large number of parentheses is what puts beginners off. @/
A major feature of Lisp is that there is no distinction between data and code, which we will discuss in the fourth episode.\
  goto *glossary_loop

*gls_nscripter
Alisa: "#FFFF33NScripter#FFFFFF is software created by#FFFF33TakahashiNaoki#FFFFFF to create#FFFF33adventure games#FFFFFF. @/
It's simple, has many functions, and is#FFFF33free for non-commercial use#FFFFFF, so many people use it to create adventure games. @/
Looking at the commands provided, it seems to be designed to run simple action games,/
but I don't think it was designed to run programming language interpreters, do you?"\
  goto *glossary_loop

*gls_expr
Arisa: "#FFFF33 expression#FFFFFF is what's called #FFFF33 program#FFFFFF or #FFFF33 code#FFFFFF./
In other words, it's like a sentence that humans write to give instructions to a computer.@
An expression consists of a single element like
#33FF33elm#FFFFFF
and elements that contain several elements inside parentheses like
#33FF33(elm1 elm2 elm3)#FFFFFF, or nested parentheses like
#33FF33((elm1 (elm2))(elm3))#FFFFFF
.@/
The detailed meaning of these will be explained in the fourth episode."\
  goto *glossary_loop

*gls_eval
ÉAÉäÉTÅu#FFFF33Evaluation#FFFFFF is about obtaining a value from an expression, which is a program written by a person,/
and it corresponds to #FFFF33executing#FFFFFF the program./
When you evaluate an expression, it is characterized by the fact that a #FFFF33result#FFFFFF, a #FFFF33value#FFFFFF, is always returned. @/
When Lisp evaluates a large expression, it evaluates from small parts in order and uses the results to evaluate the large expression. @/
We'll touch on this in episode 2,
#33FF33(+ (* 3 4) 8)#FFFFFF
When you write an expression like this,
#33FF33(* 3 4)#FFFFFF
gets evaluated first. That's what I mean.Åv\
  goto *glossary_loop

*gls_repl
Arisa: "#FFFF33REPL#FFFFFF stands for #FFFF33Read-Evaluate-Print Loop#FFFFFF,/
which refers to the interactive execution cycle of the Lisp interpreter.@/
In interactive mode, the interpreter #FFFF33reads an expression from the keyboard#FFFFFF, #FFFF33evaluates#FFFFFF it, and #FFFF33displays#FFFFFF the result.@/
This series of steps is called REPL.@/
It's also sometimes called the top level.@/
It's useful when trying out different things because you can see the results right away."\
  goto *glossary_loop

*gls_hogen
Arisa: "Lisp was originally created to express a model of calculation, and was not a programming language.@/
Lisp was born as a programming language when a student at MIT implemented it as a program.@/
After that, many people created Lisp interpreters and compilers because the core part of Lisp is easy to implement.@/
However, differences arose due to unique extensions.@/
So each Lisp is called a Lisp#FFFF33Dialect#FFFFFF.@/
Nowadays, when people just say Lisp, they often mean #FFFF33CommonLisp#FFFFFF.@/
CommonLisp is a Lisp packed with many functions, and is very multifunctional.@/
By contrast, #FFFF33Scheme#FFFFFF is a compact language with as few functions as possible.@/
These are the two Lisp dialects that are mainly used today."\
  goto *glossary_loop

*gls_scheme
ArisaÅu#FFFF33Scheme#FFFFFF is a dialect of Lisp created in 1975 by #FFFF33Gerald J. Sussman#FFFFFF and/
#FFFF33Guy L. Steele Jr.#FFFFFF. It features #FFFF33static scoping#FFFFFF, #FFFF33tail-call optimization#FFFFFF, and support for #FFFF33continuations#FFFFFF,/
but we'll skip over those details here. @/
The important thing is that because its functionality is extremely simplified, it is #FFFF33very simple#FFFFFF and yet #FFFF33powerful#FFFFFF. @/
Many people become interested and try Scheme because it is used in the famous book '#FFFF33Structure and Interpretation of Computer Programs#FFFFFF.' @/
By the way, while NScripter's syntax is akin to Scheme, it's not strictly the same, so calling it a 'Scheme-like Lisp dialect'/
might be more accurate.Åv\
  goto *glossary_loop

*gls_symbol
Arisa: "#FFFF33symbol#FFFFFF is the scheme value for expressing #FFFF33name#FFFFFF.@/
A name is a sequence of characters, and cannot contain spaces or parentheses./
Also, if it consists only of numbers, it is considered to be #FFFF33number#FFFFFF and cannot be a symbol."\
goto *glossary_loop

*gls_num
Arisa: "#FFFF33number#FFFFFF is the scheme value that is created when a sequence of numbers is read.@/
The real scheme/
can handle multi-precision integers, rational numbers, complex numbers, etc., but NScLisper can only handle fixed-length integers.@/
It's quite refreshing to be able to handle huge numbers right from the start, so once you understand the scheme to a certain extent,/
I recommend using the real scheme interpreter to try to find the factorial of a large number."\
  goto *glossary_loop

*gls_bind
Arisa: "#FFFF33bind#FFFFFF means to give #FFFF33name#FFFFFF to #FFFF33value#FFFFFF. @/
A value is a number or symbol. A name is a symbol. @/
Specifically, the binding between value and name is stored in #FFFF33environment#FFFFFF. @/
When we simply say #FFFF33bind#FFFFFF, it means the binding between value and name. @/
In Scheme, you can create a new binding by using #33FF33define#FFFFFF."\
  goto *glossary_loop

*gls_variable
Arisa: "#FFFF33variable#FFFFFF is #FFFF33name#FFFFFF associated with #FFFF33value#FFFFFF. @/
In a word, it's #FFFF33bound symbol#FFFFFF. @/
There is no special existence called a variable in Scheme, /
but it's a concept created by the #FFFF33environment#FFFFFF that holds the relationship between symbols and values, /
and the rule that when a symbol is evaluated, it becomes the corresponding value. @/
Normally, if you evaluate an unbound symbol, /
you'll get an error saying "it's not bound." @/
When you write an expression that evaluates a symbol, Scheme considers that symbol to be a variable."\
  goto *glossary_loop

*gls_env
Arisa: "#FFFF33Environment#FFFFFF is a connection between #FFFF33value#FFFFFF and #FFFF33name#FFFFFF/
It's a collection of #FFFF33bindings#FFFFFF. @/
When a symbol is evaluated, the environment searches for the value that binds that symbol and returns that value. @/
It's actually okay if you don't think about the existence of the environment at first. @/
It's a basic entity that forms the rules for Scheme evaluation,/
and Lyrical Lisp goes into detail about it."\
  goto *glossary_loop

*gls_operator
Arisa: "Like #33FF33 (expression 1, expression 2...expression n) #FFFFFF, the first element of an expression enclosed in parentheses, #33FF33 expression 1 #FFFFFF, is called the #FFFF33 operator #FFFFFF, @/
and the other elements, #33FF33 expression 2 through n #FFFFFF, are called the #FFFF33 operand #FFFFFF." \
goto *glossary_loop

*gls_atom
Arisa: "Expressions not enclosed in parentheses are called #FFFF33 atoms #FFFFFF. @/
Specifically, numbers and symbols." \
  goto *glossary_loop

*gls_quote
Arisa: "#FFFF33quote#FFFFFF is a special form that takes one argument and returns it as is. @
When you evaluate #33FF33(quote x)#FFFFFF, the symbol #FFFF33x#FFFFFF is returned as a result. @/
If you use quotation marks, you can write #33FF33'x#FFFFFF." \
  goto *glossary_loop

*gls_value
Arisa: "#FFFF33Value#FFFFFF is data that can be handled in Lisp. @/
It's often called #FFFF33Object#FFFFFF. @/
In Lisp, the expression itself is a value, and the thing you get by evaluating an expression is also a value. @/
Well, I'll explain this in more detail later." \
  goto *glossary_loop

*gls_type
Arisa: #FFFF33 The term "type" #FFFFFF refers to the kind of value. @/
Variables in Lisp can be bound to values of any type."\
  goto *glossary_loop

*gls_function
Arisa: #FFFF33Functions#FFFFFF take several arguments, process them, and return a value. To call a function, you write it as
#33FF33(Function Arg1 Arg2 Åc Argn)#FFFFFF. A function is characterized by evaluating all its arguments before performing the process.
Expressions like #33FF33(+ 1 (* 2 3))#FFFFFF are evaluated by the same rules. From the perspective of +, since #33FF33 1#FFFFFF and #33FF33 (* 2 3)#FFFFFF are arguments, they are evaluated first.
Therefore, even if you nest parentheses, they are evaluated from the inside out"\
  goto *glossary_loop

*gls_special
Arisa: "#FFFF33Special forms #FFFFFF are very similar to functions, but their unique feature is that they don't evaluate their arguments. @/
Many of them don't have a set number of arguments they can take. @/
Special forms are evaluated according to special rules that differ from normal evaluation, so be careful."\
  goto *glossary_loop

*gls_cons
Arisa: "#FFFF33 cons #FFFFFF is a type that can remember two values.@/
It's also called #FFFF33 vs #FFFFFF.@/
It can be created using the cons function,@/
and the car and cdr functions can be used to retrieve the remembered value." \
goto *glossary_loop

*gls_list
Arisa: "#FFFF33 list #FFFFFF is,
structurally, "an empty list or a cons with a list as its CDR",@
and visually, "a list of several values ??in parentheses".@/
So expressions are also lists.@/
When you evaluate a symbol, it becomes the corresponding value.@/
So if you want to get the symbol itself, you use quote.@/
Similarly, when you evaluate a list, it's treated as a function call,/
so if you want to get the list itself, you use quote."\
  goto *glossary_loop

*gls_sform
Arisa: #FFFF33S expression#FFFFFF refers to
1. Atom
2. (S expression . S expression)
For example,
#33FF3311#FFFFFF
#33FF33s#FFFFFF
#33FF33(s . 11)#FFFFFF
#33FF33(t . (s . 11))#FFFFFF
That's what it means"\
Arisa: However,
#33FF33(A . (B . (C . D)))#FFFFFF
This S expression can be written in a simplified form as,
#33FF33(A B C . D)#FFFFFF
Also, if D is an empty list #33FF33()#FFFFFF, it can be further simplified,
#33FF33(A B C)#FFFFFF
However, this is merely an abbreviation in notation, and it doesn't matter which way you write it"\
Arisa: A major feature of Lisp is that all expressions, which are programs, can be represented with S expressions, and/
When displaying the evaluated result, it is also shown using S expressions. @/
However, some values are represented in forms other than S expressions. @/
Therefore, the input format and the output format do not completely match"\
  goto *glossary_loop

*gls_address
Arisa: "You can think of Lisp values ??as being stored in boxes. @/
There are lots of these boxes, and each one has a unique number,/
and this number is called #FFFF33#FFFFFF (Address). @/
If you're wondering what this "box" is, it's actually a computer's memory device, such as memory. @/
By the way, this word "address" is actually not a proper Lisp term. @/
You shouldn't say it too much outside."\
  goto *glossary_loop

*gls_mtlambda
Arisa: "#FFFF33É… Mountain#FFFFFF is located in Higashiyama, Kyoto, and is famous for the Gozan no Okuribi.@/
I don't really know why the mountain is painted with É….@/
On a clear day, the character É… looks like the character 'ëÂ'."\
goto *glossary_loop

*gls_lambda
Arisa: "You might be wondering why we call it #33FF33É…ÇÑÇÅ#FFFFFF to create a function.@/
If you're interested, you should try studying #FFFF33É… calculus#FFFFFF.@/
I recommend the book "Computational Theory: Computability and Lambda Calculus."@/
I think that if you study É… calculus, you'll understand the fun of Lisp once again."\
goto *glossary_loop

*gls_bound
Arisa: "A bound variable is a formal argument. @
#33FF33/
(lambda (x) body) #FFFFFF
For the function obtained as the value of this expression, x is called a bound variable, /
and we say that x is bound to this function. @/
The value of a bound variable is the value of the actual argument given when calling the function. @/
So even if you change the name of a bound variable to something that doesn't appear in #33FF33 body #FFFFFF, the function itself will not change at all."\
  goto *glossary_loop

*gls_free
Arisa: #FFFF33Free variables#FFFFFF are variables other than bound variables that appear in the body of a function.@
#33FF33/
(lambda (x) (+ x y))#FFFFFF
The variable y that appears in the function obtained as the value of this expression is a free variable.@/
The value of a free variable is determined by the environment in which the expression is evaluated.@/
Therefore, a function that contains a free variable may return different values even with the same actual arguments."\
  goto *glossary_loop

*gls_recursion
Arisa: #FFFF33Recursion#FFFFFF is using oneself to define oneself.@
#33FF33/
(define f
Å@(lambda (n)
Å@Å@(if (= n 0)
Å@Å@Å@Å@Å@Å@0
Å@Å@Å@Å@Å@Å@(f (- n 1)))))#FFFFFF
For example, this expression defines f, but the function that is its value uses f within it, right?@/
Calling oneself as a function call is called a #FFFF33recursive call#FFFFFF."\
  goto *glossary_loop

*gls_syntaxsugar
Arisa: "#FFFF33 Syntax Sugar#FFFFFF (Syntax Sugar) is a special syntax that is prepared to easily achieve what can be achieved with existing syntax.@/
Since it is a syntax limited to a specific purpose, if used well, it will improve the visibility of the formula.@/
Syntax Sugar is a syntax that is far from the essence of the language, but it is a syntax that is close to human senses." \
goto *glossary_loop

*gls_scope
Arisa: "#FFFF33 Scope#FFFFFF is the range in which variables can be seen.@/
Scheme and Common Lisp are called #FFFF33 Lexical Scope#FFFFFF,/
and you can see the outside from the inside, but you can't see the inside from the outside.@/
show_dgm ":l;img/dgm_gls_scope01.bmp"
Some Lisp dialects use something different, #FFFF33 Dynamic Scope#FFFFFF."\
csp SP_DGM0 : print E_FAST
goto *glossary_loop

*gls_localvar
Alisa: "A local variable is a variable that can only be used within a specific scope. @/
To create a local variable in Lisp, use lambda or its syntactic sugar, let." \
goto *glossary_loop

*gls_globalenv
Alisa: "#FFFF33The global environment#FFFFFF is the environment used to evaluate expressions entered from the top level. @/
Even if a new environment is created, it will eventually connect to the global environment, so/
#FFFF33The global variable#FFFFFF contained in the global environment can be seen from anywhere." \
goto *glossary_loop

*gls_predicate
Alisa: "#FFFF33Predicate#FFFFFF is a function that returns #33FF33#t#FFFFFF or #33FF33#f#FFFFFF.@/
Basically, the name ends with a '?', like #33FF33number?#FFFFFF or #33FF33symbol?#FFFFFF.@/
However, there are also names that don't end with a '?', like #33FF33=#FFFFFF.@/
This '?' is pronounced 'pee'. It's the first letter of the predicate.@/
In Lisp dialects other than Scheme, there were historically models that didn't allow you to type '?' from the keyboard, so/
many predicates end with a p, like #33FF33numberp#FFFFFF."\
  goto *glossary_loop

*gls_mars
Arisa "Just Google it!"\
Arisa "That's what I want to say, but I'll give you the URL instead.
#FFFF33http://themis.asu.edu/zoom-20040202A#FFFFFF
You will surely see a shocking image."\
  goto *glossary_loop

*gls_sideeffect
Arisa: "#FFFF33Side Effects#FFFFFF are actions that do something other than obtaining a result value. @/
For example, changing the value of a variable or displaying a character would be examples of this." \
goto *glossary_loop

*gls_closure
Arisa: "#FFFF33Closure#FFFFFF (function closure) is the combination of the contents of a function and the environment used for evaluation. @/
By combining the environments, you can obtain the values ??of free variables. @/
In Scheme, function-type values ??created by lambda are closures, so you don't need to worry about this word." \
goto *glossary_loop

*gls_gc
Arisa: #FFFF33GC#FFFFFF (Garbage Collection) is a mechanism for discarding values ??from boxes that contain values ??that are no longer needed and reusing those boxes.@/
Lisp systems are equipped with GC, so programmers no longer need to distinguish between necessary and unnecessary values, making things easier for them.\
goto *glossary_loop

*gls_listdestructive
;;I want a diagram
Arisa: #FFFF33List destructive operation#FFFFFF is an operation that rewrites the contents of a cons.@/
#33FF33set-car!#FFFFFF, #33FF33set-cdr!#FFFFFF are used to perform this.@/
Destructive list operations can also create cyclic structures.@/
show_dgm ":l;img/dgm_gls_listdestructive01.bmp"
csp SP_DGM0 : print E_FAST
When you try to display a list with a circular structure in NScLisper, it will fall into an infinite loop, so /
it's better not to use it until you get used to it." \
goto *glossary_loop

*gls_tailrecursion
Arisa: "#FFFF33 tail recursion #FFFFFF is a recursive call made at the end of a function. @/
The end of a function is the point where the value of the expression becomes the value returned by the function.
When you use tail recursion in Lisp, it is automatically converted to a simple loop rather than a function call, so @/
you can perform processing quickly without wasting memory." \
goto *glossary_loop

*gls_tailcall
Arisa: "#FFFF33 tail call #FFFFFF is a function call made at the end of a function. @/
Scheme converts tail recursion into simple loops, and also converts tail calls into loops.

goto *glossary_loop

*gls_higher
Arisa: #FFFF33 Higher-order functions#FFFFFF are functions that take arguments and return functions. @/
One of the great features of Lisp is that it makes it easy to use higher-order functions. @/
If you want to learn techniques using higher-order functions, study Lisp in a proper book.
  goto *glossary_loop